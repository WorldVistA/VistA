Released HMP*2*1 SEQ #1
Extracted from mail message
**KIDS**:HMP*2.0*1^

**INSTALL NAME**
HMP*2.0*1
"BLD",9997,0)
HMP*2.0*1^HEALTH MANAGEMENT PLATFORM^0^3160709^y
"BLD",9997,4,0)
^9.64PA^^
"BLD",9997,6.3)
4
"BLD",9997,"KRN",0)
^9.67PA^779.2^20
"BLD",9997,"KRN",.4,0)
.4
"BLD",9997,"KRN",.401,0)
.401
"BLD",9997,"KRN",.402,0)
.402
"BLD",9997,"KRN",.403,0)
.403
"BLD",9997,"KRN",.5,0)
.5
"BLD",9997,"KRN",.84,0)
.84
"BLD",9997,"KRN",3.6,0)
3.6
"BLD",9997,"KRN",3.8,0)
3.8
"BLD",9997,"KRN",3.8,"NM",0)
^9.68A^^0
"BLD",9997,"KRN",9.2,0)
9.2
"BLD",9997,"KRN",9.8,0)
9.8
"BLD",9997,"KRN",9.8,"NM",0)
^9.68A^92^29
"BLD",9997,"KRN",9.8,"NM",3,0)
HMPACT^^0^B33127159
"BLD",9997,"KRN",9.8,"NM",4,0)
HMPAT^^0^B3461086
"BLD",9997,"KRN",9.8,"NM",10,0)
HMPCRPC1^^0^B104887301
"BLD",9997,"KRN",9.8,"NM",15,0)
HMPDGMRA^^0^B23357348
"BLD",9997,"KRN",9.8,"NM",17,0)
HMPDJ^^0^B36223990
"BLD",9997,"KRN",9.8,"NM",21,0)
HMPDJ02^^0^B178097048
"BLD",9997,"KRN",9.8,"NM",22,0)
HMPDJ03^^0^B113601878
"BLD",9997,"KRN",9.8,"NM",30,0)
HMPDJ08^^0^B76812256
"BLD",9997,"KRN",9.8,"NM",32,0)
HMPDJ09^^0^B58540657
"BLD",9997,"KRN",9.8,"NM",34,0)
HMPDJ1^^0^B18382483
"BLD",9997,"KRN",9.8,"NM",35,0)
HMPDJ2^^0^B21292359
"BLD",9997,"KRN",9.8,"NM",36,0)
HMPDJFS^^0^B72336462
"BLD",9997,"KRN",9.8,"NM",39,0)
HMPDJFSG^^0^B236965209
"BLD",9997,"KRN",9.8,"NM",40,0)
HMPDJFSM^^0^B91843339
"BLD",9997,"KRN",9.8,"NM",55,0)
HMPEF^^0^B86180151
"BLD",9997,"KRN",9.8,"NM",64,0)
HMPEVNT^^0^B135046428
"BLD",9997,"KRN",9.8,"NM",66,0)
HMPHTTP^^0^B14150503
"BLD",9997,"KRN",9.8,"NM",73,0)
HMPMETA^^0^B127426606
"BLD",9997,"KRN",9.8,"NM",75,0)
HMPPARAM^^0^B16345240
"BLD",9997,"KRN",9.8,"NM",80,0)
HMPPTRPC^^0^B10929781
"BLD",9997,"KRN",9.8,"NM",83,0)
HMPSTMP^^0^B79306076
"BLD",9997,"KRN",9.8,"NM",84,0)
HMPTFU2^^0^B39725294
"BLD",9997,"KRN",9.8,"NM",86,0)
HMPUPD^^0^B25062781
"BLD",9997,"KRN",9.8,"NM",87,0)
HMPUTIL1^^0^B46934983
"BLD",9997,"KRN",9.8,"NM",88,0)
HMPUTILS^^0^B41539926
"BLD",9997,"KRN",9.8,"NM",89,0)
HMPPXRM^^0^B14343853
"BLD",9997,"KRN",9.8,"NM",90,0)
HMPEHL7^^0^B6545280
"BLD",9997,"KRN",9.8,"NM",91,0)
HMPDCRC^^0^B46900881
"BLD",9997,"KRN",9.8,"NM",92,0)
HMPDJFSP^^0^B228347668
"BLD",9997,"KRN",9.8,"NM","B","HMPACT",3)

"BLD",9997,"KRN",9.8,"NM","B","HMPAT",4)

"BLD",9997,"KRN",9.8,"NM","B","HMPCRPC1",10)

"BLD",9997,"KRN",9.8,"NM","B","HMPDCRC",91)

"BLD",9997,"KRN",9.8,"NM","B","HMPDGMRA",15)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJ",17)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJ02",21)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJ03",22)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJ08",30)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJ09",32)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJ1",34)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJ2",35)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJFS",36)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJFSG",39)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJFSM",40)

"BLD",9997,"KRN",9.8,"NM","B","HMPDJFSP",92)

"BLD",9997,"KRN",9.8,"NM","B","HMPEF",55)

"BLD",9997,"KRN",9.8,"NM","B","HMPEHL7",90)

"BLD",9997,"KRN",9.8,"NM","B","HMPEVNT",64)

"BLD",9997,"KRN",9.8,"NM","B","HMPHTTP",66)

"BLD",9997,"KRN",9.8,"NM","B","HMPMETA",73)

"BLD",9997,"KRN",9.8,"NM","B","HMPPARAM",75)

"BLD",9997,"KRN",9.8,"NM","B","HMPPTRPC",80)

"BLD",9997,"KRN",9.8,"NM","B","HMPPXRM",89)

"BLD",9997,"KRN",9.8,"NM","B","HMPSTMP",83)

"BLD",9997,"KRN",9.8,"NM","B","HMPTFU2",84)

"BLD",9997,"KRN",9.8,"NM","B","HMPUPD",86)

"BLD",9997,"KRN",9.8,"NM","B","HMPUTIL1",87)

"BLD",9997,"KRN",9.8,"NM","B","HMPUTILS",88)

"BLD",9997,"KRN",19,0)
19
"BLD",9997,"KRN",19,"NM",0)
^9.68A^7^1
"BLD",9997,"KRN",19,"NM",7,0)
HMP UI CONTEXT^^0
"BLD",9997,"KRN",19,"NM","B","HMP UI CONTEXT",7)

"BLD",9997,"KRN",19.1,0)
19.1
"BLD",9997,"KRN",19.1,"NM",0)
^9.68A^^0
"BLD",9997,"KRN",101,0)
101
"BLD",9997,"KRN",101,"NM",0)
^9.68A^^0
"BLD",9997,"KRN",409.61,0)
409.61
"BLD",9997,"KRN",409.61,"NM",0)
^9.68A^^0
"BLD",9997,"KRN",771,0)
771
"BLD",9997,"KRN",771,"NM",0)
^9.68A^^0
"BLD",9997,"KRN",779.2,0)
779.2
"BLD",9997,"KRN",870,0)
870
"BLD",9997,"KRN",8989.51,0)
8989.51
"BLD",9997,"KRN",8989.51,"NM",0)
^9.68A^^0
"BLD",9997,"KRN",8989.52,0)
8989.52
"BLD",9997,"KRN",8994,0)
8994
"BLD",9997,"KRN",8994,"NM",0)
^9.68A^22^1
"BLD",9997,"KRN",8994,"NM",22,0)
HMP PATIENT SELECT^^0
"BLD",9997,"KRN",8994,"NM","B","HMP PATIENT SELECT",22)

"BLD",9997,"KRN","B",.4,.4)

"BLD",9997,"KRN","B",.401,.401)

"BLD",9997,"KRN","B",.402,.402)

"BLD",9997,"KRN","B",.403,.403)

"BLD",9997,"KRN","B",.5,.5)

"BLD",9997,"KRN","B",.84,.84)

"BLD",9997,"KRN","B",3.6,3.6)

"BLD",9997,"KRN","B",3.8,3.8)

"BLD",9997,"KRN","B",9.2,9.2)

"BLD",9997,"KRN","B",9.8,9.8)

"BLD",9997,"KRN","B",19,19)

"BLD",9997,"KRN","B",19.1,19.1)

"BLD",9997,"KRN","B",101,101)

"BLD",9997,"KRN","B",409.61,409.61)

"BLD",9997,"KRN","B",771,771)

"BLD",9997,"KRN","B",779.2,779.2)

"BLD",9997,"KRN","B",870,870)

"BLD",9997,"KRN","B",8989.51,8989.51)

"BLD",9997,"KRN","B",8989.52,8989.52)

"BLD",9997,"KRN","B",8994,8994)

"BLD",9997,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",9997,"QUES",0)
^9.62^^
"BLD",9997,"REQB",0)
^9.611^^0
"KRN",19,17035,-1)
0^7
"KRN",19,17035,0)
HMP UI CONTEXT^HMP UI Context Version 0.7-S62^^B^^^^^^^^
"KRN",19,17035,1,0)
^19.06^1^1^3140618^^
"KRN",19,17035,1,1,0)
This option allows the HMP UI access to the VistA system.
"KRN",19,17035,99.1)
62990,29647
"KRN",19,17035,"RPC",0)
^19.05P^56^56
"KRN",19,17035,"RPC",1,0)
HMPCORD RPC
"KRN",19,17035,"RPC",2,0)
HMPCPAT RPC
"KRN",19,17035,"RPC",3,0)
HMPFPTC CHKS
"KRN",19,17035,"RPC",4,0)
HMPFPTC LOG
"KRN",19,17035,"RPC",5,0)
HMP APPOINTMENTS
"KRN",19,17035,"RPC",6,0)
HMP DATA VERSION
"KRN",19,17035,"RPC",7,0)
HMP DELETE ROSTER
"KRN",19,17035,"RPC",8,0)
HMP GET PATIENT DATA
"KRN",19,17035,"RPC",9,0)
HMP GET SOURCE
"KRN",19,17035,"RPC",10,0)
HMP INPATIENTS
"KRN",19,17035,"RPC",11,0)
HMP PREVIEW ROSTER
"KRN",19,17035,"RPC",12,0)
HMP ROSTER PATIENTS
"KRN",19,17035,"RPC",13,0)
HMP ROSTERS
"KRN",19,17035,"RPC",14,0)
HMP SUBSCRIBE
"KRN",19,17035,"RPC",15,0)
HMP UPDATE ROSTER
"KRN",19,17035,"RPC",16,0)
HMPCRPC RPC
"KRN",19,17035,"RPC",19,0)
XHD GET PARAMETER DEF LIST
"KRN",19,17035,"RPC",20,0)
HMP PUT PATIENT DATA
"KRN",19,17035,"RPC",21,0)
HMP PUT OBJECT
"KRN",19,17035,"RPC",22,0)
HMP DELETE OBJECT
"KRN",19,17035,"RPC",23,0)
HMP GET OBJECT
"KRN",19,17035,"RPC",24,0)
HMP GET ROSTER LIST
"KRN",19,17035,"RPC",25,0)
HMPCPRS RPC
"KRN",19,17035,"RPC",26,0)
ORQPT WARDS
"KRN",19,17035,"RPC",27,0)
ORQPT WARD PATIENTS
"KRN",19,17035,"RPC",28,0)
ORQPT SPECIALTIES
"KRN",19,17035,"RPC",29,0)
ORQPT SPECIALTY PATIENTS
"KRN",19,17035,"RPC",30,0)
ORWU CLINLOC
"KRN",19,17035,"RPC",31,0)
ORQPT CLINIC PATIENTS
"KRN",19,17035,"RPC",32,0)
ORWU NEWPERS
"KRN",19,17035,"RPC",33,0)
ORQPT PROVIDER PATIENTS
"KRN",19,17035,"RPC",34,0)
ORWRP COLUMN HEADERS
"KRN",19,17035,"RPC",35,0)
ORWLR CUMULATIVE REPORT
"KRN",19,17035,"RPC",36,0)
ORWLRR INTERIM
"KRN",19,17035,"RPC",37,0)
ORWRP REPORT TEXT
"KRN",19,17035,"RPC",38,0)
ORWRP3 EXPAND COLUMNS
"KRN",19,17035,"RPC",39,0)
HMP PUT DEMOGRAPHICS
"KRN",19,17035,"RPC",40,0)
HMPCRPC RPCCHAIN
"KRN",19,17035,"RPC",41,0)
ORQPT DEFAULT PATIENT LIST
"KRN",19,17035,"RPC",42,0)
ORWU USERINFO
"KRN",19,17035,"RPC",43,0)
YTQ ALLKEYS
"KRN",19,17035,"RPC",44,0)
ORWPT BYWARD
"KRN",19,17035,"RPC",45,0)
ORQQPX REMINDERS LIST
"KRN",19,17035,"RPC",46,0)
ORQQPX REMINDER DETAIL
"KRN",19,17035,"RPC",47,0)
ORQQPL4 LEX
"KRN",19,17035,"RPC",48,0)
ORWRP REPORT LISTS
"KRN",19,17035,"RPC",49,0)
HMP PATIENT ADMIT SYNC
"KRN",19,17035,"RPC",50,0)
HMP PATIENT SCHED SYNC
"KRN",19,17035,"RPC",51,0)
ORWPT LIST ALL
"KRN",19,17035,"RPC",52,0)
ORWPT APPTLST
"KRN",19,17035,"RPC",53,0)
HMP CHKXTMP
"KRN",19,17035,"RPC",54,0)
HMP GLOBAL SIZE
"KRN",19,17035,"RPC",55,0)
HMP DEFAULT PATIENT LIST
"KRN",19,17035,"RPC",56,0)
HMP PATIENT SELECT
"KRN",19,17035,"U")
HMP UI CONTEXT VERSION 0.7-S62
"KRN",8994,4000,-1)
0^22
"KRN",8994,4000,0)
HMP PATIENT SELECT^SELECT^HMPPTRPC^2
"KRN",8994,4000,1,0)
^^2^2^3151123^
"KRN",8994,4000,1,1,0)
Selects patients by search criteria and returns basic patient and demographic information for patients
"KRN",8994,4000,1,2,0)
found in search.
"KRN",8994,4000,2,0)
^8994.02A^2^2
"KRN",8994,4000,2,1,0)
CRITERIA^1^10^1^1
"KRN",8994,4000,2,1,1,0)
^^5^5^3151123^
"KRN",8994,4000,2,1,1,1,0)
The type of search to perform. May be one of the following values:
"KRN",8994,4000,2,1,1,2,0)
   LAST5 - "last5" format of ssn (i.e., patient's last intial + last4 of ssn)
"KRN",8994,4000,2,1,1,3,0)
   NAME - search by patient name, can be partial name
"KRN",8994,4000,2,1,1,4,0)
   ICN - select patient by ICN
"KRN",8994,4000,2,1,1,5,0)
   PID - select patient by PID
"KRN",8994,4000,2,2,0)
SEARCH TERM^1^60^1^2
"KRN",8994,4000,2,2,1,0)
^8994.021^1^1^3151123^^
"KRN",8994,4000,2,2,1,1,0)
Term to search for when looking up patient. Should match type specified in CRITERIA.
"KRN",8994,4000,2,"B","CRITERIA",1)

"KRN",8994,4000,2,"B","SEARCH TERM",2)

"KRN",8994,4000,2,"PARAMSEQ",1,1)

"KRN",8994,4000,2,"PARAMSEQ",2,2)

"KRN",8994,4000,3,0)
^^4^4^3151123^
"KRN",8994,4000,3,1,0)
Returns a list of patient data, one line per patient, in format:
"KRN",8994,4000,3,2,0)
   Full Name^Family Name^Given Name(s)^Display Name^Gender Code^Gender Name^SSN^Last4^Last5^Date of birth^Sensitive^LocalId^PID^ICN^Summary
"KRN",8994,4000,3,3,0)
Or returns -1^Error message if error
"KRN",8994,4000,3,4,0)
If no patients found, returns empy list
"MBREQ")
0
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",603,-1)
1^1
"PKG",603,0)
HEALTH MANAGEMENT PLATFORM^HMP^Access patient medical records from all VistA's
"PKG",603,20,0)
^9.402P^^
"PKG",603,22,0)
^9.49I^1^1
"PKG",603,22,1,0)
2.0^3160223^3160329^100904
"PKG",603,22,1,"PAH",1,0)
1^3160709^100904
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
29
"RTN","HMPACT")
0^3^B33127159^B34386179
"RTN","HMPACT",1,0)
HMPACT ;ASMR/EJK/PB/JD - Patient Appointment Broker Call;May 15, 2016 14:15
"RTN","HMPACT",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPACT",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPACT",4,0)
 ;
"RTN","HMPACT",5,0)
 ; 2/16/16 - JD - Removed the check in line tag ADMIT to allow processing of all patients
"RTN","HMPACT",6,0)
 ;                regardless of their subscription. DE3375
"RTN","HMPACT",7,0)
 ;
"RTN","HMPACT",8,0)
 ; Feb 24, 2016 - PB removed the check in linetag SCHED that quit
"RTN","HMPACT",9,0)
 ; processing if the patient was registered in HMP(800000 as requested in DE2991
"RTN","HMPACT",10,0)
 Q
"RTN","HMPACT",11,0)
ACT(ROOT,DFN,ID,ALPHA,OMEGA,DTRANGE,REMOTE,MAX,ORFHIE) ;
"RTN","HMPACT",12,0)
 N ERR,ERRMSG,DFN,IEN,DIE,HMSTOP
"RTN","HMPACT",13,0)
 S ERR=0,ERRMSG="",DFN="",IEN="",HMSTOP=0
"RTN","HMPACT",14,0)
 S ROOT="XWBY"
"RTN","HMPACT",15,0)
 K ^TMP("ORDATA",$J)
"RTN","HMPACT",16,0)
 Q:'$D(^HMP(800001.5,"PTAPPT","HMP"))
"RTN","HMPACT",17,0)
 S DIE="^HMP(800001.5,""PTAPPT"","
"RTN","HMPACT",18,0)
 D FETCH
"RTN","HMPACT",19,0)
 D CLEAN
"RTN","HMPACT",20,0)
 Q
"RTN","HMPACT",21,0)
 ;
"RTN","HMPACT",22,0)
FETCH ;GET PENDING JSON MESSAGES AND UPDATE DATE RECORD RETRIEVED
"RTN","HMPACT",23,0)
 S X="[" D SETITEM(.ROOT,X)
"RTN","HMPACT",24,0)
 F  S IEN=$O(^HMP(800001.5,"PTAPPT","HMP",IEN)) Q:IEN=""!(HMSTOP)  D
"RTN","HMPACT",25,0)
 . S X=$G(^HMP(800001.5,"PTAPPT",IEN,"JSON"))
"RTN","HMPACT",26,0)
 . I $O(^HMP(800001.5,"PTAPPT","HMP",IEN))="" S $E(X,$L(X))="",HMSTOP=1
"RTN","HMPACT",27,0)
 . D SETITEM(.ROOT,X)
"RTN","HMPACT",28,0)
 . S DA=IEN,DR="6///1" D ^DIE
"RTN","HMPACT",29,0)
 . Q
"RTN","HMPACT",30,0)
 S X="]" D SETITEM(.ROOT,X)
"RTN","HMPACT",31,0)
 Q
"RTN","HMPACT",32,0)
 ;
"RTN","HMPACT",33,0)
CLEAN ;CLEAN UP STRAY VARIABLES
"RTN","HMPACT",34,0)
 K DA,DR,X
"RTN","HMPACT",35,0)
 Q
"RTN","HMPACT",36,0)
 ;
"RTN","HMPACT",37,0)
SETITEM(ROOT,X) ; -- set item in list - RRB US5872 
"RTN","HMPACT",38,0)
 S @ROOT@($O(@ROOT@(9999),-1)+1)=X
"RTN","HMPACT",39,0)
 Q
"RTN","HMPACT",40,0)
 ;
"RTN","HMPACT",41,0)
APPT(HMPOUT,BEG,END,LOCIEN) ; Lookup appointments by date and location
"RTN","HMPACT",42,0)
 ;
"RTN","HMPACT",43,0)
 ;Associated ICRs:
"RTN","HMPACT",44,0)
 ;  ICR#
"RTN","HMPACT",45,0)
 ;      2051:  Database Server API: Lookup Utilities
"RTN","HMPACT",46,0)
 ;             FIND1^DIC
"RTN","HMPACT",47,0)
 ;      10103: XLFDT Date functions
"RTN","HMPACT",48,0)
 ;             HTFM^XLFDT
"RTN","HMPACT",49,0)
 ;  SUPPORTED: VADPT
"RTN","HMPACT",50,0)
 ;             SDA^VADPT
"RTN","HMPACT",51,0)
 ;             KVA^VADPT
"RTN","HMPACT",52,0)
 ;             KVAR^VADPT
"RTN","HMPACT",53,0)
 ;             SDAPI^SDAMA301
"RTN","HMPACT",54,0)
 ;
"RTN","HMPACT",55,0)
 ; BEG - FileMan date for starting the search - If not defined, defaults to current date
"RTN","HMPACT",56,0)
 ; END - FileMan date to end the search - if not defined, defaults to the current date
"RTN","HMPACT",57,0)
 ; LOCIEN - The IEN for the clinic entry in the Hospital Location file (#44) If not defined, it will get a list of clinics and return the appointments for all clinics for the date range
"RTN","HMPACT",58,0)
 ; Returns data in the TMP($J,"HMPAPPT" global. Returns : DFN ^ APPOINTMENT DATE/TIME ^ CLINIC NAME ^ CLINIC IEN 
"RTN","HMPACT",59,0)
 ;
"RTN","HMPACT",60,0)
 N DFN,LOC,OVER,PAT,REQ,SD,SCX
"RTN","HMPACT",61,0)
 I '$G(BEG) S BEG=$$HTFM^XLFDT(+$H)  ; Default current day
"RTN","HMPACT",62,0)
 S BEG=$P(BEG,".",1)
"RTN","HMPACT",63,0)
 I BEG'?7N Q -1
"RTN","HMPACT",64,0)
 I '$G(END) S END=$$HTFM^XLFDT(+$H)  ; Default current day
"RTN","HMPACT",65,0)
 S END=$P(END,".",1)
"RTN","HMPACT",66,0)
 I END'?7N Q -1
"RTN","HMPACT",67,0)
 I END<BEG Q -1
"RTN","HMPACT",68,0)
 K ^TMP($J,"HMPAPPT")
"RTN","HMPACT",69,0)
 S HMPOUT=$NA(^TMP($J,"HMPAPPT"))
"RTN","HMPACT",70,0)
 I $G(LOCIEN) D SCHED(LOCIEN,BEG,END) G ENDAPPT
"RTN","HMPACT",71,0)
 K LOC
"RTN","HMPACT",72,0)
 ;DE2818, changed location check routine to HMPXGSD
"RTN","HMPACT",73,0)
 D CLINLOC^HMPXGSD(.LOC,"",1)  ; Lookup VistA Clinic Locations
"RTN","HMPACT",74,0)
 ;
"RTN","HMPACT",75,0)
 ; The clinic locations will be returned in the HMPOUT array:
"RTN","HMPACT",76,0)
 ;     LOC(D1)=LOCIEN^LOCNAME
"RTN","HMPACT",77,0)
 ;
"RTN","HMPACT",78,0)
LOCLKUP ; Gets all appointments for all clinics in the LOC(D1) array
"RTN","HMPACT",79,0)
 N LOCNAME
"RTN","HMPACT",80,0)
 S SCX=""
"RTN","HMPACT",81,0)
 F  S SCX=$O(LOC(SCX)) Q:SCX=""  D
"RTN","HMPACT",82,0)
 . S LOCIEN=$P(LOC(SCX),U,1),LOCNAME=$P(LOC(SCX),U,2)
"RTN","HMPACT",83,0)
 . D SCHED(LOCIEN,BEG,END)
"RTN","HMPACT",84,0)
 G ENDAPPT
"RTN","HMPACT",85,0)
 ;
"RTN","HMPACT",86,0)
SCHED(LOCIEN,BEG,END) ;
"RTN","HMPACT",87,0)
 ; Get list of patients and appointment dates from the
"RTN","HMPACT",88,0)
 ; using $$SDAPI^SDAMA301 api.
"RTN","HMPACT",89,0)
 ; Inputs are SDARRAY(1)=BEG;END - Beginning and ending dates for the search. 
"RTN","HMPACT",90,0)
 ; BEG must be defined.
"RTN","HMPACT",91,0)
 ; END ending date for the search. If END is undefined, the API returns all appointments starting with the BEG date.
"RTN","HMPACT",92,0)
 ; BEG and END are FileMan Date/Time. Both BEG and END are validated in the calling linetag APPT^HMPACT
"RTN","HMPACT",93,0)
 ; LOCIEN = IEN for the location in the Hospital Location file (#44). LOCIEN is validated in the calling linetag APPT^HMPACT
"RTN","HMPACT",94,0)
 ; 
"RTN","HMPACT",95,0)
 ; Feb 24, 2016 - PB - DE2991 requested that all patients be returned. Prior to DE2991, if a patient was in the HMP Subscription file (#800000)
"RTN","HMPACT",96,0)
 ; they were excluded from the return data.
"RTN","HMPACT",97,0)
 K ^TMP($J,"SDAMA301") ; Kill the TMP global that stores the results from SDAPI^SDAMA301
"RTN","HMPACT",98,0)
 K SDARRAY,SDCNT ; kill the SDARRAY that stores the input variables for the SDAPI^SDAMA301 call, SDCNT returns the number of appointments found. If SDCNT > 0 data is returned in the ^TMP($J,"SDAMA301" temp global
"RTN","HMPACT",99,0)
 S SDARRAY(1)=BEG_";"_END,SDARRAY(2)=LOCIEN,SDARRAY("FLDS")="1;2;4"  ;input variables for $$SDAPI^SDAMA301
"RTN","HMPACT",100,0)
 S SDCNT=$$SDAPI^SDAMA301(.SDARRAY) I $G(SDCNT)>0 D
"RTN","HMPACT",101,0)
 . K XDFN S XDFN=0
"RTN","HMPACT",102,0)
 . F  S XDFN=$O(^TMP($J,"SDAMA301",LOCIEN,XDFN)) Q:XDFN=""  S APTDATE=0 F  S APTDATE=$O(^TMP($J,"SDAMA301",LOCIEN,XDFN,APTDATE)) Q:APTDATE=""  D
"RTN","HMPACT",103,0)
 . . K LOCALE S LOCALE=$P(^TMP($J,"SDAMA301",LOCIEN,XDFN,APTDATE),"^",2),LOCNAME=$P(LOCALE,";",2)
"RTN","HMPACT",104,0)
 . . S ^TMP($J,"HMPAPPT",XDFN,APTDATE,LOCIEN)=XDFN_U_APTDATE_U_LOCNAME_U_LOCIEN  ;^TMP("HMPAPPT" is killed in APPT^HMPACT before calling this linetag (SCHED)
"RTN","HMPACT",105,0)
 K SDFN,APTDATE,LOCNAME,SDCNT,SDARRAY,^TMP($J,"SDAMA301")  ; clean up variables
"RTN","HMPACT",106,0)
 Q
"RTN","HMPACT",107,0)
 ;
"RTN","HMPACT",108,0)
ENDAPPT ;
"RTN","HMPACT",109,0)
 ;
"RTN","HMPACT",110,0)
 M @HMPOUT=^TMP($J,"HMPAPPT")
"RTN","HMPACT",111,0)
 K @HMPOUT@(0)
"RTN","HMPACT",112,0)
 Q
"RTN","HMPACT",113,0)
 ;
"RTN","HMPACT",114,0)
ADMIT(HMPOUT,LOCIEN) ; Lookup admissions by location
"RTN","HMPACT",115,0)
 ;
"RTN","HMPACT",116,0)
 ;Associated ICRs:
"RTN","HMPACT",117,0)
 ;  ICR#
"RTN","HMPACT",118,0)
 ;      2051:  Database Server API: Lookup Utilities
"RTN","HMPACT",119,0)
 ;             FIND1^DIC
"RTN","HMPACT",120,0)
 ;             LIST^DIC
"RTN","HMPACT",121,0)
 ;      10103: XLFDT Date functions
"RTN","HMPACT",122,0)
 ;             HTFM^XLFDT
"RTN","HMPACT",123,0)
 ;  SUPPORTED: VADPT
"RTN","HMPACT",124,0)
 ;             INP^VADPT
"RTN","HMPACT",125,0)
 ;             KVA^VADPT
"RTN","HMPACT",126,0)
 ;             KVAR^VADPT
"RTN","HMPACT",127,0)
 ;
"RTN","HMPACT",128,0)
 N DFROM,DIEN,DOUT,DPART,DRID,FILE,FLDS,FLG,MAX,PIDX,SCRN,SUBSCRP,WARD,XREF
"RTN","HMPACT",129,0)
 K ^TMP("HMPADMIT",$J)
"RTN","HMPACT",130,0)
 S HMPOUT=$NA(^TMP("HMPADMIT",$J))
"RTN","HMPACT",131,0)
 ; Get Patient list by Ward
"RTN","HMPACT",132,0)
 S FILE=2,DIEN="",FLDS="@;.1",FLG="P",MAX="",DFROM="",DPART="",XREF="ACN"
"RTN","HMPACT",133,0)
 S SCRN="I $P($G(^DPT(+Y,.102)),""^"")>0",DRID="",DOUT=""
"RTN","HMPACT",134,0)
 ; The SCRN parameter is set to insure the patient record has a current movement file entry.
"RTN","HMPACT",135,0)
 K ^TMP("DILIST",$J)
"RTN","HMPACT",136,0)
 D LIST^DIC(FILE,DIEN,FLDS,FLG,MAX,.DFROM,DPART,XREF,SCRN,DRID,DOUT)  ; ICR #2051
"RTN","HMPACT",137,0)
 ; The list of patients and associated wards are returned via the ^TMP("DILIST",$J,PIDX,0) global in the following format:
"RTN","HMPACT",138,0)
 ;      ^TMP("DILIST",$J,PIDX,0)=DFN^WARD
"RTN","HMPACT",139,0)
 ;      Note:  The WARD is the ward name, not an internal (IEN) entry
"RTN","HMPACT",140,0)
 S PIDX=0
"RTN","HMPACT",141,0)
 F  S PIDX=$O(^TMP("DILIST",$J,PIDX)) Q:PIDX=""  D
"RTN","HMPACT",142,0)
 . S DFN=$P(^TMP("DILIST",$J,PIDX,0),U,1),WARD=$P(^TMP("DILIST",$J,PIDX,0),U,2)
"RTN","HMPACT",143,0)
 . ; If the calling application passes a ward LOCIEN, Use the WARD LOCATION File (#42) to lookup
"RTN","HMPACT",144,0)
 . ; the ward (location) IEN for comparison to the requested LOCIEN to screen out any entries that don't match the request.
"RTN","HMPACT",145,0)
 . ; 
"RTN","HMPACT",146,0)
 . I LOCIEN'="",LOCIEN'=$$FIND1^DIC(42,"","BX",WARD,"B","","") Q
"RTN","HMPACT",147,0)
 . ; Check patients for HMP subscription, File (#800000) and setup patient data
"RTN","HMPACT",148,0)
 . ; Removed the subscription check.  JD - 2/16/16. DE3375
"RTN","HMPACT",149,0)
 . D GETADMIT(DFN)
"RTN","HMPACT",150,0)
 ;
"RTN","HMPACT",151,0)
ENDADMIT ;
"RTN","HMPACT",152,0)
 ;
"RTN","HMPACT",153,0)
 M @HMPOUT=^TMP("HMPADMIT",$J)
"RTN","HMPACT",154,0)
 K @HMPOUT@(0)
"RTN","HMPACT",155,0)
 Q
"RTN","HMPACT",156,0)
 ;
"RTN","HMPACT",157,0)
GETADMIT(DFN) ;
"RTN","HMPACT",158,0)
 N ADMIT,PDATA,LOC,LOCNAME,LRMBD,VAERR,VAIN
"RTN","HMPACT",159,0)
 ; Lookup patient admissions data
"RTN","HMPACT",160,0)
 ; Use supported INP^VADPT call to get the admissions data from the Patient File (#2)
"RTN","HMPACT",161,0)
 D INP^VADPT
"RTN","HMPACT",162,0)
 ; LOC = Ward (Location) IEN, LOCNAME = Ward (Location) Name, LRMBD = Room-Bed Name (Optional depending upon inpatient
"RTN","HMPACT",163,0)
 ; location setup), ADMIT = Admission date.time in VA format
"RTN","HMPACT",164,0)
 S LOC=$P(VAIN(4),U),LOCNAME=$P(VAIN(4),U,2),LRMBD=VAIN(5),ADMIT=$P(VAIN(7),U)
"RTN","HMPACT",165,0)
 K PDATA
"RTN","HMPACT",166,0)
 S PDATA=DFN_U_ADMIT_U_LOCNAME_U_LRMBD_U_LOC
"RTN","HMPACT",167,0)
 S ^TMP("HMPADMIT",$J,DFN,LOC)=PDATA
"RTN","HMPACT",168,0)
 ; Supported calls to Kill VADPT variables
"RTN","HMPACT",169,0)
 D KVAR^VADPT,KVA^VADPT
"RTN","HMPACT",170,0)
 ;
"RTN","HMPACT",171,0)
 Q
"RTN","HMPACT",172,0)
 ;
"RTN","HMPAT")
0^4^B3461086^B3595282
"RTN","HMPAT",1,0)
HMPAT ;ASMR/EJK,ASF,CK - ASU/TIU Trigger to HMP Activity File;May 15, 2016 14:15
"RTN","HMPAT",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPAT",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPAT",4,0)
 ;
"RTN","HMPAT",5,0)
 ; DE2818 - SQA findings. Newed HMPRSLT in ECLASS+10.  RRB - 10/27/2015
"RTN","HMPAT",6,0)
 Q
"RTN","HMPAT",7,0)
ECLASS(HMPIEN) ; called from EDIT^USRCLASS,ADD^USRRULA
"RTN","HMPAT",8,0)
 N HMPSYS,TYPE,HMPMAX,HMPI,HMPID,HMPERR,HMPRSLT,HMPTN,HMPLAST,HMPCNT,HMPFINI,HMPFRSP,HMPARGS
"RTN","HMPAT",9,0)
 N $ES,$ET,ERRMSG
"RTN","HMPAT",10,0)
 S HMPID=$P($G(USRDATA),U,2)
"RTN","HMPAT",11,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPAT",12,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPAT",13,0)
 S (HMPMAX,HMPLAST,HMPID)="",HMPCNT=0
"RTN","HMPAT",14,0)
 S HMPARGS("server")=$O(^HMP(800000,"B",""))
"RTN","HMPAT",15,0)
 S HMPARGS("command")="startOperationalDataExtract"
"RTN","HMPAT",16,0)
 S HMPARGS("domains")="asu-class"
"RTN","HMPAT",17,0)
 D API^HMPDJFS(.HMPRSLT,.HMPARGS)
"RTN","HMPAT",18,0)
 Q
"RTN","HMPAT",19,0)
 ;
"RTN","HMPAT",20,0)
ERULE ; called from EDIT1^USRRULA
"RTN","HMPAT",21,0)
 N HMPSYS,TYPE,HMPMAX,HMPI,HMPID,HMPERR,HMPTN,HMPLAST,HMPCNT,HMPFINI,HMPFRSP,HMPARGS
"RTN","HMPAT",22,0)
 N $ES,$ET,ERRMSG
"RTN","HMPAT",23,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPAT",24,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPAT",25,0)
 S (HMPMAX,HMPLAST,HMPID)="",HMPCNT=0
"RTN","HMPAT",26,0)
 S HMPARGS("server")=$O(^HMP(800000,"B",""))
"RTN","HMPAT",27,0)
 S HMPARGS("command")="startOperationalDataExtract"
"RTN","HMPAT",28,0)
 S HMPARGS("domains")="asu-rule"
"RTN","HMPAT",29,0)
 D API^HMPDJFS(.HMPRSLT,.HMPARGS)
"RTN","HMPAT",30,0)
 Q
"RTN","HMPAT",31,0)
 ;
"RTN","HMPAT",32,0)
EDEF ; called from option TIU DOCUMENT DEFINITION EDIT
"RTN","HMPAT",33,0)
 N HMPDA
"RTN","HMPAT",34,0)
 S HMPDA=$P(XQLOK,",",2),HMPDA=$TR(HMPDA,")","")
"RTN","HMPAT",35,0)
 ; DE2818 begin change ASF 11/9/15
"RTN","HMPAT",36,0)
 ;I HMPDA?1N.N,$D(^TIU(8925.1,HMPDA)) D POSTX^HMPEVNT("doc-def",HMPDA)
"RTN","HMPAT",37,0)
 ;I HMPDA?1N.N,'$D(^TIU(8925.1,HMPDA)) D POSTX^HMPEVNT("doc-def",HMPDA,"@")
"RTN","HMPAT",38,0)
 N DA,DIC,DIQ,DR,R  ; FileMan variables
"RTN","HMPAT",39,0)
 S DIC=8925.1,DR=.01,DA=HMPDA,DIQ="R" D EN^DIQ1
"RTN","HMPAT",40,0)
 D:$D(R(8925.1,DA,.01)) POSTX^HMPEVNT("doc-def",HMPDA)
"RTN","HMPAT",41,0)
 D:'$D(R(8925.1,DA,.01)) POSTX^HMPEVNT("doc-def",HMPDA,"@")
"RTN","HMPAT",42,0)
 ; DE2818 end change
"RTN","HMPAT",43,0)
 Q
"RTN","HMPCRPC1")
0^10^B104887301^B103567295
"RTN","HMPCRPC1",1,0)
HMPCRPC1 ;SLC/AGP,ASMR/RRB,CK - Patient and User routine;May 15, 2016 14:15
"RTN","HMPCRPC1",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPCRPC1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPCRPC1",4,0)
 ;
"RTN","HMPCRPC1",5,0)
 Q
"RTN","HMPCRPC1",6,0)
 ;
"RTN","HMPCRPC1",7,0)
GETADD(VALUES,DFN) ;
"RTN","HMPCRPC1",8,0)
 K VAPA
"RTN","HMPCRPC1",9,0)
 D ADD^VADPT
"RTN","HMPCRPC1",10,0)
 N INC,NUM,TEMP
"RTN","HMPCRPC1",11,0)
 I VAPA(12)=1 D
"RTN","HMPCRPC1",12,0)
 .I $L(VAPA(13))>0 S VALUES("confidentIalAddress","street",0)=VAPA(13)
"RTN","HMPCRPC1",13,0)
 .I $L(VAPA(14))>0 S VALUES("confidentIalAddress","street",1)=VAPA(14)
"RTN","HMPCRPC1",14,0)
 .I $L(VAPA(15))>0 S VALUES("confidentIalAddress","street",2)=VAPA(15)
"RTN","HMPCRPC1",15,0)
 .I $L(VAPA(16))>0 S VALUES("confidentIalAddress","city")=VAPA(16)
"RTN","HMPCRPC1",16,0)
 .I $L(VAPA(17))>0 S VALUES("confidentIalAddress","state")=$P(VAPA(17),U,2)
"RTN","HMPCRPC1",17,0)
 .I $L(VAPA(18))>0 S VALUES("confidentIalAddress","zip")=VAPA(18)
"RTN","HMPCRPC1",18,0)
 .I $L(VAPA(20))>0 S VALUES("confidentIalAddress","startDate")=$P(VAPA(20),U,2)
"RTN","HMPCRPC1",19,0)
 .I $L(VAPA(21))>0 S VALUES("confidentIalAddress","stopDate")=$P(VAPA(21),U,2)
"RTN","HMPCRPC1",20,0)
 .S INC=0,NUM=0 F  S INC=$O(VAPA(22,INC)) Q:INC=""  D
"RTN","HMPCRPC1",21,0)
 ..S NUM=NUM+1,VALUES("confidentIalAddress","catgories",NUM,"category")=$P(VAPA(22,INC),U,2)
"RTN","HMPCRPC1",22,0)
 ..S VALUES("confidentIalAddress","catgories",NUM,"status")=$S($P(VAPA(22,INC),U,3)="Y":"true",1:"false")
"RTN","HMPCRPC1",23,0)
 ;
"RTN","HMPCRPC1",24,0)
 ;I $L(VAPA(1))>0 S VALUES("address","street",0)=VAPA(1)
"RTN","HMPCRPC1",25,0)
 ;I $L(VAPA(2))>0 S VALUES("address","street",1)=VAPA(2)
"RTN","HMPCRPC1",26,0)
 ;I $L(VAPA(3))>0 S VALUES("address","street",2)=VAPA(3)
"RTN","HMPCRPC1",27,0)
 ;I $L(VAPA(4))>0 S VALUES("address","city")=VAPA(4)
"RTN","HMPCRPC1",28,0)
 ;I $L(VAPA(5))>0 S VALUES("address","state")=$P(VAPA(5),U,2)
"RTN","HMPCRPC1",29,0)
 ;I $L(VAPA(6))>0 S VALUES("address","zip")=VAPA(6)
"RTN","HMPCRPC1",30,0)
 I VAPA(9)]"" S VALUES("temporaryAddress","startDate")=$P(VAPA(9),U,2)
"RTN","HMPCRPC1",31,0)
 I VAPA(10)]"" S VALUES("temporaryAddress","stopDate")=$P(VAPA(10),U,2)
"RTN","HMPCRPC1",32,0)
ADDX ;
"RTN","HMPCRPC1",33,0)
 ;I $L(VAPA(8))>0 S VALUES("address","phone")=VAPA(8)
"RTN","HMPCRPC1",34,0)
 I $P($G(^DPT(DFN,.13)),U,3)'="" S VALUES("email")=$P($G(^DPT(DFN,.13)),U,3)
"RTN","HMPCRPC1",35,0)
 I +$P($G(^DPT(DFN,.11)),U,16)>0 S VALUES("badAddress")=$$GET1^DIQ(2,DFN_",",.121)
"RTN","HMPCRPC1",36,0)
 D KVAR^VADPT
"RTN","HMPCRPC1",37,0)
 Q
"RTN","HMPCRPC1",38,0)
 ;
"RTN","HMPCRPC1",39,0)
GETBSA(DFN) ;
"RTN","HMPCRPC1",40,0)
 N DATE,DATA,NFOUND,TEST,TEXT
"RTN","HMPCRPC1",41,0)
 S TEST=""
"RTN","HMPCRPC1",42,0)
 D BSA^PXRMBMI(DFN,1,0,DT,.NFOUND,.TEST,.DATE,.DATA,.TEXT)
"RTN","HMPCRPC1",43,0)
 Q +$G(DATA(1,"BSA"))
"RTN","HMPCRPC1",44,0)
 ;
"RTN","HMPCRPC1",45,0)
GETBMI(DFN) ;
"RTN","HMPCRPC1",46,0)
 ;  BMI(DFN,NGET,BDT,EDT,NFOUND,TEST,DATE,DATA,TEXT) 
"RTN","HMPCRPC1",47,0)
 N DATE,DATA,NFOUND,TEST,TEXT
"RTN","HMPCRPC1",48,0)
 D BMI^PXRMBMI(DFN,1,0,DT,.NFOUND,.TEST,.DATE,.DATA,.TEXT)
"RTN","HMPCRPC1",49,0)
 Q +$G(DATA(1,"BMI"))
"RTN","HMPCRPC1",50,0)
 ;
"RTN","HMPCRPC1",51,0)
GETDEM(VALUES,DFN) ;
"RTN","HMPCRPC1",52,0)
 D DEM^VADPT
"RTN","HMPCRPC1",53,0)
 S VALUES("name")=VADM(1)
"RTN","HMPCRPC1",54,0)
 I VADM(2)]"" S VALUES("ssn")=$P(VADM(2),U,2)
"RTN","HMPCRPC1",55,0)
 I VADM(3)]"" S VALUES("dob")=$P(VADM(3),U,2)
"RTN","HMPCRPC1",56,0)
 I VADM(4)]"" S VALUES("age")=VADM(4)
"RTN","HMPCRPC1",57,0)
 I VADM(5)]"" S VALUES("gender")=$P(VADM(5),U,2)
"RTN","HMPCRPC1",58,0)
 I VADM(6)]"" S VALUES("dateDeath")=$P(VADM(6),U,2)
"RTN","HMPCRPC1",59,0)
 I VADM(7)]"" S VALUES("remarks")=VADM(7)
"RTN","HMPCRPC1",60,0)
 I VADM(8)]"" S VALUES("race")=$P(VADM(8),U,2)
"RTN","HMPCRPC1",61,0)
 D KVAR^VADPT
"RTN","HMPCRPC1",62,0)
 Q
"RTN","HMPCRPC1",63,0)
 ;
"RTN","HMPCRPC1",64,0)
GETKEYS(VALUES,USER) ;
"RTN","HMPCRPC1",65,0)
 N NAME,HMPERR,HMPLIST,CNT
"RTN","HMPCRPC1",66,0)
 D LIST^DIC(200.051,","_USER_",",".01",,,,,,,,"HMPLIST","HMPERR")
"RTN","HMPCRPC1",67,0)
 S CNT=0 F  S CNT=$O(HMPLIST("DILIST",1,CNT)) Q:CNT'>0  D
"RTN","HMPCRPC1",68,0)
 . S NAME=$G(HMPLIST("DILIST",1,CNT)) Q:NAME=""
"RTN","HMPCRPC1",69,0)
 . S VALUES("vistaKeys",NAME)="TRUE"
"RTN","HMPCRPC1",70,0)
 Q
"RTN","HMPCRPC1",71,0)
 ;
"RTN","HMPCRPC1",72,0)
GETNOK(VALUES,DFN,TYPE) ;
"RTN","HMPCRPC1",73,0)
 K VAOA
"RTN","HMPCRPC1",74,0)
 S VAOA("A")=TYPE
"RTN","HMPCRPC1",75,0)
 N CNT,CONTACT
"RTN","HMPCRPC1",76,0)
 S CONTACT=$S(TYPE=3:"secondary",1:"primary")
"RTN","HMPCRPC1",77,0)
 S CNT=$S(TYPE=3:2,1:1)
"RTN","HMPCRPC1",78,0)
 D OAD^VADPT
"RTN","HMPCRPC1",79,0)
 ;
"RTN","HMPCRPC1",80,0)
 I VAOA(9)]"" S VALUES("nok",CNT,"name")=VAOA(9)
"RTN","HMPCRPC1",81,0)
 I VAOA(10)]"" S VALUES("nok",CNT,"relationship")=VAOA(10)
"RTN","HMPCRPC1",82,0)
 I VAOA(1)]"" S VALUES("nok",CNT,"address","street",1)=VAOA(1)
"RTN","HMPCRPC1",83,0)
 I VAOA(2)]"" S VALUES("nok",CNT,"address","street",2)=VAOA(2)
"RTN","HMPCRPC1",84,0)
 I VAOA(3)]"" S VALUES("nok",CNT,"address","street",3)=VAOA(3)
"RTN","HMPCRPC1",85,0)
 I VAOA(4)]"" S VALUES("nok",CNT,"address","city")=VAOA(4)
"RTN","HMPCRPC1",86,0)
 I VAOA(5)]"" S VALUES("nok",CNT,"address","state")=$P(VAOA(5),U,2)
"RTN","HMPCRPC1",87,0)
 I VAOA(6)]"" S VALUES("nok",CNT,"address","zip")=VAOA(6)
"RTN","HMPCRPC1",88,0)
 I VAOA(8)]"" S VALUES("nok",CNT,"address","phone")=VAOA(8)
"RTN","HMPCRPC1",89,0)
 D KVAR^VADPT
"RTN","HMPCRPC1",90,0)
 Q
"RTN","HMPCRPC1",91,0)
 ;
"RTN","HMPCRPC1",92,0)
GETMEANS(VALUES,DFN) ;
"RTN","HMPCRPC1",93,0)
 K VAEL
"RTN","HMPCRPC1",94,0)
 D ELIG^VADPT
"RTN","HMPCRPC1",95,0)
 I VAEL(9)]"" S VALUES("meanStatus")=$P(VAEL(9),U,2)
"RTN","HMPCRPC1",96,0)
 D KVAR^VADPT
"RTN","HMPCRPC1",97,0)
 Q
"RTN","HMPCRPC1",98,0)
 ;
"RTN","HMPCRPC1",99,0)
GETPATI(RESULT,DFN) ;
"RTN","HMPCRPC1",100,0)
 N TYPE,VALUES,HMPERR,Y,HMPODEM,HMPSYS
"RTN","HMPCRPC1",101,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPCRPC1",102,0)
 D DPT1OD^HMPDJ00(.VALUES)
"RTN","HMPCRPC1",103,0)
 G GPQ
"RTN","HMPCRPC1",104,0)
 S VALUES("pid")=$$PID^HMPDJFS(DFN)
"RTN","HMPCRPC1",105,0)
 ;D BUILDUID^HMPPARAM(.VALUES,"patient",DFN)
"RTN","HMPCRPC1",106,0)
 ;D GETDEM(.VALUES,DFN)
"RTN","HMPCRPC1",107,0)
 D GETADD(.VALUES,DFN)
"RTN","HMPCRPC1",108,0)
 ;F TYPE=1,3 D GETNOK(.VALUES,DFN,TYPE)
"RTN","HMPCRPC1",109,0)
 D GETPATTM(.VALUES,DFN)
"RTN","HMPCRPC1",110,0)
 ;D GETPATVI(.VALUES,DFN)
"RTN","HMPCRPC1",111,0)
 D GETPATIP(.VALUES,DFN)
"RTN","HMPCRPC1",112,0)
 D GETMEANS(.VALUES,DFN)
"RTN","HMPCRPC1",113,0)
 D PRF^HMPFPTC(DFN,.VALUES)
"RTN","HMPCRPC1",114,0)
 S Y=$$CWAD^ORQPT2(DFN)
"RTN","HMPCRPC1",115,0)
 I Y]"" S VALUES("cwad")=Y
"RTN","HMPCRPC1",116,0)
 I $D(VALUES("patientRecordFlags")) S VALUES("cwad")=$G(VALUES("cwad"))_"F"
"RTN","HMPCRPC1",117,0)
 ;D PTINQ^ORWPT(.DEM,DFN)
"RTN","HMPCRPC1",118,0)
 ;S NUM=5,STR=""
"RTN","HMPCRPC1",119,0)
 ;F  S NUM=$O(@DEM@(NUM)) Q:NUM'>0  D
"RTN","HMPCRPC1",120,0)
 ;.S VALUES("patDemDetails","text","\",NUM)=@DEM@(NUM)_$C(13,10)
"RTN","HMPCRPC1",121,0)
 S VALUES("success")="true"
"RTN","HMPCRPC1",122,0)
GPQ D ENCODE^HMPJSON("VALUES","RESULT","HMPERR")
"RTN","HMPCRPC1",123,0)
 I $D(HMPERR) D
"RTN","HMPCRPC1",124,0)
 .K RESULT N TEMP,TXT
"RTN","HMPCRPC1",125,0)
 .S TXT(1)="Problem encoding json output."
"RTN","HMPCRPC1",126,0)
 .D SETERROR^HMPUTILS(.TEMP,.HMPERR,.TXT,.VALUES)
"RTN","HMPCRPC1",127,0)
 .K HMPERR D ENCODE^HMPJSON("TEMP","RESULT","HMPERR")
"RTN","HMPCRPC1",128,0)
 Q
"RTN","HMPCRPC1",129,0)
 ;
"RTN","HMPCRPC1",130,0)
GETPATIP(VALUES,DFN) ;
"RTN","HMPCRPC1",131,0)
 N HMPDATA
"RTN","HMPCRPC1",132,0)
 D INPLOC^ORWPT(.HMPDATA,DFN)
"RTN","HMPCRPC1",133,0)
 I +HMPDATA D
"RTN","HMPCRPC1",134,0)
 . S VALUES("shortInpatientLocation")=$P($G(^SC(+HMPDATA,0)),U,2)
"RTN","HMPCRPC1",135,0)
 . S VALUES("inpatientLocation")=$P(HMPDATA,U,2)
"RTN","HMPCRPC1",136,0)
 I $P($G(^DPT(DFN,.101)),U)'="" S VALUES("roomBed")=$P($G(^DPT(DFN,.101)),U)
"RTN","HMPCRPC1",137,0)
 Q
"RTN","HMPCRPC1",138,0)
 ;
"RTN","HMPCRPC1",139,0)
GETPATVI(VALUES,DFN) ;  DE2818 - PB - Code commented out during SQA review/modifications
"RTN","HMPCRPC1",140,0)
 ;N BMI,DAS,HT,LDATE,HMPTEMP,WT,BSA
"RTN","HMPCRPC1",141,0)
 ;;get weight
"RTN","HMPCRPC1",142,0)
 ;S LDATE=$O(^PXRMINDX(120.5,"PI",DFN,9,""),-1)
"RTN","HMPCRPC1",143,0)
 ;I LDATE>0 D
"RTN","HMPCRPC1",144,0)
 ;.S DAS=$O(^PXRMINDX(120.5,"PI",DFN,9,LDATE,""))
"RTN","HMPCRPC1",145,0)
 ;.I DAS']"" Q
"RTN","HMPCRPC1",146,0)
 ;.D GETDATA^PXRMVITL(DAS,.HMPTEMP)
"RTN","HMPCRPC1",147,0)
 ;.S WT=HMPTEMP("VALUE")
"RTN","HMPCRPC1",148,0)
 ;.S VALUES("lastVitals","weight","value")=WT
"RTN","HMPCRPC1",149,0)
 ;.S VALUES("lastVitals","weight","lastDone")=$$FMTE^XLFDT(LDATE,"D")
"RTN","HMPCRPC1",150,0)
 ;;get height
"RTN","HMPCRPC1",151,0)
 ;K LDATE,DAS
"RTN","HMPCRPC1",152,0)
 ;S LDATE=$O(^PXRMINDX(120.5,"PI",DFN,8,""),-1)
"RTN","HMPCRPC1",153,0)
 ;I LDATE>0 D
"RTN","HMPCRPC1",154,0)
 ;.S DAS=$O(^PXRMINDX(120.5,"PI",DFN,8,LDATE,""))
"RTN","HMPCRPC1",155,0)
 ;.I DAS']"" Q
"RTN","HMPCRPC1",156,0)
 ;.D GETDATA^PXRMVITL(DAS,.HMPTEMP)
"RTN","HMPCRPC1",157,0)
 ;.S HT=HMPTEMP("VALUE")
"RTN","HMPCRPC1",158,0)
 ;.S VALUES("lastVitals","height","value")=HT
"RTN","HMPCRPC1",159,0)
 ;.S VALUES("lastVitals","height","lastDone")=$$FMTE^XLFDT(LDATE,"D")
"RTN","HMPCRPC1",160,0)
 ;S BMI=$$GETBMI(DFN)
"RTN","HMPCRPC1",161,0)
 ;I BMI>0 S VALUES("lastVitals","bmi")=BMI
"RTN","HMPCRPC1",162,0)
 ;S BSA=$$GETBSA(DFN)
"RTN","HMPCRPC1",163,0)
 ;I BSA>0 S VALUES("lastVitals","bsa")=BSA
"RTN","HMPCRPC1",164,0)
 ;Q
"RTN","HMPCRPC1",165,0)
 ;
"RTN","HMPCRPC1",166,0)
GETPATTM(VALUES,DFN) ; -- returns treating team info
"RTN","HMPCRPC1",167,0)
 N CNT,PROV,TEAM,MH,HMPTEAM,MHTEAM
"RTN","HMPCRPC1",168,0)
 S PROV=$$OUTPTPR^SDUTL3(DFN) D NP(+PROV,"primaryProvider")
"RTN","HMPCRPC1",169,0)
 S PROV=$$OUTPTAP^SDUTL3(DFN) D NP(+PROV,"associateProvider")
"RTN","HMPCRPC1",170,0)
 S PROV=$G(^DPT(DFN,.1041)) D NP(+PROV,"attendingProvider")
"RTN","HMPCRPC1",171,0)
 S PROV=$G(^DPT(DFN,.104)) D NP(+PROV,"inpatientProvider")
"RTN","HMPCRPC1",172,0)
 ;
"RTN","HMPCRPC1",173,0)
 S TEAM=$$OUTPTTM^SDUTL3(DFN) I TEAM D
"RTN","HMPCRPC1",174,0)
 . S VALUES("teamInfo","team","uid")=$$SETUID^HMPUTILS("team",,+TEAM)
"RTN","HMPCRPC1",175,0)
 . S VALUES("teamInfo","team","name")=$P(TEAM,U,2)
"RTN","HMPCRPC1",176,0)
 . S VALUES("teamInfo","team","phone")=$P($G(^SCTM(404.51,+TEAM,0)),U,2)
"RTN","HMPCRPC1",177,0)
 I 'TEAM S VALUES("teamInfo","team","name")="unassigned"
"RTN","HMPCRPC1",178,0)
 ;
"RTN","HMPCRPC1",179,0)
 S MH=$$START^SCMCMHTC(DFN) D NP(+MH,"mhCoordinator")
"RTN","HMPCRPC1",180,0)
 S VALUES("teamInfo","mhCoordinator","mhPosition")=$S(MH:$P(MH,U,3),1:"unassigned")
"RTN","HMPCRPC1",181,0)
 S VALUES("teamInfo","mhCoordinator","mhTeam")=$S(MH:$P(MH,U,5),1:"unassigned")
"RTN","HMPCRPC1",182,0)
 ;US5234 - Add Mental Health Team Office Phone - TW
"RTN","HMPCRPC1",183,0)
 I $P($G(MH),U,5)'="" D
"RTN","HMPCRPC1",184,0)
 . S MHTEAM=$O(^SCTM(404.51,"B",$P(MH,U,5),""))
"RTN","HMPCRPC1",185,0)
 . S VALUES("teamInfo","mhCoordinator","mhTeamOfficePhone")=$$GET1^DIQ(404.51,MHTEAM_",",.02)
"RTN","HMPCRPC1",186,0)
 ;
"RTN","HMPCRPC1",187,0)
 D PCDETAIL^ORWPT1(.HMPTEAM,DFN)
"RTN","HMPCRPC1",188,0)
 S CNT=0 F  S CNT=$O(HMPTEAM(CNT)) Q:CNT'>0  D
"RTN","HMPCRPC1",189,0)
 . S VALUES("teamInfo","text","\",CNT)=HMPTEAM(CNT)_$C(13,10)
"RTN","HMPCRPC1",190,0)
 Q
"RTN","HMPCRPC1",191,0)
NP(X,TYPE) ; -- add New Person data to teamInfo array
"RTN","HMPCRPC1",192,0)
 Q:$G(TYPE)=""
"RTN","HMPCRPC1",193,0)
 I $G(X)'>0 S VALUES("teamInfo",TYPE,"name")="unassigned" Q
"RTN","HMPCRPC1",194,0)
 S VALUES("teamInfo",TYPE,"uid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPCRPC1",195,0)
 S VALUES("teamInfo",TYPE,"name")=$P($G(^VA(200,+X,0)),U)
"RTN","HMPCRPC1",196,0)
 S VALUES("teamInfo",TYPE,"analogPager")=$P($G(^VA(200,+X,.13)),U,7)
"RTN","HMPCRPC1",197,0)
 S VALUES("teamInfo",TYPE,"digitalPager")=$P($G(^VA(200,+X,.13)),U,8)
"RTN","HMPCRPC1",198,0)
 S VALUES("teamInfo",TYPE,"officePhone")=$P($G(^VA(200,+X,.13)),U,2)
"RTN","HMPCRPC1",199,0)
 Q
"RTN","HMPCRPC1",200,0)
 ;
"RTN","HMPCRPC1",201,0)
GETPOS(VALUES,USER) ;
"RTN","HMPCRPC1",202,0)
 ; this returns the list of position for an user
"RTN","HMPCRPC1",203,0)
 N CNT,NODE,NUM,ROLEIEN,ROLE,TEAM,TEAMIEN,TEAMPHN,HMPLIST,HMPERR
"RTN","HMPCRPC1",204,0)
 ;$$TPPR^SCAPMC(DUZ,SCDATES,SCPURPA,SCROLEA,"LIST",HMPERR)
"RTN","HMPCRPC1",205,0)
 S NUM=$$TPPR^SCAPMC(USER,"","","","",.HMPERR)
"RTN","HMPCRPC1",206,0)
 F CNT=1:1:NUM D
"RTN","HMPCRPC1",207,0)
 .S NODE=$G(^TMP("SC TMP LIST",$J,CNT))
"RTN","HMPCRPC1",208,0)
 .S VALUES("vistaPositions",CNT,"position")=$P(NODE,U,2)
"RTN","HMPCRPC1",209,0)
 .S VALUES("vistaPositions",CNT,"effectiveDate")=$P(NODE,U,5)
"RTN","HMPCRPC1",210,0)
 .S VALUES("vistaPositions",CNT,"inactiveDate")=$P(NODE,U,6)
"RTN","HMPCRPC1",211,0)
 .S TEAMIEN=$P(NODE,U,3)
"RTN","HMPCRPC1",212,0)
 .S TEAM=$$GET1^DIQ(404.51,(+TEAMIEN_","),.01)
"RTN","HMPCRPC1",213,0)
 .S TEAMPHN=$$GET1^DIQ(404.51,(+TEAMIEN_","),.02)
"RTN","HMPCRPC1",214,0)
 .S VALUES("vistaPositions",CNT,"teamName")=TEAM
"RTN","HMPCRPC1",215,0)
 .S VALUES("vistaPositions",CNT,"teamPhone")=TEAMPHN
"RTN","HMPCRPC1",216,0)
 .I $P(NODE,U,9)>0 D
"RTN","HMPCRPC1",217,0)
 .S VALUES("vistaPositions",CNT,"role")=$$GET1^DIQ(8930,($P(NODE,U,9)_","),.01)
"RTN","HMPCRPC1",218,0)
 Q
"RTN","HMPCRPC1",219,0)
 ;
"RTN","HMPCRPC1",220,0)
GETUSERC(VALUES,USER) ;
"RTN","HMPCRPC1",221,0)
 N ARRAY,CNT,EFFDATE,EXPDATE,ID,IND,LIST,NODE
"RTN","HMPCRPC1",222,0)
 D WHATIS^USRLM(USER,"LIST",1)
"RTN","HMPCRPC1",223,0)
 ;LIST(Uppername_indicator)=UserClassIEN^MembershipIEN^name^EffectDt^ExpireDt
"RTN","HMPCRPC1",224,0)
 S IND=0,CNT=0 F  S IND=$O(LIST(IND)) Q:IND=""  D
"RTN","HMPCRPC1",225,0)
 .S NODE=LIST(IND)
"RTN","HMPCRPC1",226,0)
 .S EFFDATE=$P(NODE,U,4),EXPDATE=$P(NODE,U,5)
"RTN","HMPCRPC1",227,0)
 .I EFFDATE>0,EFFDATE>DT Q
"RTN","HMPCRPC1",228,0)
 .I EXPDATE>0,EXPDATE<DT Q
"RTN","HMPCRPC1",229,0)
 .S CNT=CNT+1
"RTN","HMPCRPC1",230,0)
 .S ID=$P(NODE,U)
"RTN","HMPCRPC1",231,0)
 .S ARRAY(ID)=""
"RTN","HMPCRPC1",232,0)
 .S VALUES("vistaUserClass",CNT,"role")=$P(NODE,U,3)
"RTN","HMPCRPC1",233,0)
 .S VALUES("vistaUserClass",CNT,"uid")=$$SETUID^HMPUTILS("asu-class","",ID,"")
"RTN","HMPCRPC1",234,0)
 .S VALUES("vistaUserClass",CNT,"effectiveDate")=EFFDATE
"RTN","HMPCRPC1",235,0)
 .S VALUES("vistaUserClass",CNT,"expirationDate")=EXPDATE
"RTN","HMPCRPC1",236,0)
 .I $D(^USR(8930,"AD",ID)) D GETUCPAR(.VALUES,ID,.CNT,.ARRAY)
"RTN","HMPCRPC1",237,0)
 I CNT=0 D
"RTN","HMPCRPC1",238,0)
 .S ID=$O(^USR(8930,"B","USER","")) I +ID'>0 Q
"RTN","HMPCRPC1",239,0)
 .S CNT=CNT+1
"RTN","HMPCRPC1",240,0)
 .S VALUES("vistaUserClass",CNT,"role")=$P($G(^USR(8930,ID,0)),U)
"RTN","HMPCRPC1",241,0)
 .S VALUES("vistaUserClass",CNT,"uid")=$$SETUID^HMPUTILS("asu-class","",ID,"")
"RTN","HMPCRPC1",242,0)
 Q
"RTN","HMPCRPC1",243,0)
GETUCPAR(VALUES,ID,CNT,ARRAY) ;
"RTN","HMPCRPC1",244,0)
 N IEN,ROLE
"RTN","HMPCRPC1",245,0)
 S IEN=0 F  S IEN=$O(^USR(8930,"AD",ID,IEN)) Q:IEN'>0  D
"RTN","HMPCRPC1",246,0)
 .I $D(ARRAY(IEN)) Q
"RTN","HMPCRPC1",247,0)
 .S ARRAY(IEN)=""
"RTN","HMPCRPC1",248,0)
 .S ROLE=$P($G(^USR(8930,IEN,0)),U)
"RTN","HMPCRPC1",249,0)
 .S CNT=CNT+1
"RTN","HMPCRPC1",250,0)
 .S VALUES("vistaUserClass",CNT,"role")=ROLE
"RTN","HMPCRPC1",251,0)
 .S VALUES("vistaUserClass",CNT,"uid")=$$SETUID^HMPUTILS("asu-class","",IEN,"")
"RTN","HMPCRPC1",252,0)
 .I $D(^USR(8930,"AD",ID)) D GETUCPAR(.VALUES,IEN,.CNT,.ARRAY)
"RTN","HMPCRPC1",253,0)
 Q
"RTN","HMPCRPC1",254,0)
 ;
"RTN","HMPCRPC1",255,0)
GETUSERI(RESULT,USER) ;
"RTN","HMPCRPC1",256,0)
 N RPCOPT,VALUES,HMPERR,HMPLIST,CPRSPATH
"RTN","HMPCRPC1",257,0)
 D BUILDUID^HMPPARAM(.VALUES,"user",USER)
"RTN","HMPCRPC1",258,0)
 S VALUES("timeout")=$$GET^XPAR("USR^SYS","ORWOR TIMEOUT CHART",1,"I")
"RTN","HMPCRPC1",259,0)
 S VALUES("timeoutCounter")=$$GET^XPAR("USR^SYS^PKG","ORWOR TIMEOUT COUNTDOWN",1,"I")
"RTN","HMPCRPC1",260,0)
 S CPRSPATH=$$GET^XPAR("USR^SYS","HMP CPRS PATH",1,"I")
"RTN","HMPCRPC1",261,0)
 S VALUES("cprsPath")=$S($L($G(CPRSPATH))>0:CPRSPATH,1:"")
"RTN","HMPCRPC1",262,0)
 D FIND^DIC(19,"",1,"X","HMP UI CONTEXT",1,,,,"HMPLIST")
"RTN","HMPCRPC1",263,0)
 S RPCOPT=$S($D(^HMPLIST("DILIST",0)):-1,1:$P(HMPLIST("DILIST","ID",1,1),"version ",2))
"RTN","HMPCRPC1",264,0)
 ;S VALUES("signingPriv")=$S($D(^XUSEC("ORES",DUZ)):3,$D(^XUSEC("ORELSE",DUZ)):2,$D(^XUSEC("OREMAS",DUZ)):1,1:0)
"RTN","HMPCRPC1",265,0)
 S VALUES("orderingRole")=$$ORDROLE(USER)
"RTN","HMPCRPC1",266,0)
 S VALUES("hmpVersion")=RPCOPT
"RTN","HMPCRPC1",267,0)
 S VALUES("domain")=$$KSP^XUPARAM("WHERE")  ; domain
"RTN","HMPCRPC1",268,0)
 S VALUES("service")=+$G(^VA(200,USER,5))     ; service/section
"RTN","HMPCRPC1",269,0)
 D GETUSERC(.VALUES,USER)
"RTN","HMPCRPC1",270,0)
 D GETPOS(.VALUES,USER)
"RTN","HMPCRPC1",271,0)
 D GETKEYS(.VALUES,USER)
"RTN","HMPCRPC1",272,0)
 S VALUES("productionAccount")=$S($$PROD^XUPROD=1:"true",1:"false")
"RTN","HMPCRPC1",273,0)
 ;S RESULT=$$ENCODE^HMPJSON("VALUES","HMPERR")
"RTN","HMPCRPC1",274,0)
 D ENCODE^HMPJSON("VALUES","RESULT","HMPERR")
"RTN","HMPCRPC1",275,0)
 Q
"RTN","HMPCRPC1",276,0)
 ;
"RTN","HMPCRPC1",277,0)
ORDROLE(USER) ; returns the role a person takes in ordering
"RTN","HMPCRPC1",278,0)
 ; VAL: 0=nokey, 1=clerk, 2=nurse, 3=physician, 4=student, 5=bad keys
"RTN","HMPCRPC1",279,0)
 ;I '$G(ORWCLVER) Q 0  ; version of client is to old for ordering
"RTN","HMPCRPC1",280,0)
 I ($D(^XUSEC("OREMAS",USER))+$D(^XUSEC("ORELSE",USER))+$D(^XUSEC("ORES",USER)))>1 Q 5
"RTN","HMPCRPC1",281,0)
 I $D(^XUSEC("OREMAS",USER)) Q 1                           ; clerk
"RTN","HMPCRPC1",282,0)
 I $D(^XUSEC("ORELSE",USER)) Q 2                           ; nurse
"RTN","HMPCRPC1",283,0)
 I $D(^XUSEC("ORES",USER)),$D(^XUSEC("PROVIDER",USER)) Q 3  ; doctor
"RTN","HMPCRPC1",284,0)
 I $D(^XUSEC("PROVIDER",USER)) Q 4                         ; student
"RTN","HMPCRPC1",285,0)
 Q 0
"RTN","HMPCRPC1",286,0)
 ;
"RTN","HMPDCRC")
0^91^B46900881^B46986534
"RTN","HMPDCRC",1,0)
HMPDCRC ;SLC/MKB,AGP,ASMR/RRB - Compute CRC32 for VistA data;May 15, 2016 14:15
"RTN","HMPDCRC",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDCRC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDCRC",4,0)
 ;
"RTN","HMPDCRC",5,0)
 ; External References          DBIA#
"RTN","HMPDCRC",6,0)
 ; -------------------          -----
"RTN","HMPDCRC",7,0)
 ; ^DPT                         10035
"RTN","HMPDCRC",8,0)
 ; %ZTLOAD                      10063
"RTN","HMPDCRC",9,0)
 ; MPIF001                       2701
"RTN","HMPDCRC",10,0)
 ; XLFCRC                        3156
"RTN","HMPDCRC",11,0)
 ; XLFDT                        10103
"RTN","HMPDCRC",12,0)
 Q
"RTN","HMPDCRC",13,0)
 ;
"RTN","HMPDCRC",14,0)
CHECK(HMPCRC,FILTER) ; -- Return CRC32 checksums of VistA data
"RTN","HMPDCRC",15,0)
 ; RPC = HMP GET CHECKSUM
"RTN","HMPDCRC",16,0)
 ; where FILTER("system")    = name of calling/client system
"RTN","HMPDCRC",17,0)
 ;       FILTER("patientId") = DFN or DFN;ICN
"RTN","HMPDCRC",18,0)
 ;       FILTER("domain")    = name of desired data type (see HMPDJ0)
"RTN","HMPDCRC",19,0)
 ;       FILTER("uid")       = single item id to return  [opt]
"RTN","HMPDCRC",20,0)
 ;       FILTER("start")     = start date.time of search [opt]
"RTN","HMPDCRC",21,0)
 ;       FILTER("stop")      = stop date.time of search  [opt]
"RTN","HMPDCRC",22,0)
 ;       FILTER("queued")    = true or false
"RTN","HMPDCRC",23,0)
 ;
"RTN","HMPDCRC",24,0)
 ; HMPCRC returns the name of the ^TMP array containing the results
"RTN","HMPDCRC",25,0)
 ;
"RTN","HMPDCRC",26,0)
 N DFN,NODE,QUEUED,SYS,HMPSYS
"RTN","HMPDCRC",27,0)
 K ^TMP("HMPDCRC",$J),HMPCRC
"RTN","HMPDCRC",28,0)
 S SYS=$G(FILTER("system")) I SYS="" Q
"RTN","HMPDCRC",29,0)
 S DFN=$G(FILTER("patientId")) I DFN="" Q
"RTN","HMPDCRC",30,0)
 S QUEUED=$G(FILTER("queued"))
"RTN","HMPDCRC",31,0)
 S NODE="HMPDCRC "_SYS_"-"_"-"_DFN
"RTN","HMPDCRC",32,0)
 S FILTER("node")=NODE
"RTN","HMPDCRC",33,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDCRC",34,0)
 ;
"RTN","HMPDCRC",35,0)
 ; - if not queued, generate checksums and exit w/values in ^TMP
"RTN","HMPDCRC",36,0)
 I QUEUED'="true" D  Q
"RTN","HMPDCRC",37,0)
 . S ^XTMP(NODE,0)=$$FMADD^XLFDT(DT,1)_U_DT_U_"Checksum for Server "_SYS_" patient "_DFN
"RTN","HMPDCRC",38,0)
 . D EN(.FILTER)
"RTN","HMPDCRC",39,0)
 . M ^TMP("HMPDCRC",$J)=^XTMP(NODE,"data")
"RTN","HMPDCRC",40,0)
 . S HMPCRC=$NA(^TMP("HMPDCRC",$J))
"RTN","HMPDCRC",41,0)
 . K ^XTMP(NODE)
"RTN","HMPDCRC",42,0)
 ;
"RTN","HMPDCRC",43,0)
 ; - Queue job if not started, else return data if done
"RTN","HMPDCRC",44,0)
 I +$G(^XTMP(NODE,"start"))=0 D QUEUED(.FILTER,NODE,SYS,DFN) Q
"RTN","HMPDCRC",45,0)
 I +$G(^XTMP(NODE,"stop"))>0 D  K ^XTMP(NODE)
"RTN","HMPDCRC",46,0)
 . I $G(^XTMP(NODE,"error"))'=""  S HMPCRC=^XTMP(NODE,"error") Q
"RTN","HMPDCRC",47,0)
 . S HMPCRC=$NA(^TMP("HMPDCRC",$J))
"RTN","HMPDCRC",48,0)
 . M ^TMP("HMPDCRC",$J)=^XTMP(NODE,"data")
"RTN","HMPDCRC",49,0)
 Q
"RTN","HMPDCRC",50,0)
 ;
"RTN","HMPDCRC",51,0)
QUEUED(FILTER,NODE,SYS,DFN) ; -- start job to generate checksums
"RTN","HMPDCRC",52,0)
 N ZTDESC,ZTIO,ZTRTN,ZTSAVE,ZTDTH,ZTSK
"RTN","HMPDCRC",53,0)
 S ^XTMP(NODE,0)=$$FMADD^XLFDT(DT,1)_U_DT_U_"Checksum for Server "_SYS_" patient "_DFN
"RTN","HMPDCRC",54,0)
 S ZTRTN="EN1^HMPDCRC",ZTDESC="Patient Checksum Extract for "_DFN
"RTN","HMPDCRC",55,0)
 S ZTDTH=$$NOW^XLFDT(),ZTIO="",ZTSAVE("FILTER(")=""
"RTN","HMPDCRC",56,0)
 S ^XTMP(NODE,"start")=$$NOW^XLFDT()
"RTN","HMPDCRC",57,0)
 D ^%ZTLOAD I +$G(ZTSK)>0  S ^XTMP(NODE,"task")=+$G(ZTSK) Q    ;success
"RTN","HMPDCRC",58,0)
 S ^XTMP(NODE,"error")="Cannot start a task job"
"RTN","HMPDCRC",59,0)
 S ^XTMP(NODE,"stop")=$$NOW^XLFDT()
"RTN","HMPDCRC",60,0)
 S ^XTMP(NODE,"task")=ZTSK
"RTN","HMPDCRC",61,0)
 Q
"RTN","HMPDCRC",62,0)
 ;
"RTN","HMPDCRC",63,0)
EN(FILTER) ; -- Return CRC values of requested data in ^XTMP(node,"data") as JSON
"RTN","HMPDCRC",64,0)
EN1 ;           [entry point for queued job]
"RTN","HMPDCRC",65,0)
 ;
"RTN","HMPDCRC",66,0)
 N ICN,DFN,NODE,UID,HMPP,TYPE,HMPTN,CRC
"RTN","HMPDCRC",67,0)
 N HMPCRC,HMPSTART,HMPSTOP,HMPMAX,HMPI,HMPID,HMPTYPE ;for HMPDJ0
"RTN","HMPDCRC",68,0)
 K ^TMP("HMPCRC",$J),^TMP("HMPCRCF",$J)
"RTN","HMPDCRC",69,0)
 ;
"RTN","HMPDCRC",70,0)
 ; parse & validate input parameters
"RTN","HMPDCRC",71,0)
 S DFN=$G(FILTER("patientId")),HMPCRC=""
"RTN","HMPDCRC",72,0)
 S ICN=+$P($G(DFN),";",2),DFN=+$G(DFN)
"RTN","HMPDCRC",73,0)
 I DFN<1,ICN S DFN=+$$GETDFN^MPIF001(ICN)
"RTN","HMPDCRC",74,0)
 Q:DFN<1!'$D(^DPT(DFN))  ;ICR 10035 DE 2818 ASF 11/2/15
"RTN","HMPDCRC",75,0)
 S NODE=$G(FILTER("node")) I NODE="" S NODE="HMPDCRC"
"RTN","HMPDCRC",76,0)
 ;
"RTN","HMPDCRC",77,0)
 S HMPMAX=9999,HMPI=0                                ;for HMPDJ0
"RTN","HMPDCRC",78,0)
 S HMPSTART=+$G(FILTER("start"),1410102)
"RTN","HMPDCRC",79,0)
 S HMPSTOP=+$G(FILTER("stop"),4141015)
"RTN","HMPDCRC",80,0)
 S UID=$G(FILTER("uid")),HMPTYPE=$G(FILTER("domain"))
"RTN","HMPDCRC",81,0)
 I $L(UID) S HMPTYPE=$P(UID,":",3),HMPID=$P(UID,":",6)
"RTN","HMPDCRC",82,0)
 E  S:HMPTYPE="" HMPTYPE=$$ALL
"RTN","HMPDCRC",83,0)
 ;
"RTN","HMPDCRC",84,0)
 F HMPP=1:1:$L(HMPTYPE,";") S TYPE=$P(HMPTYPE,";",HMPP) I $L(TYPE) D
"RTN","HMPDCRC",85,0)
 . S HMPTN=$$TAG^HMPDJ(TYPE)_"^HMPDJ0" Q:'$L($T(@HMPTN))
"RTN","HMPDCRC",86,0)
 . D @HMPTN
"RTN","HMPDCRC",87,0)
 ;
"RTN","HMPDCRC",88,0)
 I $L(UID) D  G ENQ ;single item
"RTN","HMPDCRC",89,0)
 . S CRC=$G(^TMP("HMPCRC",$J,HMPTYPE,UID))
"RTN","HMPDCRC",90,0)
 . S ^XTMP(NODE,"data",1)=CRC,^XTMP(NODE,"stop")=$$NOW^XLFDT()
"RTN","HMPDCRC",91,0)
 ; generate checksum for each domain requested
"RTN","HMPDCRC",92,0)
 S TYPE="" F  S TYPE=$O(^TMP("HMPCRC",$J,TYPE)) Q:TYPE=""  D
"RTN","HMPDCRC",93,0)
 . S CRC="" D GET($NA(^TMP("HMPCRC",$J,TYPE)),.CRC)
"RTN","HMPDCRC",94,0)
 . S ^TMP("HMPCRC",$J,TYPE)=CRC
"RTN","HMPDCRC",95,0)
 I $L(HMPTYPE,";")>1 D  ;get whole-chart checksum
"RTN","HMPDCRC",96,0)
 . S CRC="" D GET($NA(^TMP("HMPCRC",$J)),.CRC)
"RTN","HMPDCRC",97,0)
 . S ^TMP("HMPCRC",$J,"patient")=CRC
"RTN","HMPDCRC",98,0)
 ;
"RTN","HMPDCRC",99,0)
ENCODE ; -- return list(s) of checksums as JSON
"RTN","HMPDCRC",100,0)
 D PREP
"RTN","HMPDCRC",101,0)
 D ENCODE^HMPJSON($NA(^TMP("HMPCRCF",$J)),$NA(^XTMP(NODE,"data")),"ERROR")
"RTN","HMPDCRC",102,0)
 S ^XTMP(NODE,"stop")=$$NOW^XLFDT()
"RTN","HMPDCRC",103,0)
 ;
"RTN","HMPDCRC",104,0)
ENQ K ^TMP("HMPCRC",$J),^TMP("HMPCRCF",$J)
"RTN","HMPDCRC",105,0)
 Q
"RTN","HMPDCRC",106,0)
 ;
"RTN","HMPDCRC",107,0)
PREP ; -- reformat ^TMP("HMPCRC",$J) for JSON utility -> ^TMP("HMPCRCF",$J)
"RTN","HMPDCRC",108,0)
 N DCNT,DOMAIN,UID,UCNT
"RTN","HMPDCRC",109,0)
 S DOMAIN="",DCNT=0
"RTN","HMPDCRC",110,0)
 F  S DOMAIN=$O(^TMP("HMPCRC",$J,DOMAIN)) Q:DOMAIN=""  D
"RTN","HMPDCRC",111,0)
 . S ^TMP("HMPCRCF",$J,DOMAIN,"crc")=^TMP("HMPCRC",$J,DOMAIN)
"RTN","HMPDCRC",112,0)
 . S UCNT=0,UID="" F  S UID=$O(^TMP("HMPCRC",$J,DOMAIN,UID)) Q:UID=""  D
"RTN","HMPDCRC",113,0)
 .. S UCNT=UCNT+1,^TMP("HMPCRCF",$J,DOMAIN,"uids",UCNT,UID)=^TMP("HMPCRC",$J,DOMAIN,UID)
"RTN","HMPDCRC",114,0)
 Q
"RTN","HMPDCRC",115,0)
 ;
"RTN","HMPDCRC",116,0)
GET(LIST,CRC) ; -- compute CRC32 value for LIST of strings
"RTN","HMPDCRC",117,0)
 N I S CRC=$G(CRC),I=""
"RTN","HMPDCRC",118,0)
 F  S I=$O(@LIST@(I)) Q:I=""  I $G(@LIST@(I))'="" S CRC=$$CRC32^XLFCRC(I_":"_@LIST@(I),CRC)
"RTN","HMPDCRC",119,0)
 Q
"RTN","HMPDCRC",120,0)
 ;
"RTN","HMPDCRC",121,0)
ONE(ARRAY,COLL) ; -- process one data item [save result in ^TMP]
"RTN","HMPDCRC",122,0)
 N LIST,UID,ATTR,CRC
"RTN","HMPDCRC",123,0)
 S LIST=$$ATTR(COLL),UID=$G(@ARRAY@("uid")) Q:UID=""
"RTN","HMPDCRC",124,0)
 S ATTR="" F  S ATTR=$O(@ARRAY@(ATTR)) Q:ATTR=""  I LIST'[(U_ATTR_U) K @ARRAY@(ATTR)
"RTN","HMPDCRC",125,0)
 D GET(ARRAY,.CRC)
"RTN","HMPDCRC",126,0)
 S ^TMP("HMPCRC",$J,COLL,UID)=CRC
"RTN","HMPDCRC",127,0)
 S HMPI=HMPI+1
"RTN","HMPDCRC",128,0)
 Q
"RTN","HMPDCRC",129,0)
 ;
"RTN","HMPDCRC",130,0)
GET1(ARRAY,COLL) ; -- process one data item [return result]
"RTN","HMPDCRC",131,0)
 N LIST,ATTR,ITEM,CRC
"RTN","HMPDCRC",132,0)
 S LIST=$$ATTR(COLL)
"RTN","HMPDCRC",133,0)
 S ATTR="" F  S ATTR=$O(@ARRAY@(ATTR)) Q:ATTR=""  I LIST[(U_ATTR_U) S ITEM(ATTR)=@ARRAY@(ATTR)
"RTN","HMPDCRC",134,0)
 D GET(ITEM,.CRC)
"RTN","HMPDCRC",135,0)
 Q CRC
"RTN","HMPDCRC",136,0)
 ;
"RTN","HMPDCRC",137,0)
ALL() ; -- return string for all types of data
"RTN","HMPDCRC",138,0)
 Q "problem;allergy;consult;vital;lab;procedure;obs;order;treatment;med;ptf;factor;immunization;exam;cpt;education;pov;skin;image;appointment;surgery;document;visit;mh"
"RTN","HMPDCRC",139,0)
 ;
"RTN","HMPDCRC",140,0)
ATTR(X) ; -- return list of attributes needed for collection X
"RTN","HMPDCRC",141,0)
 N Y S Y=""
"RTN","HMPDCRC",142,0)
 I X="vital"        S Y="^observed^typeName^result^"
"RTN","HMPDCRC",143,0)
 I X="problem"      S Y="^onset^problemText^statusName^"
"RTN","HMPDCRC",144,0)
 I X="allergy"      S Y="^entered^summary^"
"RTN","HMPDCRC",145,0)
 I X="order"        S Y="^start^name^statusName^"
"RTN","HMPDCRC",146,0)
 I X="treatment"    S Y="^start^name^statusName^"
"RTN","HMPDCRC",147,0)
 I X="med"          S Y="^overallstart^name^vaStatus^"
"RTN","HMPDCRC",148,0)
 I X="consult"      S Y="^startDate^typeName^statusName^"
"RTN","HMPDCRC",149,0)
 I X="procedure"    S Y="^dateTime^name^statusName^"
"RTN","HMPDCRC",150,0)
 I X="obs"          S Y="^observed^typeName^result^"
"RTN","HMPDCRC",151,0)
 I X="lab"          S Y="^observed^typeName^"
"RTN","HMPDCRC",152,0)
 I X="image"        S Y="^dateTime^name^statusName^"
"RTN","HMPDCRC",153,0)
 I X="surgery"      S Y="^dateTime^typeName^statusName^"
"RTN","HMPDCRC",154,0)
 I X="document"     S Y="^referenceDateTime^localTitle^statusName^"
"RTN","HMPDCRC",155,0)
 I X="mh"           S Y="^administeredDateTime^name^"
"RTN","HMPDCRC",156,0)
 I X="immunization" S Y="^administeredDateTime^name^"
"RTN","HMPDCRC",157,0)
 I X="pov"          S Y="^entered^name^"
"RTN","HMPDCRC",158,0)
 I X="skin"         S Y="^entered^name^result^"
"RTN","HMPDCRC",159,0)
 I X="exam"         S Y="^entered^name^result^"
"RTN","HMPDCRC",160,0)
 I X="cpt"          S Y="^entered^name^"
"RTN","HMPDCRC",161,0)
 I X="education"    S Y="^entered^name^result^"
"RTN","HMPDCRC",162,0)
 I X="factor"       S Y="^entered^name^"
"RTN","HMPDCRC",163,0)
 I X="appointment"  S Y="^dateTime^typeName^appointmentStatus^"
"RTN","HMPDCRC",164,0)
 I X="visit"        S Y="^dateTime^typeName^"
"RTN","HMPDCRC",165,0)
 I X="ptf"          S Y="^arrivalDateTime^icdCode^"
"RTN","HMPDCRC",166,0)
 Q Y
"RTN","HMPDCRC",167,0)
 ;
"RTN","HMPDCRC",168,0)
 ;
"RTN","HMPDCRC",169,0)
TEST(FILTER) ;
"RTN","HMPDCRC",170,0)
 N DONE,OUT
"RTN","HMPDCRC",171,0)
 S DONE=0
"RTN","HMPDCRC",172,0)
 F  D  Q:DONE=1
"RTN","HMPDCRC",173,0)
 .D CHECK(.OUT,.FILTER)
"RTN","HMPDCRC",174,0)
 .H 1 W !,$D(OUT)
"RTN","HMPDCRC",175,0)
 .I $D(OUT)>0 S DONE=1
"RTN","HMPDCRC",176,0)
 Q
"RTN","HMPDGMRA")
0^15^B23357348^B22211624
"RTN","HMPDGMRA",1,0)
HMPDGMRA ;SLC/MKB,ASMR/RRB,JD - Allergy/Reaction extract;May 15, 2016 14:15
"RTN","HMPDGMRA",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDGMRA",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDGMRA",4,0)
 ;
"RTN","HMPDGMRA",5,0)
 ;DE4220 - JD - 4/1/16: Fixed the date function so that seconds are considered for
"RTN","HMPDGMRA",6,0)
 ;                      Origination Date/Time field (^DD(120.8,4)).
"RTN","HMPDGMRA",7,0)
 ;
"RTN","HMPDGMRA",8,0)
 ; External References          DBIA#
"RTN","HMPDGMRA",9,0)
 ; -------------------          -----
"RTN","HMPDGMRA",10,0)
 ; ^VA(200                      10060
"RTN","HMPDGMRA",11,0)
 ; %DT                          10003
"RTN","HMPDGMRA",12,0)
 ; GMRADPT                      10099
"RTN","HMPDGMRA",13,0)
 ; EN1^GMRAOR2                   2422
"RTN","HMPDGMRA",14,0)
 ; PSN50P41                      4531
"RTN","HMPDGMRA",15,0)
 ; PSN50P65                      4543
"RTN","HMPDGMRA",16,0)
 Q
"RTN","HMPDGMRA",17,0)
 ; ------------ Get reactions from VistA ------------
"RTN","HMPDGMRA",18,0)
 ;
"RTN","HMPDGMRA",19,0)
EN(DFN,BEG,END,MAX,IFN) ; -- find patient's allergies/reactions
"RTN","HMPDGMRA",20,0)
 N GMRA,GMRAL,HMPN,HMPITM,HMPCNT
"RTN","HMPDGMRA",21,0)
 S DFN=+$G(DFN) Q:DFN<1
"RTN","HMPDGMRA",22,0)
 S BEG=$G(BEG,1410101),END=$G(END,4141015),MAX=$G(MAX,9999),HMPCNT=0
"RTN","HMPDGMRA",23,0)
 D EN1^GMRADPT
"RTN","HMPDGMRA",24,0)
 ;
"RTN","HMPDGMRA",25,0)
 ; get one reaction
"RTN","HMPDGMRA",26,0)
 I $G(IFN) D EN1(IFN,.HMPITM),XML(.HMPITM) Q
"RTN","HMPDGMRA",27,0)
 ;
"RTN","HMPDGMRA",28,0)
 ; get all reactions
"RTN","HMPDGMRA",29,0)
 I 'GMRAL D  Q
"RTN","HMPDGMRA",30,0)
 . S HMPITM("assessment")=$S(GMRAL=0:"nka",1:"not done")
"RTN","HMPDGMRA",31,0)
 . S HMPITM("facility")=$$FAC^HMPD ;local stn#^name
"RTN","HMPDGMRA",32,0)
 . D XML(.HMPITM)
"RTN","HMPDGMRA",33,0)
 S HMPN=0 F  S HMPN=+$O(GMRAL(HMPN)) Q:HMPN<1  D  Q:HMPCNT'<MAX
"RTN","HMPDGMRA",34,0)
 . K HMPITM D EN1(HMPN,.HMPITM) Q:'$D(HMPITM)
"RTN","HMPDGMRA",35,0)
 . D XML(.HMPITM) S HMPCNT=HMPCNT+1
"RTN","HMPDGMRA",36,0)
 Q
"RTN","HMPDGMRA",37,0)
 ;
"RTN","HMPDGMRA",38,0)
EN1(ID,REAC) ; -- return a reaction in REAC("attribute")=value
"RTN","HMPDGMRA",39,0)
 ;          from EN: expects GMRAL(ID)
"RTN","HMPDGMRA",40,0)
 N HMPY,GMRA,I,J,X,Y,SEV,TXT,SEV K REAC
"RTN","HMPDGMRA",41,0)
 S GMRA=$G(GMRAL(ID)) D EN1^GMRAOR2(ID,"HMPY")
"RTN","HMPDGMRA",42,0)
 S X=$P(HMPY,U,10) I $L(X) S X=$$DATE(X) Q:X<BEG  Q:X>END  S REAC("entered")=X
"RTN","HMPDGMRA",43,0)
 S REAC("facility")=$$FAC^HMPD ;local stn#^name
"RTN","HMPDGMRA",44,0)
 S REAC("id")=ID,REAC("name")=$P(HMPY,U) I $P(GMRA,U,9) D
"RTN","HMPDGMRA",45,0)
 . S X=$P(GMRA,U,9),Y=+$P(X,"(",2) I 'Y,X["PSDRUG" S Y=50
"RTN","HMPDGMRA",46,0)
 . S REAC("localCode")=X,REAC("vuid")=$$VUID^HMPD(+X,Y)
"RTN","HMPDGMRA",47,0)
 S X=$P(HMPY,U,6) S:$L(X) REAC("mechanism")=X
"RTN","HMPDGMRA",48,0)
 S X=$P(HMPY,U,5),REAC("source")=$E(X)
"RTN","HMPDGMRA",49,0)
 S REAC("type")=$S($L(GMRA):$P(GMRA,U,7),1:$$DFO($P(HMPY,U,7)))_U_$P(HMPY,U,7)
"RTN","HMPDGMRA",50,0)
 I $P(HMPY,U,4)="VERIFIED",$P(HMPY,U,9) S REAC("verified")=$P(HMPY,U,9)
"RTN","HMPDGMRA",51,0)
 S I=0,SEV="" F  S I=$O(HMPY("O",I)) Q:I<1  S X=$P(HMPY("O",I),U,2) S:X]SEV SEV=X ;find highest severity
"RTN","HMPDGMRA",52,0)
 S:$L(SEV) REAC("severity")=SEV
"RTN","HMPDGMRA",53,0)
 ; reactions
"RTN","HMPDGMRA",54,0)
 S I=0 F  S I=$O(GMRAL(ID,"S",I)) Q:I<1  D
"RTN","HMPDGMRA",55,0)
 . S X=$G(GMRAL(ID,"S",I)),Y=+$P(X,";",2)
"RTN","HMPDGMRA",56,0)
 . S REAC("reaction",I)=$P(X,";")_U_$$VUID^HMPD(Y,120.83)
"RTN","HMPDGMRA",57,0)
 ; comments
"RTN","HMPDGMRA",58,0)
 S I=0 F  S I=$O(HMPY("C",I)) Q:I<1  D
"RTN","HMPDGMRA",59,0)
 . S X=$G(HMPY("C",I)) K TXT
"RTN","HMPDGMRA",60,0)
 . S Y=$$VA200($P(X,U,3))_U_$P(X,U)
"RTN","HMPDGMRA",61,0)
 . S Y=Y_U_$S($L($P(X,U,2)):$E($P(X,U,2)),1:"E")
"RTN","HMPDGMRA",62,0)
 . S J=0 F  S J=$O(HMPY("C",I,J)) Q:J<1  S X=$G(HMPY("C",I,J,0)),TXT(J)=X
"RTN","HMPDGMRA",63,0)
 . K X S X=$$STRING^HMPD(.TXT)
"RTN","HMPDGMRA",64,0)
 . S REAC("comment",I)=Y_U_X ;ien^name^date^type^text
"RTN","HMPDGMRA",65,0)
 ; drug info
"RTN","HMPDGMRA",66,0)
 I $D(HMPY("I")) D
"RTN","HMPDGMRA",67,0)
 . N ROOT S ROOT=$$B^PSN50P41
"RTN","HMPDGMRA",68,0)
 . S I=0 F  S I=$O(HMPY("I",I)) Q:I<1  S X=$G(HMPY("I",I)) D
"RTN","HMPDGMRA",69,0)
 .. N IEN S IEN=$O(@ROOT@(X,0))
"RTN","HMPDGMRA",70,0)
 .. S REAC("drugIngredient",I)=X_U_$$VUID^HMPD(IEN,50.416)
"RTN","HMPDGMRA",71,0)
 I $D(HMPY("V")) D
"RTN","HMPDGMRA",72,0)
 . S I=0 F  S I=$O(HMPY("V",I)) Q:I<1  S X=$G(HMPY("V",I)) D
"RTN","HMPDGMRA",73,0)
 .. D C^PSN50P65("",$P(X,U,2),"PSN")
"RTN","HMPDGMRA",74,0)
 .. N IEN S IEN=+$O(^TMP($J,"PSN","C",$P(X,U),0))
"RTN","HMPDGMRA",75,0)
 .. S REAC("drugClass",I)=$P(X,U,2)_U_$$VUID^HMPD(IEN,50.605)
"RTN","HMPDGMRA",76,0)
 I GMRA="" S REAC("removed")=1 ;entered in error
"RTN","HMPDGMRA",77,0)
 Q
"RTN","HMPDGMRA",78,0)
 ;
"RTN","HMPDGMRA",79,0)
VA200(NAME) ; -- Return ien^name from #200
"RTN","HMPDGMRA",80,0)
 N Y S NAME=$G(NAME),Y="^"
"RTN","HMPDGMRA",81,0)
 I $L(NAME) S Y=+$O(^VA(200,"B",NAME,0))_U_NAME  ; IA 10060, DE2818
"RTN","HMPDGMRA",82,0)
 Q Y
"RTN","HMPDGMRA",83,0)
 ;
"RTN","HMPDGMRA",84,0)
DATE(X) ; -- Return internal form of date X
"RTN","HMPDGMRA",85,0)
 N %DT,Y
"RTN","HMPDGMRA",86,0)
 S %DT="STX" D ^%DT  ;Added the "S" to allow for seconds.  DE4220
"RTN","HMPDGMRA",87,0)
 Q Y
"RTN","HMPDGMRA",88,0)
 ;
"RTN","HMPDGMRA",89,0)
DFO(X) ; -- Return 'DFO' string for mechanism name(s)
"RTN","HMPDGMRA",90,0)
 N I,P,Y S Y=""
"RTN","HMPDGMRA",91,0)
 F I=1:1:$L(X,",") S P=$P(X,",",I),Y=Y_$S($E(P)=" ":$E(P,2),1:$E(P))
"RTN","HMPDGMRA",92,0)
 S:Y="" Y=$G(X)
"RTN","HMPDGMRA",93,0)
 Q Y
"RTN","HMPDGMRA",94,0)
 ;
"RTN","HMPDGMRA",95,0)
 ; ------------ Return data to middle tier ------------
"RTN","HMPDGMRA",96,0)
 ;
"RTN","HMPDGMRA",97,0)
XML(REAC) ; -- Return patient reaction as XML
"RTN","HMPDGMRA",98,0)
 ;  as <element code='123' displayName='ABC' />
"RTN","HMPDGMRA",99,0)
 N ATT,X,Y,I,P,NM,TAG
"RTN","HMPDGMRA",100,0)
 D ADD("<allergy>") S HMPTOTL=$G(HMPTOTL)+1
"RTN","HMPDGMRA",101,0)
 S ATT="" F  S ATT=$O(REAC(ATT)) Q:ATT=""  D  D:$L(Y) ADD(Y)
"RTN","HMPDGMRA",102,0)
 . I ATT="comment" D  S Y="" Q
"RTN","HMPDGMRA",103,0)
 .. S I=0,Y="<comments>" D ADD(Y)
"RTN","HMPDGMRA",104,0)
 .. F  S I=$O(REAC(ATT,I)) Q:I<1  S X=$G(REAC(ATT,I)) D
"RTN","HMPDGMRA",105,0)
 ... S Y="<comment id='"_I
"RTN","HMPDGMRA",106,0)
 ... S:$L($P(X,U,3)) Y=Y_"' entered='"_$P(X,U,3)
"RTN","HMPDGMRA",107,0)
 ... S:$L($P(X,U,2)) Y=Y_"' enteredBy='"_$$ESC^HMPD($P(X,U,2))
"RTN","HMPDGMRA",108,0)
 ... S:$L($P(X,U,4)) Y=Y_"' commentType='"_$P(X,U,4)
"RTN","HMPDGMRA",109,0)
 ... S:$L($P(X,U,5)) Y=Y_"' commentText='"_$$ESC^HMPD($P(X,U,5))
"RTN","HMPDGMRA",110,0)
 ... S Y=Y_"' />" D ADD(Y)
"RTN","HMPDGMRA",111,0)
 .. D ADD("</comments>")
"RTN","HMPDGMRA",112,0)
 . I $O(REAC(ATT,0)) D  S Y="" Q
"RTN","HMPDGMRA",113,0)
 .. S NM=ATT_$S($E(ATT,$L(ATT))="s":"es",1:"s") D ADD("<"_NM_">")
"RTN","HMPDGMRA",114,0)
 .. S I=0 F  S I=$O(REAC(ATT,I)) Q:I<1  D
"RTN","HMPDGMRA",115,0)
 ... S X=$G(REAC(ATT,I)),Y="<"_ATT_" "
"RTN","HMPDGMRA",116,0)
 ... F P=1:1 S TAG=$P("name^vuid^severity^Z",U,P) Q:TAG="Z"  I $L($P(X,U,P)) S Y=Y_TAG_"='"_$$ESC^HMPD($P(X,U,P))_"' "
"RTN","HMPDGMRA",117,0)
 ... S Y=Y_"/>" D ADD(Y)
"RTN","HMPDGMRA",118,0)
 .. D ADD("</"_NM_">")
"RTN","HMPDGMRA",119,0)
 . S X=$G(REAC(ATT)),Y="" Q:'$L(X)
"RTN","HMPDGMRA",120,0)
 . I X'["^" S Y="<"_ATT_" value='"_$$ESC^HMPD(X)_"' />" Q
"RTN","HMPDGMRA",121,0)
 . I $L(X)>1 D  S Y=""
"RTN","HMPDGMRA",122,0)
 .. S Y="<"_ATT_" "
"RTN","HMPDGMRA",123,0)
 .. F P=1:1 S TAG=$P("code^name^Z",U,P) Q:TAG="Z"  I $L($P(X,U,P)) S Y=Y_TAG_"='"_$$ESC^HMPD($P(X,U,P))_"' "
"RTN","HMPDGMRA",124,0)
 .. S Y=Y_"/>" D ADD(Y)
"RTN","HMPDGMRA",125,0)
 D ADD("</allergy>")
"RTN","HMPDGMRA",126,0)
 Q
"RTN","HMPDGMRA",127,0)
 ;
"RTN","HMPDGMRA",128,0)
ADD(X) ; Add a line @HMP@(n)=X
"RTN","HMPDGMRA",129,0)
 S HMPI=$G(HMPI)+1
"RTN","HMPDGMRA",130,0)
 S @HMP@(HMPI)=X
"RTN","HMPDGMRA",131,0)
 Q
"RTN","HMPDJ")
0^17^B36223990^B36572187
"RTN","HMPDJ",1,0)
HMPDJ ;SLC/MKB,ASMR/RRB,CK -- Serve VistA data as JSON via RPC;May 15, 2016 14:15
"RTN","HMPDJ",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJ",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ",4,0)
 ;
"RTN","HMPDJ",5,0)
 ; External References          DBIA#
"RTN","HMPDJ",6,0)
 ; -------------------          -----
"RTN","HMPDJ",7,0)
 ; ^DPT                         10035
"RTN","HMPDJ",8,0)
 ; MPIF001                       2701
"RTN","HMPDJ",9,0)
 ; XLFDT                        10103
"RTN","HMPDJ",10,0)
 ; XLFSTR                       10104
"RTN","HMPDJ",11,0)
 ; XUPARAM                       2541
"RTN","HMPDJ",12,0)
 ;
"RTN","HMPDJ",13,0)
 ; DE2818/RRB - SQA findings 1st 3 lines of code.
"RTN","HMPDJ",14,0)
 ;
"RTN","HMPDJ",15,0)
 Q
"RTN","HMPDJ",16,0)
GET(HMP,FILTER) ; -- Return search results as JSON in @HMP@(n)
"RTN","HMPDJ",17,0)
 ; RPC = HMP GET PATIENT DATA JSON
"RTN","HMPDJ",18,0)
 ; where FILTER("patientId") = DFN or DFN;ICN
"RTN","HMPDJ",19,0)
 ;       FILTER("domain")    = name of desired data type  (see HMPDJ0)
"RTN","HMPDJ",20,0)
 ;       FILTER("text")      = boolean, to include document text [opt]
"RTN","HMPDJ",21,0)
 ;       FILTER("start")     = start date.time of search         [opt]
"RTN","HMPDJ",22,0)
 ;       FILTER("stop")      = stop date.time of search          [opt]
"RTN","HMPDJ",23,0)
 ;       FILTER("max")       = maximum number of items to return [opt]
"RTN","HMPDJ",24,0)
 ;       FILTER("id")        = single item id to return          [opt]
"RTN","HMPDJ",25,0)
 ;       FILTER("uid")       = single record uid to return       [opt]
"RTN","HMPDJ",26,0)
 ;       FILTER("noHead")    = flag, to omit header and commas   [opt]
"RTN","HMPDJ",27,0)
 ;
"RTN","HMPDJ",28,0)
 N ICN,DFN,HMPI,HMPSYS,HMPTYPE,HMPSTART,HMPSTOP,HMPMAX,HMPID,HMPTEXT,HMPP,TYPE,HMPTN,HMPERR
"RTN","HMPDJ",29,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPDJ",30,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJ",31,0)
 S DT=$$DT^XLFDT             ;for crossing midnight boundary
"RTN","HMPDJ",32,0)
 ;
"RTN","HMPDJ",33,0)
 ; parse & validate input parameters
"RTN","HMPDJ",34,0)
 I $G(FILTER("uid"))'="" D SEPUID(.FILTER)
"RTN","HMPDJ",35,0)
 ;
"RTN","HMPDJ",36,0)
 S DFN=$G(FILTER("patientId"))
"RTN","HMPDJ",37,0)
 ;
"RTN","HMPDJ",38,0)
 S ICN=+$P($G(DFN),";",2),DFN=+$G(DFN)
"RTN","HMPDJ",39,0)
 I DFN<1,ICN S DFN=+$$GETDFN^MPIF001(ICN)
"RTN","HMPDJ",40,0)
 ;
"RTN","HMPDJ",41,0)
 S HMPTYPE=$G(FILTER("domain")) S:HMPTYPE="" HMPTYPE=$$ALL
"RTN","HMPDJ",42,0)
 I $D(ZTQUEUED) S HMP=$NA(^XTMP(HMPBATCH,HMPFZTSK,HMPTYPE)) K @HMP
"RTN","HMPDJ",43,0)
 I HMPTYPE'="new",DFN<1!'$D(^DPT(DFN)) S HMPERR=$$ERR(1,DFN) G GTQ ;ICR 10035 DE2818 ASF 11/2/15
"RTN","HMPDJ",44,0)
 ;
"RTN","HMPDJ",45,0)
 ; -- initialize chunking if from DOMPT^HMPDJFSP ; i.e. HMPCHNK defined *S68-JCH*
"RTN","HMPDJ",46,0)
 D CHNKINIT^HMPDJFSP(.HMP,.HMPI) ; *S68-JCH*
"RTN","HMPDJ",47,0)
 ;
"RTN","HMPDJ",48,0)
 S HMPSTART=+$G(FILTER("start"),1410102)
"RTN","HMPDJ",49,0)
 S HMPSTOP=+$G(FILTER("stop"),4141015)
"RTN","HMPDJ",50,0)
 S HMPMAX=+$G(FILTER("max"),999999)
"RTN","HMPDJ",51,0)
 I HMPSTART,HMPSTOP,HMPSTOP<HMPSTART D
"RTN","HMPDJ",52,0)
 . N X S X=HMPSTART,HMPSTART=HMPSTOP,HMPSTOP=X
"RTN","HMPDJ",53,0)
 I HMPSTOP,$L(HMPSTOP,".")<2 S HMPSTOP=HMPSTOP_".24"
"RTN","HMPDJ",54,0)
 ;
"RTN","HMPDJ",55,0)
 S HMPID=$G(FILTER("id"))
"RTN","HMPDJ",56,0)
 S HMPTEXT=+$G(FILTER("text"),1) ;default = true/text
"RTN","HMPDJ",57,0)
 ;
"RTN","HMPDJ",58,0)
 ;set error trap
"RTN","HMPDJ",59,0)
 K ^TMP($J,"HMP ERROR")
"RTN","HMPDJ",60,0)
 ;
"RTN","HMPDJ",61,0)
 ; extract data
"RTN","HMPDJ",62,0)
 I HMPTYPE="new",$L($T(EN^HMPDJX)),'$G(^XTMP("HMP-off","GET")) D EN^HMPDJX(HMPID,HMPMAX) Q  ;data updates
"RTN","HMPDJ",63,0)
 F HMPP=1:1:$L(HMPTYPE,";") S TYPE=$P(HMPTYPE,";",HMPP) I $L(TYPE) D
"RTN","HMPDJ",64,0)
 . S HMPTN=$$TAG(TYPE)_"^HMPDJ0" Q:'$L($T(@HMPTN))  ;D ERR(2) Q
"RTN","HMPDJ",65,0)
 . N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ",66,0)
 . S $ET="D ERRHDLR^HMPDERRH",ERRMSG="A problem occurred when trying to load patient data from an API."
"RTN","HMPDJ",67,0)
 . D @HMPTN
"RTN","HMPDJ",68,0)
 ;
"RTN","HMPDJ",69,0)
GTQ ; add item count and terminating characters
"RTN","HMPDJ",70,0)
 N ERROR I $D(^TMP($J,"HMP ERROR"))>0 D BUILDERR(.ERROR)
"RTN","HMPDJ",71,0)
 I +$G(FILTER("noHead"))=1 D  Q
"RTN","HMPDJ",72,0)
 .S @HMP@("total")=+$G(HMPI)
"RTN","HMPDJ",73,0)
 .I $L($G(ERROR(1)))>1 S @HMP@("error")=ERROR(1)
"RTN","HMPDJ",74,0)
 S @HMP@(.5)="{""apiVersion"":""1.01"",""params"":{"_$$SYS_"},"
"RTN","HMPDJ",75,0)
 I $D(HMPERR) S @HMP@(1)="""error"":{""message"":"""_HMPERR_"""}}" Q
"RTN","HMPDJ",76,0)
 I '$D(@HMP)!'$G(HMPI) D  Q
"RTN","HMPDJ",77,0)
 . I '$D(ERROR) S @HMP@(1)="""data"":{""totalItems"":0,""items"":[]}}" Q
"RTN","HMPDJ",78,0)
 . S @HMP@(1)="""data"":{""totalItems"":0,""items"":[]},"
"RTN","HMPDJ",79,0)
 . S @HMP@(2,1)=ERROR(1)_"}"
"RTN","HMPDJ",80,0)
 ;
"RTN","HMPDJ",81,0)
 S @HMP@(.6)="""data"":{""updated"":"""_$$HL7NOW_""",""totalItems"":"_HMPI_",""items"":["
"RTN","HMPDJ",82,0)
 S HMPI=HMPI+1,@HMP@(HMPI)=$S($D(ERROR):"]}",1:"]}}")
"RTN","HMPDJ",83,0)
 I $D(ERROR)>0 S HMPI=HMPI+1,@HMP@(HMPI,.3)=",",@HMP@(HMPI,1)=ERROR(1)_"}"
"RTN","HMPDJ",84,0)
 K ^TMP($J,"HMP ERROR"),^TMP("HMPTEXT",$J)
"RTN","HMPDJ",85,0)
 Q
"RTN","HMPDJ",86,0)
 ;
"RTN","HMPDJ",87,0)
SEPUID(FILTER) ; -- separate uid into FILTER pieces
"RTN","HMPDJ",88,0)
 N UID
"RTN","HMPDJ",89,0)
 S UID=$G(FILTER("uid")) K FILTER("uid") Q:UID=""
"RTN","HMPDJ",90,0)
 I $P(UID,":",4)'=HMPSYS Q
"RTN","HMPDJ",91,0)
 S FILTER("patientId")=$P(UID,":",5)
"RTN","HMPDJ",92,0)
 S FILTER("domain")=$P(UID,":",3)
"RTN","HMPDJ",93,0)
 S FILTER("id")=$P(UID,":",6)
"RTN","HMPDJ",94,0)
 Q
"RTN","HMPDJ",95,0)
 ;
"RTN","HMPDJ",96,0)
SYS() ; -- return system info for JSON header
"RTN","HMPDJ",97,0)
 Q """domain"":"""_$$KSP^XUPARAM("WHERE")_""",""systemId"":"""_HMPSYS_""""
"RTN","HMPDJ",98,0)
 ;
"RTN","HMPDJ",99,0)
BUILDERR(RESULT,DFN) ; -- build error array
"RTN","HMPDJ",100,0)
 N COUNT,MESSAGE,MSGCNT
"RTN","HMPDJ",101,0)
 S COUNT=$G(^TMP($J,"HMP ERROR","# of Errors"))
"RTN","HMPDJ",102,0)
 S MESSAGE="A mumps error occurred when extracting patient data. A total of "_COUNT_" occurred.\n\r"
"RTN","HMPDJ",103,0)
 S MSGCNT=0 F  S MSGCNT=$O(^TMP($J,"HMP ERROR","ERROR MESSAGE",MSGCNT)) Q:MSGCNT'>0  D
"RTN","HMPDJ",104,0)
 . S MESSAGE=MESSAGE_$G(^TMP($J,"HMP ERROR","ERROR MESSAGE",MSGCNT))_"\n\r"
"RTN","HMPDJ",105,0)
 S RESULT(1)="""error"":{""message"":"""_MESSAGE_"""}"
"RTN","HMPDJ",106,0)
 Q
"RTN","HMPDJ",107,0)
 ;
"RTN","HMPDJ",108,0)
TAG(X) ; -- Return linetag in HMPDJ0 routine for clinical domain X
"RTN","HMPDJ",109,0)
 N Y S X=$G(X,"Z")
"RTN","HMPDJ",110,0)
 S Y=$E($$UP^XLFSTR(X),1,8)
"RTN","HMPDJ",111,0)
 S:'$L($T(@(Y_"^HMPDJ0"))) Y="HMP"
"RTN","HMPDJ",112,0)
 Q Y
"RTN","HMPDJ",113,0)
 ;
"RTN","HMPDJ",114,0)
ALL() ; -- return string for all types of data
"RTN","HMPDJ",115,0)
 Q "patient;problem;allergy;consult;vital;lab;procedure;obs;order;treatment;med;ptf;factor;immunization;exam;cpt;education;pov;skin;image;appointment;surgery;document;visit;mh"
"RTN","HMPDJ",116,0)
 ;
"RTN","HMPDJ",117,0)
ERR(X,VAL) ; -- return error message
"RTN","HMPDJ",118,0)
 N MSG  S MSG="Error"
"RTN","HMPDJ",119,0)
 I X=1  S MSG="Patient with dfn '"_$G(VAL)_"' not found"
"RTN","HMPDJ",120,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPDJ",121,0)
 I X=3  S MSG="UID '"_$G(VAL)_"' not found"
"RTN","HMPDJ",122,0)
 I X=4  S MSG="Unable to create new object"
"RTN","HMPDJ",123,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPDJ",124,0)
 Q MSG
"RTN","HMPDJ",125,0)
 ;
"RTN","HMPDJ",126,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPDJ",127,0)
 Q $P($$FMTHL7^XLFDT($$NOW^XLFDT),"-")
"RTN","HMPDJ",128,0)
 ;
"RTN","HMPDJ",129,0)
ADD(ITEM,COLL) ; -- add ITEM to results
"RTN","HMPDJ",130,0)
 I $D(HMPCRC),$D(COLL) D ONE^HMPDCRC(ITEM,COLL) Q  ;checksum
"RTN","HMPDJ",131,0)
 ; -- add ITEM to @HMP@(HMPI) to return JSON
"RTN","HMPDJ",132,0)
 N HMPY,HMPERR
"RTN","HMPDJ",133,0)
 D ENCODE^HMPJSON(ITEM,"HMPY","HMPERR")
"RTN","HMPDJ",134,0)
 I $D(HMPERR) D  ;return ERRor instead of ITEM
"RTN","HMPDJ",135,0)
 . N HMPTMP,HMPTXT,HMPITM
"RTN","HMPDJ",136,0)
 . M HMPITM=@ITEM K HMPY
"RTN","HMPDJ",137,0)
 . S HMPTXT(1)="Problem encoding json output."
"RTN","HMPDJ",138,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.HMPITM)
"RTN","HMPDJ",139,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","HMPY","HMPERR")
"RTN","HMPDJ",140,0)
 I $D(HMPY) D
"RTN","HMPDJ",141,0)
 . S HMPI=HMPI+1
"RTN","HMPDJ",142,0)
 . I HMPI>1 S @HMP@(HMPI,.3)=","
"RTN","HMPDJ",143,0)
 . M @HMP@(HMPI)=HMPY
"RTN","HMPDJ",144,0)
 . ;
"RTN","HMPDJ",145,0)
 . ; -- chunk data if from DOMPT^HMPDJFSP ; i.e. HMPCHNK defined ; *S68-JCH*
"RTN","HMPDJ",146,0)
 . D CHNKCHK^HMPDJFSP(.HMP,.HMPI) ; *S68-JCH*
"RTN","HMPDJ",147,0)
 Q
"RTN","HMPDJ",148,0)
 ;
"RTN","HMPDJ",149,0)
TEST(DFN,TYPE,ID,TEXT,IN) ; -- test GET, write results to screen
"RTN","HMPDJ",150,0)
 N OUT,IDX S U="^"
"RTN","HMPDJ",151,0)
 S:'$D(IN("systemID")) IN("systemID")=$$SYS^HMPUTILS
"RTN","HMPDJ",152,0)
 S IN("patientId")=+$G(DFN)
"RTN","HMPDJ",153,0)
 S IN("domain")=$G(TYPE)
"RTN","HMPDJ",154,0)
 S:$D(ID) IN("id")=ID
"RTN","HMPDJ",155,0)
 S:$D(TEXT) IN("text")=TEXT
"RTN","HMPDJ",156,0)
 D GET(.OUT,.IN)
"RTN","HMPDJ",157,0)
 ;
"RTN","HMPDJ",158,0)
 S IDX=OUT
"RTN","HMPDJ",159,0)
 F  S IDX=$Q(@IDX) Q:IDX'?1"^TMP(""HMP"","1.N.E  Q:+$P(IDX,",",2)'=$J  W !,@IDX
"RTN","HMPDJ",160,0)
 Q
"RTN","HMPDJ",161,0)
 ;
"RTN","HMPDJ02")
0^21^B178097048^B178043401
"RTN","HMPDJ02",1,0)
HMPDJ02 ;SLC/MKB,ASMR/RRB,ASF,CK - Problems,Allergies,Vitals;May 15, 2016 14:15
"RTN","HMPDJ02",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJ02",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ02",4,0)
 ;
"RTN","HMPDJ02",5,0)
 ; External References          DBIA#
"RTN","HMPDJ02",6,0)
 ; -------------------          -----
"RTN","HMPDJ02",7,0)
 ; ^PXRMINDX                     4290
"RTN","HMPDJ02",8,0)
 ; DIC                           2051
"RTN","HMPDJ02",9,0)
 ; DIQ                           2056
"RTN","HMPDJ02",10,0)
 ; GMPLUTL2                      2741
"RTN","HMPDJ02",11,0)
 ; GMRADPT                      10099
"RTN","HMPDJ02",12,0)
 ; GMRAOR2                       2422
"RTN","HMPDJ02",13,0)
 ; GMRVUT0,^UTILITY($J           1446
"RTN","HMPDJ02",14,0)
 ; GMVGETQL                      5048
"RTN","HMPDJ02",15,0)
 ; GMVGETVT                      5047
"RTN","HMPDJ02",16,0)
 ; GMVUTL                        5046
"RTN","HMPDJ02",17,0)
 ; ICDCODE                       3990
"RTN","HMPDJ02",18,0)
 ; XLFSTR                       10104
"RTN","HMPDJ02",19,0)
 ; XUAF4                         2171
"RTN","HMPDJ02",20,0)
 ;
"RTN","HMPDJ02",21,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ02",22,0)
 ;
"RTN","HMPDJ02",23,0)
 Q
"RTN","HMPDJ02",24,0)
 ;
"RTN","HMPDJ02",25,0)
GMPL1(ID,POVLST) ; -- problem
"RTN","HMPDJ02",26,0)
 N HMPL,PROB,X,I,DATE,USER,FAC,LEXS
"RTN","HMPDJ02",27,0)
 D DETAIL^GMPLUTL2(ID,.HMPL) Q:'$D(HMPL)  ;doesn't exist
"RTN","HMPDJ02",28,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ02",29,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ02",30,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the problem domain"
"RTN","HMPDJ02",31,0)
 ;
"RTN","HMPDJ02",32,0)
 S PROB("uid")=$$SETUID^HMPUTILS("problem",DFN,ID),PROB("localId")=ID
"RTN","HMPDJ02",33,0)
 S PROB("problemText")=$G(HMPL("NARRATIVE"))
"RTN","HMPDJ02",34,0)
 S DATE=$P($G(HMPL("ENTERED")),U)
"RTN","HMPDJ02",35,0)
 S:$L(DATE) DATE=$$DATE^HMPDGMPL(DATE),PROB("entered")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ02",36,0)
 S X=$G(HMPL("DIAGNOSIS")) I $L(X) D
"RTN","HMPDJ02",37,0)
 . N ICD9ZN,DIAG,SCTCODE
"RTN","HMPDJ02",38,0)
 . I DATE'>0 S DATE=DT
"RTN","HMPDJ02",39,0)
 . S ICD9ZN=$$ICDDX^ICDCODE(X,DATE),DIAG=$S($P($G(ICD9ZN),U,4)'="":$P(ICD9ZN,U,4),1:X)
"RTN","HMPDJ02",40,0)
 . ; BEGIN MOD ASF 09/8/15 US 9239 DE 2082
"RTN","HMPDJ02",41,0)
 . ; Only set icdCode and icdName if it is ICD9 (ICD10 is only available in codes array)
"RTN","HMPDJ02",42,0)
 . I HMPL("CSYS")="ICD" S PROB("icdCode")=$$SETNCS^HMPUTILS("icd",HMPL("DIAGNOSIS")),PROB("icdName")=DIAG
"RTN","HMPDJ02",43,0)
 . ; Create codes array for both ICD9 or ICD10
"RTN","HMPDJ02",44,0)
 . S PROB("codes",1,"code")=HMPL("DIAGNOSIS")
"RTN","HMPDJ02",45,0)
 . S PROB("codes",1,"display")=$S(HMPL("CSYS")="ICD":DIAG,HMPL("CSYS")="10D":HMPL("ICDD"))
"RTN","HMPDJ02",46,0)
 . S PROB("codes",1,"system")=$S(HMPL("CSYS")="ICD":"urn:oid:2.16.840.1.113883.6.42",HMPL("CSYS")="10D":"urn:oid:2.16.840.1.113883.6.3",1:"codesystem error")
"RTN","HMPDJ02",47,0)
 . ;SNOMED CT codes
"RTN","HMPDJ02",48,0)
 . S SCTCODE=$$GET1^DIQ(9000011,ID_",",80001) ;9000011,80001 SNOMED CT CONCEPT CODE
"RTN","HMPDJ02",49,0)
 . D:SCTCODE EN^LEXCODE(SCTCODE) ; ICR 1614
"RTN","HMPDJ02",50,0)
 . I $D(LEXS("SCT",1)) D
"RTN","HMPDJ02",51,0)
 . . S PROB("codes",2,"code")=SCTCODE
"RTN","HMPDJ02",52,0)
 . . S PROB("codes",2,"code","\s")="" ; Ensure code is sent as a string
"RTN","HMPDJ02",53,0)
 . . S PROB("codes",2,"display")=$P(LEXS("SCT",1),U,2)
"RTN","HMPDJ02",54,0)
 . . S PROB("codes",2,"system")="http://snomed.info/sct"
"RTN","HMPDJ02",55,0)
 . ; END MOD ASF US 9239 DE 2082
"RTN","HMPDJ02",56,0)
 S X=$G(HMPL("ONSET")) S:$L(X) X=$$DATE^HMPDGMPL(X),PROB("onset")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",57,0)
 S X=$G(HMPL("MODIFIED")) S:$L(X) X=$$DATE^HMPDGMPL(X),PROB("updated")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",58,0)
 S X=$G(HMPL("STATUS")) I $L(X) D
"RTN","HMPDJ02",59,0)
 . S PROB("statusName")=X,X=$E(X)
"RTN","HMPDJ02",60,0)
 . S X=$S(X="A":55561003,X="I":73425007,1:"")
"RTN","HMPDJ02",61,0)
 . S PROB("statusCode")=$$SETNCS^HMPUTILS("sct",X)
"RTN","HMPDJ02",62,0)
 S X=$G(HMPL("PRIORITY")) I X]"" D
"RTN","HMPDJ02",63,0)
 . S X=$$LOW^XLFSTR(X),PROB("acuityName")=X
"RTN","HMPDJ02",64,0)
 . S PROB("acuityCode")=$$SETVURN^HMPUTILS("prob-acuity",$E(X))
"RTN","HMPDJ02",65,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.07,"I") S:X PROB("resolved")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",66,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.02,"I")
"RTN","HMPDJ02",67,0)
 S:X="P" PROB("unverified")="false",PROB("removed")="false"
"RTN","HMPDJ02",68,0)
 S:X="T" PROB("unverified")="true",PROB("removed")="false"
"RTN","HMPDJ02",69,0)
 S:X="H" PROB("unverified")="false",PROB("removed")="true"
"RTN","HMPDJ02",70,0)
 S X=$G(HMPL("SC")),X=$S(X="YES":"",X="NO":"false",1:"")
"RTN","HMPDJ02",71,0)
 S:$L(X) PROB("serviceConnected")=X
"RTN","HMPDJ02",72,0)
 S X=$G(HMPL("PROVIDER")) I $L(X) D
"RTN","HMPDJ02",73,0)
 . S PROB("providerName")=X,X=$$GET1^DIQ(9000011,ID_",",1.05,"I")
"RTN","HMPDJ02",74,0)
 . S PROB("providerUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ02",75,0)
 S X=$$GET1^DIQ(9000011,ID_",",1.06) S:$L(X) PROB("service")=X
"RTN","HMPDJ02",76,0)
 S X=$G(HMPL("CLINIC")) I $L(X) D
"RTN","HMPDJ02",77,0)
 . S PROB("locationName")=X
"RTN","HMPDJ02",78,0)
 . N LOC S LOC=+$$FIND1^DIC(44,,"QX",X)
"RTN","HMPDJ02",79,0)
 . S:LOC PROB("locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ02",80,0)
 S X=+$$GET1^DIQ(9000011,ID_",",.06,"I")
"RTN","HMPDJ02",81,0)
 S:X FAC=$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U)
"RTN","HMPDJ02",82,0)
 I 'X S FAC=$$FAC^HMPD ;local stn#^name
"RTN","HMPDJ02",83,0)
 D FACILITY^HMPUTILS(FAC,"PROB")
"RTN","HMPDJ02",84,0)
 S I=0 F  S I=$O(HMPL("COMMENT",I)) Q:I<1  D
"RTN","HMPDJ02",85,0)
 . S X=$G(HMPL("COMMENT",I))
"RTN","HMPDJ02",86,0)
 . S USER=$$VA200^HMPDGMPL($P(X,U,2)),DATE=$$DATE^HMPDGMPL($P(X,U))
"RTN","HMPDJ02",87,0)
 . S PROB("comments",I,"enteredByCode")=$$SETUID^HMPUTILS("user",,+USER)
"RTN","HMPDJ02",88,0)
 . S PROB("comments",I,"enteredByName")=$P(X,U,2)
"RTN","HMPDJ02",89,0)
 . S PROB("comments",I,"entered")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ02",90,0)
 . S PROB("comments",I,"comment")=$P(X,U,3)
"RTN","HMPDJ02",91,0)
 I $D(POVLST) D GMPLVST(ID,"PROB",.POVLST)  ;JL;add encounter information. 
"RTN","HMPDJ02",92,0)
 S PROB("lastUpdateTime")=$$EN^HMPSTMP("problem")
"RTN","HMPDJ02",93,0)
 S PROB("stampTime")=PROB("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ02",94,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ02",95,0)
 I $G(HMPMETA) D ADD^HMPMETA("problem",PROB("uid"),PROB("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ02",96,0)
 D ADD^HMPDJ("PROB","problem")
"RTN","HMPDJ02",97,0)
 Q
"RTN","HMPDJ02",98,0)
 ;
"RTN","HMPDJ02",99,0)
GMPLVST(ID,Y,POVLST)  ; --- JL;associate problem with visit and notes
"RTN","HMPDJ02",100,0)
 ; DE2818, ^AUPNPROB( - ICR 1253
"RTN","HMPDJ02",101,0)
 Q:'$G(ID)!'$G(^AUPNPROB(ID,0))!'$D(POVLST)  ;invalid id or no data
"RTN","HMPDJ02",102,0)
 N ICDCODE
"RTN","HMPDJ02",103,0)
 S ICDCODE=$$CODEC^ICDCODE($P(^AUPNPROB(ID,0),U,1)) Q:ICDCODE=-1  ;invalid icdcode
"RTN","HMPDJ02",104,0)
 Q:$D(POVLST(ICDCODE))=0
"RTN","HMPDJ02",105,0)
 N IDX,VCNT,NCNT,DIEN,VIEN,FAC,STCODE
"RTN","HMPDJ02",106,0)
 S IDX="",VCNT=0,NCNT=0 F  S IDX=$O(POVLST(ICDCODE,IDX)) Q:IDX=""  D
"RTN","HMPDJ02",107,0)
 . S VCNT=VCNT+1
"RTN","HMPDJ02",108,0)
 . S VIEN=+$G(POVLST(ICDCODE,IDX)),FAC=$$FAC^HMPDJ04(VIEN),STCODE=$$STCODE^HMPDJ04(VIEN)
"RTN","HMPDJ02",109,0)
 . I FAC D FACILITY^HMPUTILS(FAC,Y_"(""encounters"","_VCNT_")")  ; facility info
"RTN","HMPDJ02",110,0)
 . I STCODE D STOPCODE^HMPDJ04(STCODE,Y_"(""encounters"","_VCNT_")") ; stop code
"RTN","HMPDJ02",111,0)
 . S @Y@("encounters",VCNT,"dateTime")=$$JSONDT^HMPUTILS($$DATE^HMPDGMPL(+IDX))
"RTN","HMPDJ02",112,0)
 . S @Y@("encounters",VCNT,"visitUid")=$$SETUID^HMPUTILS("visit",DFN,VIEN)
"RTN","HMPDJ02",113,0)
 . N ENINFO S ENINFO=$G(POVLST(ICDCODE,IDX))
"RTN","HMPDJ02",114,0)
 . S DIEN=+$P(ENINFO,U,2)
"RTN","HMPDJ02",115,0)
 . ;W "DIEN is "_DIEN,!
"RTN","HMPDJ02",116,0)
 . I DIEN D
"RTN","HMPDJ02",117,0)
 . . S NCNT=NCNT+1
"RTN","HMPDJ02",118,0)
 . . ; extract the extra data from the document
"RTN","HMPDJ02",119,0)
 . . N DOCINFO S DOCINFO=$E(ENINFO,$F($G(ENINFO),U),$L(ENINFO))
"RTN","HMPDJ02",120,0)
 . . N OUTPUT S OUTPUT="" D EN1^HMPDJ08(DOCINFO,3,.OUTPUT)
"RTN","HMPDJ02",121,0)
 . . N NAME F NAME="documentTypeName","entered","summary","facilityName","authorDisplayName" D
"RTN","HMPDJ02",122,0)
 . . . S:$D(OUTPUT(NAME)) @Y@("documents",NCNT,NAME)=$G(OUTPUT(NAME))
"RTN","HMPDJ02",123,0)
 . . S @Y@("documents",NCNT,"documentUid")=$$SETUID^HMPUTILS("document",DFN,DIEN)
"RTN","HMPDJ02",124,0)
 Q
"RTN","HMPDJ02",125,0)
 ;
"RTN","HMPDJ02",126,0)
GMPLPOV(DFNN,POVLST,DONTKILL) ; -- JL;All problem of visit related to the patient from V POV file
"RTN","HMPDJ02",127,0)
 ;INPUT: Patient's DFN
"RTN","HMPDJ02",128,0)
 ;OUTPUT: Patient's VISIT list in the format of
"RTN","HMPDJ02",129,0)
 ;        OUTPUT(DIAGNOSIS,DATATIME)="VISITIEN"
"RTN","HMPDJ02",130,0)
 ;
"RTN","HMPDJ02",131,0)
 Q:'$G(DFNN)
"RTN","HMPDJ02",132,0)
 N INVVST
"RTN","HMPDJ02",133,0)
 K:'DONTKILL POVLST ; clear the output
"RTN","HMPDJ02",134,0)
 ;DE2818, ^AUPNVPOV( - ICR 3094, ^AUPNVSIT( - ICR 2028
"RTN","HMPDJ02",135,0)
 ; Query V POV(^AUPNVPOV() by using "AA" Cross Reference.
"RTN","HMPDJ02",136,0)
 S INVVST="",CURVST="" F  S INVVST=$O(^AUPNVPOV("AA",DFNN,INVVST)) Q:INVVST=""  D
"RTN","HMPDJ02",137,0)
 . N CURVST,DIEN
"RTN","HMPDJ02",138,0)
 . S CURVST=INVVST,DIEN="" F  S DIEN=$O(^AUPNVPOV("AA",DFNN,CURVST,DIEN)) Q:DIEN=""  D
"RTN","HMPDJ02",139,0)
 . . N ICDIEN,PVISIT
"RTN","HMPDJ02",140,0)
 . . S ICDIEN=+$P(^AUPNVPOV(DIEN,0),U,1),PVISIT=$P(^AUPNVPOV(DIEN,0),U,3)
"RTN","HMPDJ02",141,0)
 . . N VISITDT
"RTN","HMPDJ02",142,0)
 . . S VISITDT=+$G(^AUPNVSIT(PVISIT,0)) Q:'$L(VISITDT)  ;quit if no visit is found, bad data entry.
"RTN","HMPDJ02",143,0)
 . . N ICDCODE,VIEN
"RTN","HMPDJ02",144,0)
 . . S ICDCODE=$$CODEC^ICDCODE(ICDIEN) Q:ICDCODE=-1  ;convert to ICD code, quit if not valid
"RTN","HMPDJ02",145,0)
 . . I $D(POVLST(ICDCODE,VISITDT))'=0 D  Q
"RTN","HMPDJ02",146,0)
 . . . S VIEN=$$GETVIEN(DFNN,VISITDT)
"RTN","HMPDJ02",147,0)
 . . . ; W:VIEN=-1 "Can not find VISIT IEN for "_VISITDT,!
"RTN","HMPDJ02",148,0)
 . . . S:VIEN'=-1 POVLST(ICDCODE,VISITDT)=VIEN
"RTN","HMPDJ02",149,0)
 Q
"RTN","HMPDJ02",150,0)
 ;
"RTN","HMPDJ02",151,0)
GETVIEN(DFNN,VISITDT)  ;JL; get the Visit IEN from VISIT file based on patient ID and Datetime
"RTN","HMPDJ02",152,0)
 Q:'+$G(DFNN)!'$L(VISITDT) -1  ;return -1 if bad parameter
"RTN","HMPDJ02",153,0)
 N REVDT,VISITIEN
"RTN","HMPDJ02",154,0)
 S REVDT=9999999-$P(VISITDT,".",1)_$S($P(VISITDT,".",2)'="":"."_$P(VISITDT,".",2),1:"")
"RTN","HMPDJ02",155,0)
 ; ;DE2818, ^AUPNVSIT( - ICR 2028
"RTN","HMPDJ02",156,0)
 S VISITIEN=$O(^AUPNVSIT("AA",DFNN,REVDT,""))  ; using "AA" cross-reference
"RTN","HMPDJ02",157,0)
 Q:VISITIEN="" -1
"RTN","HMPDJ02",158,0)
 Q VISITIEN
"RTN","HMPDJ02",159,0)
 ;
"RTN","HMPDJ02",160,0)
DIAGLIST(DIAGS,DFN,ORDATE,ORPRCNT) ;BL,JL; get list diagnosis on past notes
"RTN","HMPDJ02",161,0)
 S:'+$G(ORDATE) ORDATE=DT
"RTN","HMPDJ02",162,0)
 S:'+$G(ORPRCNT) ORPRCNT=1
"RTN","HMPDJ02",163,0)
 ;Use TIU DOCUMENTS BY CONTEXT to retrieve all notes associated with patient (CONTEXT^TIUSRVLO)
"RTN","HMPDJ02",164,0)
 K ENC,DIAGCODE,CNT,DIAG,DIAGNUM,DIAGLINE,ENCNUM,LINE,IEN,CLASS,CONTEXT,EARLY,LATE,PERSON,OCCLIM,SEQUENCE,SHOWADD,INCUND,LSTNUM,NOTEINFO
"RTN","HMPDJ02",165,0)
 K NEWCNT,OLDLST,DIAGCNT
"RTN","HMPDJ02",166,0)
 S CLASS=3,CONTEXT=1,EARLY=-1,LATE=-1,PERSON=0,OCCLIM=0,SEQUENCE="D",SHOWADD=0,INCUND=0,OLDLST=""
"RTN","HMPDJ02",167,0)
 ;TAKE EXISTING LIST FROM ENCOUNTER CALL AND PRESERVE TO BE APPENDED AFTERWARD
"RTN","HMPDJ02",168,0)
 K DIAGS S DIAGS=""
"RTN","HMPDJ02",169,0)
 D CONTEXT^TIUSRVLO(.DIAGS,CLASS,CONTEXT,DFN,EARLY,LATE,PERSON,OCCLIM,SEQUENCE,SHOWADD,INCUND)
"RTN","HMPDJ02",170,0)
 M DIAGS=^TMP("TIUR",$J)
"RTN","HMPDJ02",171,0)
 ;Go through notes list and use ORWPCE PCE4NOTE to extract diagnosis associated with each encounter to previous problem list (PCE4NOTE^ORWPCE3)
"RTN","HMPDJ02",172,0)
 S LSTNUM=""
"RTN","HMPDJ02",173,0)
 ;THIS CALL WILL EXTRACT ALL THE VISIT INFORMATION TO ^TMP(PXKENC,$J,VISIT)
"RTN","HMPDJ02",174,0)
 N VIEN
"RTN","HMPDJ02",175,0)
 F  S LSTNUM=$O(DIAGS(LSTNUM)) Q:LSTNUM=""  D
"RTN","HMPDJ02",176,0)
 . S NOTEINFO=""
"RTN","HMPDJ02",177,0)
 . S IEN=$P(DIAGS(LSTNUM),"^",1)
"RTN","HMPDJ02",178,0)
 . D PCE4NOTE^ORWPCE3(.NOTEINFO,IEN,DFN)
"RTN","HMPDJ02",179,0)
 . S CNT=0,DIAGCNT=0
"RTN","HMPDJ02",180,0)
 . F  S CNT=$O(NOTEINFO(CNT)) Q:CNT=""  D
"RTN","HMPDJ02",181,0)
 . . Q:$P(NOTEINFO(CNT),"^",1)'["POV"
"RTN","HMPDJ02",182,0)
 . . S DIAGCNT=DIAGCNT+1
"RTN","HMPDJ02",183,0)
 . . S VISITDT=$P($G(NOTEINFO(2)),U,3)  ; get the visit datetime
"RTN","HMPDJ02",184,0)
 . . S ICDCODE=$P(NOTEINFO(CNT),U,2)  ; get the diagnosis code
"RTN","HMPDJ02",185,0)
 . . I $D(ENC(ICDCODE,VISITDT))=0 D
"RTN","HMPDJ02",186,0)
 . . . S VIEN=$$GETVIEN(DFN,VISITDT)
"RTN","HMPDJ02",187,0)
 . . . ;W:VIEN=-1 "Can not find Visit ID for "_NOTEINFO(CNT),!
"RTN","HMPDJ02",188,0)
 . . . S:VIEN'=-1 ENC(ICDCODE,VISITDT)=VIEN_U_$G(DIAGS(LSTNUM)) ;  add to list only if visit ien is valid
"RTN","HMPDJ02",189,0)
 ; KILL DIAGS BECAUSE IT NOW CONTAINS NOTE INFO
"RTN","HMPDJ02",190,0)
 K DIAGS
"RTN","HMPDJ02",191,0)
 M DIAGS=ENC
"RTN","HMPDJ02",192,0)
 ;CLEAN UP ARRAYS
"RTN","HMPDJ02",193,0)
 K NOTEINFO,ENC,DIAG,^TMP("TIUR",$J)
"RTN","HMPDJ02",194,0)
 D GMPLPOV(DFN,.DIAGS,1)  ; Also loop thru V POV file to find extra encounter
"RTN","HMPDJ02",195,0)
 Q
"RTN","HMPDJ02",196,0)
 ;
"RTN","HMPDJ02",197,0)
GMRA1(ID) ; -- allergy/reaction GMRAL(ID)
"RTN","HMPDJ02",198,0)
 N GMRA,HMPY,REAC,X,Y,I,USER,CMMT
"RTN","HMPDJ02",199,0)
 S GMRA=$G(GMRAL(ID)) D EN1^GMRAOR2(ID,"HMPY")
"RTN","HMPDJ02",200,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ02",201,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ02",202,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the allergy domain"
"RTN","HMPDJ02",203,0)
 ;
"RTN","HMPDJ02",204,0)
 S X=$P(HMPY,U,10) I $L(X) S X=$$DATE^HMPDGMRA(X) Q:X<HMPSTART  Q:X>HMPSTOP  S REAC("entered")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ02",205,0)
 S X=$$FAC^HMPD D FACILITY^HMPUTILS(X,"REAC")
"RTN","HMPDJ02",206,0)
 S REAC("kind")="Allergy / Adverse Reaction"
"RTN","HMPDJ02",207,0)
 S REAC("localId")=ID,REAC("uid")=$$SETUID^HMPUTILS("allergy",DFN,ID)
"RTN","HMPDJ02",208,0)
 S (REAC("summary"),REAC("products",1,"name"))=$P(HMPY,U) I $P(GMRA,U,9) D
"RTN","HMPDJ02",209,0)
 . S X=$P(GMRA,U,9),REAC("reference")=X
"RTN","HMPDJ02",210,0)
 . S Y=+$P(X,"(",2) I 'Y,X["PSDRUG" S Y=50
"RTN","HMPDJ02",211,0)
 . S I=$$VUID^HMPD(+X,Y),REAC("products",1,"vuid")=$$SETVURN^HMPUTILS("vuid",I)
"RTN","HMPDJ02",212,0)
 S X=$P(HMPY,U,2) S:$L(X) REAC("originatorName")=X
"RTN","HMPDJ02",213,0)
 S REAC("historical")=$S($E($P(HMPY,U,5))="H":"true",1:"false")
"RTN","HMPDJ02",214,0)
 S X=$P(HMPY,U,6) S:$L(X) REAC("mechanism")=X
"RTN","HMPDJ02",215,0)
 S X=$P(HMPY,U,7) S:$L(X) REAC("typeName")=X
"RTN","HMPDJ02",216,0)
 ; REAC("adverseEventTypeName")=$P(HMPY,U,7)_" "_$P(HMPY,U,6) ;TYPE_MECH
"RTN","HMPDJ02",217,0)
 I $P(HMPY,U,4)="VERIFIED",$P(HMPY,U,9) D
"RTN","HMPDJ02",218,0)
 . S REAC("verified")=$$JSONDT^HMPUTILS($P(HMPY,U,9))
"RTN","HMPDJ02",219,0)
 . S REAC("verifierName")=$P(HMPY,U,8)
"RTN","HMPDJ02",220,0)
 ; severity
"RTN","HMPDJ02",221,0)
 S I=0 F  S I=$O(HMPY("O",I)) Q:I<1  D
"RTN","HMPDJ02",222,0)
 . S X=$G(HMPY("O",I))
"RTN","HMPDJ02",223,0)
 . S REAC("observations",I,"date")=$$JSONDT^HMPUTILS(+X)
"RTN","HMPDJ02",224,0)
 . S REAC("observations",I,"severity")=$P(X,U,2)
"RTN","HMPDJ02",225,0)
 ; reactions
"RTN","HMPDJ02",226,0)
 S I=0 F  S I=$O(GMRAL(ID,"S",I)) Q:I<1  D
"RTN","HMPDJ02",227,0)
 . S X=$G(GMRAL(ID,"S",I))
"RTN","HMPDJ02",228,0)
 . S REAC("reactions",I,"name")=$P(X,";")
"RTN","HMPDJ02",229,0)
 . S Y=$$VUID^HMPD(+$P(X,";",2),120.83)
"RTN","HMPDJ02",230,0)
 . S REAC("reactions",I,"vuid")=$$SETVURN^HMPUTILS("vuid",Y)
"RTN","HMPDJ02",231,0)
 ; drug classes
"RTN","HMPDJ02",232,0)
 S I=0 F  S I=$O(HMPY("V",I)) Q:I<1  D
"RTN","HMPDJ02",233,0)
 . S X=$G(HMPY("V",I))
"RTN","HMPDJ02",234,0)
 . S REAC("drugClasses",I,"code")=$P(X,U)
"RTN","HMPDJ02",235,0)
 . S REAC("drugClasses",I,"name")=$P(X,U,2)
"RTN","HMPDJ02",236,0)
 S I=0 F  S I=$O(HMPY("C",I)) Q:I<1  D
"RTN","HMPDJ02",237,0)
 . S X=$G(HMPY("C",I)),USER=$$VA200^HMPDGMPL($P(X,U,3))
"RTN","HMPDJ02",238,0)
 . S REAC("comments",I,"enteredByUid")=$$SETUID^HMPUTILS("user",,+USER)
"RTN","HMPDJ02",239,0)
 . S REAC("comments",I,"enteredByName")=$P(X,U,3)
"RTN","HMPDJ02",240,0)
 . S REAC("comments",I,"entered")=$$JSONDT^HMPUTILS(+X)
"RTN","HMPDJ02",241,0)
 . K CMMT M CMMT=HMPY("C",I)
"RTN","HMPDJ02",242,0)
 . S REAC("comments",I,"comment")=$$STRING^HMPD(.CMMT)
"RTN","HMPDJ02",243,0)
 I GMRA="" S REAC("removed")="true" ;entered in error
"RTN","HMPDJ02",244,0)
 ; next
"RTN","HMPDJ02",245,0)
 S REAC("lastUpdateTime")=$$EN^HMPSTMP("allergy")
"RTN","HMPDJ02",246,0)
 S REAC("stampTime")=REAC("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ02",247,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ02",248,0)
 I $G(HMPMETA) D ADD^HMPMETA("allergy",REAC("uid"),REAC("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ02",249,0)
 D ADD^HMPDJ("REAC","allergy")
"RTN","HMPDJ02",250,0)
 Q
"RTN","HMPDJ02",251,0)
 ;
"RTN","HMPDJ02",252,0)
NKA ; -- no assessment or NKA [GMRAL=0 or ""]
"RTN","HMPDJ02",253,0)
 N REAC,X
"RTN","HMPDJ02",254,0)
 ;DE2818, ^GMR(120.86 - ICR 3449
"RTN","HMPDJ02",255,0)
 S X=$G(^GMR(120.86,DFN,0)) Q:GMRAL=""!'$P(X,U,2)  ;DE2818, ICR 3449
"RTN","HMPDJ02",256,0)
 S REAC("uid")=$$SETUID^HMPUTILS("obs",DFN,"120.86;"_DFN)
"RTN","HMPDJ02",257,0)
 S REAC("typeCode")="urn:sct:160244002"
"RTN","HMPDJ02",258,0)
 S REAC("typeName")="No known allergies"
"RTN","HMPDJ02",259,0)
 S X=$$FAC^HMPD D FACILITY^HMPUTILS(X,"REAC")
"RTN","HMPDJ02",260,0)
 D ADD^HMPDJ("REAC","allergy")
"RTN","HMPDJ02",261,0)
 Q
"RTN","HMPDJ02",262,0)
 ;
"RTN","HMPDJ02",263,0)
GMV1(ID) ; -- vital/measurement ^UTILITY($J,"GMRVD",HMPIDT,HMPTYP,ID)
"RTN","HMPDJ02",264,0)
 N VIT,HMPY,X0,TYPE,LOC,FAC,X,Y,MRES,MUNT,HIGH,LOW,I
"RTN","HMPDJ02",265,0)
 D GETREC^GMVUTL(.HMPY,ID,1) S X0=$G(HMPY(0))
"RTN","HMPDJ02",266,0)
 ; DE281, ^PXRMINDX(120.5 - ICR 4290
"RTN","HMPDJ02",267,0)
 ; GMRVUT0 returns CLiO data with a pseudo-ID >> get real ID
"RTN","HMPDJ02",268,0)
 I X0="",$G(HMPIDT),$D(HMPTYP) D  ;[from HMPDJ0]
"RTN","HMPDJ02",269,0)
 . N GMRVD S GMRVD=$G(^UTILITY($J,"GMRVD",HMPIDT,HMPTYP,ID))
"RTN","HMPDJ02",270,0)
 . S ID=$O(^PXRMINDX(120.5,"PI",DFN,$P(GMRVD,U,3),+GMRVD,""))
"RTN","HMPDJ02",271,0)
 . I $L(ID) D GETREC^GMVUTL(.HMPY,ID,1) S X0=$G(HMPY(0))
"RTN","HMPDJ02",272,0)
 Q:X0=""
"RTN","HMPDJ02",273,0)
 ;
"RTN","HMPDJ02",274,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ02",275,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ02",276,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the vitals domain"
"RTN","HMPDJ02",277,0)
 S VIT("localId")=ID,VIT("kind")="Vital Sign"
"RTN","HMPDJ02",278,0)
 S VIT("uid")=$$SETUID^HMPUTILS("vital",DFN,ID)
"RTN","HMPDJ02",279,0)
 S VIT("observed")=$$JSONDT^HMPUTILS(+X0)
"RTN","HMPDJ02",280,0)
 S VIT("resulted")=$$JSONDT^HMPUTILS(+$P(X0,U,4))
"RTN","HMPDJ02",281,0)
 S TYPE=$$FIELD^GMVGETVT(+$P(X0,U,3),2)
"RTN","HMPDJ02",282,0)
 S VIT("displayName")=TYPE
"RTN","HMPDJ02",283,0)
 S VIT("typeName")=$$FIELD^GMVGETVT($P(X0,U,3),1)
"RTN","HMPDJ02",284,0)
 S VIT("typeCode")="urn:va:vuid:"_$$FIELD^GMVGETVT($P(X0,U,3),4)
"RTN","HMPDJ02",285,0)
 S X=$P(X0,U,8),VIT("result")=X
"RTN","HMPDJ02",286,0)
 S VIT("units")=$$UNIT^HMPDGMV(TYPE),(MRES,MUNT)=""
"RTN","HMPDJ02",287,0)
 I TYPE="T"  S MUNT="C",MRES=$J(X-32*5/9,0,1) ;EN1^GMRVUTL
"RTN","HMPDJ02",288,0)
 I TYPE="HT" S MUNT="cm",MRES=$J(2.54*X,0,2)  ;EN2^GMRVUTL
"RTN","HMPDJ02",289,0)
 I TYPE="WT" S MUNT="kg",MRES=$J(X/2.2,0,2)   ;EN3^GMRVUTL
"RTN","HMPDJ02",290,0)
 I TYPE="CG" S MUNT="cm",MRES=$J(2.54*X,0,2)
"RTN","HMPDJ02",291,0)
 S:MRES VIT("metricResult")=MRES,VIT("metricUnits")=MUNT
"RTN","HMPDJ02",292,0)
 S X=$$RANGE^HMPDGMV(TYPE) I $L(X) S VIT("high")=$P(X,U),VIT("low")=$P(X,U,2)
"RTN","HMPDJ02",293,0)
 S VIT("summary")=VIT("typeName")_" "_VIT("result")_" "_VIT("units")
"RTN","HMPDJ02",294,0)
 F I=1:1:$L(HMPY(5),U) S X=$P(HMPY(5),U,I) I X D
"RTN","HMPDJ02",295,0)
 . S VIT("qualifiers",I,"name")=$$FIELD^GMVGETQL(X,1)
"RTN","HMPDJ02",296,0)
 . S VIT("qualifiers",I,"vuid")=$$FIELD^GMVGETQL(X,3)
"RTN","HMPDJ02",297,0)
 ;US4338 - add pulse ox qualifier if it exists. name component is required. vuid is not per Thomas Loth
"RTN","HMPDJ02",298,0)
 I $P(X0,U,10) S VIT("qualifiers",I+1,"name")=$P(X0,U,10)
"RTN","HMPDJ02",299,0)
 I $G(HMPY(2)) S VIT("removed")="true"        ;entered in error
"RTN","HMPDJ02",300,0)
 S LOC=+$P(X0,U,5),FAC=$$FAC^HMPD(LOC)
"RTN","HMPDJ02",301,0)
 S VIT("locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ02",302,0)
 S VIT("locationName")=$S(LOC:$$GET1^DIQ(44,LOC_",",.01),1:"unknown")  ;DE2818, ICR 10040
"RTN","HMPDJ02",303,0)
 N USERID S USERID=$P(HMPY(0),U,6)
"RTN","HMPDJ02",304,0)
 I $G(USERID) D
"RTN","HMPDJ02",305,0)
 . S VIT("enteredByUid")=$$SETUID^HMPUTILS("user",,USERID)
"RTN","HMPDJ02",306,0)
 . S VIT("enteredByName")=$$GET1^DIQ(200,USERID_",",.01)  ;DE2818, ICR 10060
"RTN","HMPDJ02",307,0)
 D FACILITY^HMPUTILS(FAC,"VIT")
"RTN","HMPDJ02",308,0)
 S VIT("lastUpdateTime")=$$EN^HMPSTMP("vital")
"RTN","HMPDJ02",309,0)
 S VIT("stampTime")=VIT("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ02",310,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ02",311,0)
 I $G(HMPMETA) D ADD^HMPMETA("vital",VIT("uid"),VIT("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ02",312,0)
 D ADD^HMPDJ("VIT","vital")
"RTN","HMPDJ02",313,0)
 Q
"RTN","HMPDJ02",314,0)
 ;
"RTN","HMPDJ02",315,0)
HMP(COLL) ; -- HMP Patient Objects
"RTN","HMPDJ02",316,0)
 N ID I $L($G(HMPID)) D  Q
"RTN","HMPDJ02",317,0)
 . S ID=+HMPID I 'ID S ID=+$O(^HMP(800000.1,"B",HMPID,0)) ;IEN or UID
"RTN","HMPDJ02",318,0)
 . D:ID HMP1(800000.1,ID)
"RTN","HMPDJ02",319,0)
 Q:$G(COLL)=""  ;error
"RTN","HMPDJ02",320,0)
 S ID=0 F  S ID=$O(^HMP(800000.1,"C",DFN,COLL,ID)) Q:ID<1  D HMP1(800000.1,ID)
"RTN","HMPDJ02",321,0)
 Q
"RTN","HMPDJ02",322,0)
HMP1(FNUM,ID) ; -- [patient] object
"RTN","HMPDJ02",323,0)
 N I,X,HMPY
"RTN","HMPDJ02",324,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ02",325,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=$G(DFN)
"RTN","HMPDJ02",326,0)
 S ERRMSG="A problem occurred retreiving record "_ID_" for the HMP domain"
"RTN","HMPDJ02",327,0)
 S I=0 F  S I=$O(^HMP(FNUM,ID,1,I)) Q:I<1  S X=$G(^(I,0)),HMPY(I)=X
"RTN","HMPDJ02",328,0)
 I $D(HMPY) D  ;already encoded JSON
"RTN","HMPDJ02",329,0)
 . S HMPI=HMPI+1 S:HMPI>1 @HMP@(HMPI,.3)=","
"RTN","HMPDJ02",330,0)
 . M @HMP@(HMPI)=HMPY
"RTN","HMPDJ02",331,0)
 . ; -- chunk data if from DQINIT^HMPDJFSP ; i.e. HMPCHNK defined ;*S68-JCH*
"RTN","HMPDJ02",332,0)
 . D CHNKCHK^HMPDJFSP(.HMP,.HMPI) ;*S68-JCH*
"RTN","HMPDJ02",333,0)
 Q
"RTN","HMPDJ03")
0^22^B113601878^B97739485
"RTN","HMPDJ03",1,0)
HMPDJ03 ;SLC/MKB,ASMR/RRB,JD - Consults,ClinProcedures,CLiO;May 15, 2016 14:15
"RTN","HMPDJ03",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJ03",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ03",4,0)
 ;
"RTN","HMPDJ03",5,0)
 ; DE4173 - JD - 3/30/16: Send consult notes for "activities" and "results".
"RTN","HMPDJ03",6,0)
 ;
"RTN","HMPDJ03",7,0)
 ; External References          DBIA#
"RTN","HMPDJ03",8,0)
 ; -------------------          -----
"RTN","HMPDJ03",9,0)
 ; ^SC(                         10040
"RTN","HMPDJ03",10,0)
 ; ^TIU(8925.1                   5677
"RTN","HMPDJ03",11,0)
 ; ^VA(200                      10060
"RTN","HMPDJ03",12,0)
 ; %DT                          10003
"RTN","HMPDJ03",13,0)
 ; DILFD                         2055
"RTN","HMPDJ03",14,0)
 ; DIQ                           2056
"RTN","HMPDJ03",15,0)
 ; GMRCAPI                       6082
"RTN","HMPDJ03",16,0)
 ; GMRCGUIB                      2980
"RTN","HMPDJ03",17,0)
 ; GMRCSLM1,^TMP("GMRCR"         2740
"RTN","HMPDJ03",18,0)
 ; MCARUTL3                      3280
"RTN","HMPDJ03",19,0)
 ; MDPS1,^TMP("MDHSP"            4230
"RTN","HMPDJ03",20,0)
 ; ORX8                          2467
"RTN","HMPDJ03",21,0)
 ; TIULQ                         2693
"RTN","HMPDJ03",22,0)
 ; TIUSRVLO                      2834
"RTN","HMPDJ03",23,0)
 ; XLFSTR                       10104
"RTN","HMPDJ03",24,0)
 ; XUAF4                         2171
"RTN","HMPDJ03",25,0)
 ;
"RTN","HMPDJ03",26,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ03",27,0)
 Q
"RTN","HMPDJ03",28,0)
 ;
"RTN","HMPDJ03",29,0)
GMRC1(ID) ; -- consult/request HMPX=^TMP("GMRCR",$J,"CS",HMPN,0)
"RTN","HMPDJ03",30,0)
 N CONS,ORDER,HMPD,X0,X,HMPA,DA,ACT0,ACT2,ACT3,ACT,HMPEASON,HMPJ,HMPTIU
"RTN","HMPDJ03",31,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ03",32,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ03",33,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the consults domain"
"RTN","HMPDJ03",34,0)
 ;
"RTN","HMPDJ03",35,0)
 S CONS("localId")=+HMPX,CONS("uid")=$$SETUID^HMPUTILS("consult",DFN,+HMPX)
"RTN","HMPDJ03",36,0)
 S CONS("dateTime")=$$JSONDT^HMPUTILS($P(HMPX,U,2))
"RTN","HMPDJ03",37,0)
 S CONS("statusName")=$P(HMPX,U,3),CONS("service")=$P(HMPX,U,4)
"RTN","HMPDJ03",38,0)
 S CONS("consultProcedure")=$P(HMPX,U,5)
"RTN","HMPDJ03",39,0)
 I $P(HMPX,U,6)="*" S CONS("interpretation")="SIGNIFICANT FINDINGS"
"RTN","HMPDJ03",40,0)
 S CONS("typeName")=$P(HMPX,U,7),CONS("category")=$P(HMPX,U,9)
"RTN","HMPDJ03",41,0)
 S ORDER=+$P(HMPX,U,8),CONS("orderName")=$P($$OI^ORX8(ORDER),U,2)
"RTN","HMPDJ03",42,0)
 S CONS("orderUid")=$$SETUID^HMPUTILS("order",DFN,ORDER)
"RTN","HMPDJ03",43,0)
 D GET^GMRCAPI(.HMPD,+HMPX) S X0=$G(HMPD(0)) ;=^GMR(123,ID,0)
"RTN","HMPDJ03",44,0)
 S X=$P(X0,U,6) S:X CONS("fromService")=$$GET1^DIQ(44,X_",",.01)  ;DE2818
"RTN","HMPDJ03",45,0)
 S X=$P(X0,U,9) S:X]"" CONS("urgency")=X
"RTN","HMPDJ03",46,0)
 S X=$P(X0,U,10) S:X]"" CONS("place")=X
"RTN","HMPDJ03",47,0)
 S X=$P(X0,U,11) S:X CONS("attention")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",48,0)
 S X=$P(X0,U,13) S:X]"" CONS("lastAction")=X
"RTN","HMPDJ03",49,0)
 S X=$P(X0,U,14) I X D  ;ordering provider
"RTN","HMPDJ03",50,0)
 . S CONS("providerUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ03",51,0)
 . S CONS("providerName")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",52,0)
 S X=$P(X0,U,18) I $L(X) D
"RTN","HMPDJ03",53,0)
 . S CONS("patientClassCode")="urn:va:patient-class:"_$S(X="I":"IMP",1:"AMB")
"RTN","HMPDJ03",54,0)
 . S CONS("patientClassName")=$S(X="I":"Inpatient",1:"Ambulatory")
"RTN","HMPDJ03",55,0)
 S X=+$P(X0,U,24) S:X CONS("earliestDate")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",56,0)
 I $P(HMPX,U,9)="M" S CONS("clinicalProcedure")=$G(HMPD(1))
"RTN","HMPDJ03",57,0)
 I $D(HMPD(20)) M HMPEASON=HMPD(20) S CONS("reason")=$$STRING^HMPD(.HMPEASON)
"RTN","HMPDJ03",58,0)
 S X=$G(HMPD(30)) S:$L(X) CONS("provisionalDx")=X
"RTN","HMPDJ03",59,0)
 ; 
"RTN","HMPDJ03",60,0)
 I $P(X0,U,23) D  ;inter-facility
"RTN","HMPDJ03",61,0)
 . N IFC S X=$$NS^XUAF4($P(X0,U,23))
"RTN","HMPDJ03",62,0)
 . S CONS("remote","facilityCode")=$P(X,U,2),CONS("remote","facilityName")=$P(X,U)
"RTN","HMPDJ03",63,0)
 . S:$P(X0,U,22) CONS("remote","id")=$P(X0,U,22)
"RTN","HMPDJ03",64,0)
 . S IFC=$$IFC^GMRCAPI(ID)
"RTN","HMPDJ03",65,0)
 . S X=$P(IFC,U) S:$L(X) CONS("remote","service")=X
"RTN","HMPDJ03",66,0)
 . S X=$P(IFC,U,5) S:$L(X) CONS("remote","role")=$S(X="P":"Requesting facility",1:"Consulting facility")
"RTN","HMPDJ03",67,0)
 . S CONS("remote","providerName")=$P(IFC,U,6)
"RTN","HMPDJ03",68,0)
 . S X=$P(IFC,U,2) S:$L(X) CONS("remote","providerphone")=X
"RTN","HMPDJ03",69,0)
 . S X=$P(IFC,U,3) S:$L(X) CONS("remote","providerpager")=X
"RTN","HMPDJ03",70,0)
 ;
"RTN","HMPDJ03",71,0)
 D ACT^GMRCAPI(.HMPA,ID)
"RTN","HMPDJ03",72,0)
 S DA=0 F  S DA=$O(HMPA(DA)) Q:DA<1  D
"RTN","HMPDJ03",73,0)
 . S ACT0=$G(HMPA(DA,0)),ACT2=$G(HMPA(DA,2)),ACT3=$G(HMPA(DA,3)) K ACT
"RTN","HMPDJ03",74,0)
 . I $L(ACT2),$P(X0,U,23) S X=$$NS^XUAF4($P(X0,U,23)),ACT("facilityCode")=$P(X,U,2),ACT("facilityName")=$P(X,U)
"RTN","HMPDJ03",75,0)
 . S ACT("name")=$P(ACT0,U,2)
"RTN","HMPDJ03",76,0)
 . S ACT("entered")=$$JSONDT^HMPUTILS($P(ACT0,U))
"RTN","HMPDJ03",77,0)
 . S ACT("dateTime")=$$JSONDT^HMPUTILS($P(ACT0,U,3))
"RTN","HMPDJ03",78,0)
 . S:$L($P(ACT2,U,3)) ACT("timeZone")=$P(ACT2,U,3)
"RTN","HMPDJ03",79,0)
 . I $L(ACT2) S ACT("enteredBy")=$P(ACT2,U),ACT("responsible")=$P(ACT2,U,2)
"RTN","HMPDJ03",80,0)
 . E  D  ;remote vs. local users
"RTN","HMPDJ03",81,0)
 .. S X=+$P(ACT0,U,4) S:X ACT("responsible")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",82,0)
 .. S X=+$P(ACT0,U,5) S:X ACT("enteredBy")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",83,0)
 . S X=$S($L(ACT3):ACT3,1:$P(ACT0,U,6)) S:$L(X) ACT("forwardedFrom")=X
"RTN","HMPDJ03",84,0)
 . S X=$P(ACT0,U,7) S:X ACT("previousAttention")=$$GET1^DIQ(200,X_",",.01)  ;DE2818
"RTN","HMPDJ03",85,0)
 . S X=$P(ACT0,U,8) S:X ACT("device")=$$GET1^DIQ(3.5,X_",",.01)
"RTN","HMPDJ03",86,0)
 . S X=$P(ACT0,U,9) I X,X["TIU" D
"RTN","HMPDJ03",87,0)
 .. S ACT("resultUid")=$$SETUID^HMPUTILS("document",DFN,+X)
"RTN","HMPDJ03",88,0)
 .. ;=== Start DE4173 for "activity" attribute
"RTN","HMPDJ03",89,0)
 .. N HMP92,HMPNI
"RTN","HMPDJ03",90,0)
 .. S HMPNI=$P($P(ACT0,U,9),";")  ;Note (document) IEN --> ^TIU(8925,HMPNI
"RTN","HMPDJ03",91,0)
 .. I HMPNI'>0 Q
"RTN","HMPDJ03",92,0)
 .. D SETTEXT^HMPUTILS($NA(^TIU(8925,HMPNI,"TEXT")),"HMP92")  ;Format a word processing field
"RTN","HMPDJ03",93,0)
 .. M ACT("note","\")=HMP92
"RTN","HMPDJ03",94,0)
 .. ;=== End DE4173 for "activity" attribute
"RTN","HMPDJ03",95,0)
 . I $D(HMPA(DA,1)) M HMPEASON=HMPA(DA,1) S ACT("comment")=$$STRING^HMPD(.HMPEASON)
"RTN","HMPDJ03",96,0)
 . M CONS("activity",DA)=ACT
"RTN","HMPDJ03",97,0)
 ;
"RTN","HMPDJ03",98,0)
 S HMPJ=0 F  S HMPJ=$O(HMPD(50,HMPJ)) Q:HMPJ<1  S X=$G(HMPD(50,HMPJ)) D
"RTN","HMPDJ03",99,0)
 . Q:'$D(@(U_$P(X,";",2)_+X_")"))  ;text deleted
"RTN","HMPDJ03",100,0)
 . ;=== Start DE4173 for "results" attribute
"RTN","HMPDJ03",101,0)
 . N HMP92,HMPNI
"RTN","HMPDJ03",102,0)
 . S HMPNI=$P(X,";")  ;Note (document) IEN --> ^TIU(8925,HMPNI
"RTN","HMPDJ03",103,0)
 . I HMPNI>0 D
"RTN","HMPDJ03",104,0)
 .. D SETTEXT^HMPUTILS($NA(^TIU(8925,HMPNI,"TEXT")),"HMP92")  ;Format a word processing field
"RTN","HMPDJ03",105,0)
 .. M CONS("results",HMPJ,"note","\")=HMP92
"RTN","HMPDJ03",106,0)
 . ;=== End DE4173 for "results" attribute
"RTN","HMPDJ03",107,0)
 . S CONS("results",HMPJ,"uid")=$$SETUID^HMPUTILS("document",DFN,+X)
"RTN","HMPDJ03",108,0)
 . D EXTRACT^TIULQ(+X,"HMPTIU",,.01)
"RTN","HMPDJ03",109,0)
 . S CONS("results",HMPJ,"localTitle")=$G(HMPTIU(+X,.01,"E"))
"RTN","HMPDJ03",110,0)
 S X=$P(X0,U,21),X=$S(X:$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U),1:$$FAC^HMPD)
"RTN","HMPDJ03",111,0)
 D FACILITY^HMPUTILS(X,"CONS")
"RTN","HMPDJ03",112,0)
 S CONS("lastUpdateTime")=$$EN^HMPSTMP("consult")
"RTN","HMPDJ03",113,0)
 S CONS("stampTime")=CONS("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ03",114,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ03",115,0)
 I $G(HMPMETA) D ADD^HMPMETA("consult",CONS("uid"),CONS("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ03",116,0)
 D ADD^HMPDJ("CONS","consult")
"RTN","HMPDJ03",117,0)
 Q
"RTN","HMPDJ03",118,0)
 ;
"RTN","HMPDJ03",119,0)
MDPS1(DFN,BEG,END,MAX) ; -- perform CP search (scope variables)
"RTN","HMPDJ03",120,0)
 N MCARCODE,MCARDT,MCARPROC,MCESKEY,MCESSEC,MCFILE,MDC,MDIMG,RES
"RTN","HMPDJ03",121,0)
 S BEG=$G(BEG,1410101),END=$G(END,4141015),MAX=$G(MAX,9999)
"RTN","HMPDJ03",122,0)
 K ^TMP("MDHSP",$J) S RES=""
"RTN","HMPDJ03",123,0)
 D EN1^MDPS1(.RES,DFN,BEG,END,MAX,"",0) ;RES=^TMP("MDHSP",$J)
"RTN","HMPDJ03",124,0)
 Q
"RTN","HMPDJ03",125,0)
 ;
"RTN","HMPDJ03",126,0)
MC1(ID) ; -- clinical procedure HMPX=^TMP("MDHSP",$J,HMPN)
"RTN","HMPDJ03",127,0)
 N X,Y,%DT,DATE,RTN,GBL,CONS,TIUN,HMPD,X0,PROC,HMPT,LOC,FAC
"RTN","HMPDJ03",128,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ03",129,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ03",130,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the clinical procedure domain"
"RTN","HMPDJ03",131,0)
 ;
"RTN","HMPDJ03",132,0)
 S RTN=$P(HMPX,U,3,4) Q:RTN="PRPRO^MDPS4"  ;skip non-CP items
"RTN","HMPDJ03",133,0)
 S X=$P(HMPX,U,6),%DT="TXS" D ^%DT Q:Y'>0  S DATE=Y
"RTN","HMPDJ03",134,0)
 S GBL=+$P(HMPX,U,2)_";"_$S(RTN="PR702^MDPS1":"MDD(702,",1:$$ROOT^HMPDMC(DFN,$P(HMPX,U,11),DATE))
"RTN","HMPDJ03",135,0)
 Q:'GBL  I $G(ID),ID'=GBL Q                ;unknown, or not requested
"RTN","HMPDJ03",136,0)
 ;
"RTN","HMPDJ03",137,0)
 S CONS=+$P(HMPX,U,13) D:CONS DOCLIST^GMRCGUIB(.HMPD,CONS) S X0=$G(HMPD(0)) ;=^GMR(123,ID,0)
"RTN","HMPDJ03",138,0)
 S TIUN=+$P(HMPX,U,14) S:TIUN TIUN=TIUN_U_$$RESOLVE^TIUSRVLO(TIUN)
"RTN","HMPDJ03",139,0)
 S PROC("localId")=GBL,PROC("category")="CP"
"RTN","HMPDJ03",140,0)
 S PROC("uid")=$$SETUID^HMPUTILS("procedure",DFN,GBL)
"RTN","HMPDJ03",141,0)
 S PROC("name")=$P(HMPX,U),PROC("dateTime")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ03",142,0)
 S X=$P(HMPX,U,7) S:$L(X) PROC("interpretation")=X
"RTN","HMPDJ03",143,0)
 S PROC("kind")="Procedure"
"RTN","HMPDJ03",144,0)
 I CONS,X0 D
"RTN","HMPDJ03",145,0)
 . N HMPJ S PROC("requested")=$$JSONDT^HMPUTILS(+X0)
"RTN","HMPDJ03",146,0)
 . S PROC("consultUid")=$$SETUID^HMPUTILS("consult",DFN,CONS)
"RTN","HMPDJ03",147,0)
 . S PROC("orderUid")=$$SETUID^HMPUTILS("order",DFN,+$P(X0,U,3))
"RTN","HMPDJ03",148,0)
 . S PROC("statusName")=$$EXTERNAL^DILFD(123,8,,$P(X0,U,12))
"RTN","HMPDJ03",149,0)
 . S HMPJ=0 F  S HMPJ=$O(HMPD(50,HMPJ)) Q:HMPJ<1  S X=+$G(HMPD(50,HMPJ)) D
"RTN","HMPDJ03",150,0)
 .. D NOTE(X)
"RTN","HMPDJ03",151,0)
 .. S:'TIUN TIUN=X_U_$$RESOLVE^TIUSRVLO(X)
"RTN","HMPDJ03",152,0)
 I TIUN D
"RTN","HMPDJ03",153,0)
 . S X=$P(TIUN,U,5) I X D
"RTN","HMPDJ03",154,0)
 .. S PROC("providers",1,"providerUid")=$$SETUID^HMPUTILS("user",,+X)
"RTN","HMPDJ03",155,0)
 .. S PROC("providers",1,"providerName")=$P(X,";",3)
"RTN","HMPDJ03",156,0)
 . S:$P(TIUN,U,11) PROC("hasImages")="true"
"RTN","HMPDJ03",157,0)
 . K HMPT D EXTRACT^TIULQ(+TIUN,"HMPT",,".03;.05;1211",,,"I")
"RTN","HMPDJ03",158,0)
 . S X=+$G(HMPT(+TIUN,.03,"I")),PROC("encounterUid")=$$SETUID^HMPUTILS("visit",DFN,X)
"RTN","HMPDJ03",159,0)
 . S LOC=+$G(HMPT(+TIUN,1211,"I")) I LOC S LOC=LOC_U_$$GET1^DIQ(44,LOC_",",.01)  ;DE2818
"RTN","HMPDJ03",160,0)
 . E  S X=$P(TIUN,U,6) S:$L(X) LOC=+$O(^SC("B",X,0))_U_X  ; DE2818, ICR 10040
"RTN","HMPDJ03",161,0)
 . S:LOC PROC("locationUid")=$$SETUID^HMPUTILS("location",,+LOC),PROC("locationName")=$P(LOC,U,2),FAC=$$FAC^HMPD(+LOC)
"RTN","HMPDJ03",162,0)
 . I '$D(PROC("statusName")) S X=+$G(HMPT(+TIUN,.05,"I")),PROC("statusName")=$S(X<6:"PARTIAL RESULTS",1:"COMPLETE")
"RTN","HMPDJ03",163,0)
 . I '$G(PROC("results",+TIUN)) D NOTE(+TIUN)
"RTN","HMPDJ03",164,0)
 ; if no consult or note/visit ...
"RTN","HMPDJ03",165,0)
 I 'CONS,'TIUN,RTN'="PR702^MDPS1" S PROC("results",1,"uid")=$$SETUID^HMPUTILS("document",DFN,GBL) ;DE1977 add link to report document
"RTN","HMPDJ03",166,0)
 S:'$D(PROC("statusName")) PROC("statusName")="COMPLETE"
"RTN","HMPDJ03",167,0)
 I '$D(FAC) S X=$P(X0,U,21),FAC=$S(X:$$STA^XUAF4(X)_U_$P($$NS^XUAF4(X),U),1:$$FAC^HMPD)
"RTN","HMPDJ03",168,0)
 D FACILITY^HMPUTILS(FAC,"PROC")
"RTN","HMPDJ03",169,0)
 S PROC("lastUpdateTime")=$$EN^HMPSTMP("procedure")
"RTN","HMPDJ03",170,0)
 S PROC("stampTime")=PROC("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ03",171,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ03",172,0)
 I $G(HMPMETA) D ADD^HMPMETA("procedure",PROC("uid"),PROC("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ03",173,0)
 D ADD^HMPDJ("PROC","procedure")
"RTN","HMPDJ03",174,0)
 Q
"RTN","HMPDJ03",175,0)
 ;
"RTN","HMPDJ03",176,0)
NOTE(DA) ; -- add TIU note info
"RTN","HMPDJ03",177,0)
 N HMPT,TEXT
"RTN","HMPDJ03",178,0)
 D EXTRACT^TIULQ(DA,"HMPT",,.01)
"RTN","HMPDJ03",179,0)
 S PROC("results",DA,"uid")=$$SETUID^HMPUTILS("document",+$G(DFN),DA)
"RTN","HMPDJ03",180,0)
 S PROC("results",DA,"localTitle")=$G(HMPT(DA,.01,"E"))
"RTN","HMPDJ03",181,0)
 Q
"RTN","HMPDJ03",182,0)
 ;
"RTN","HMPDJ03",183,0)
MDC1(ID) ; -- clinical observation
"RTN","HMPDJ03",184,0)
 N GUID,CLIO,HMPC,HMPT,LOC,FAC,I,X,Y
"RTN","HMPDJ03",185,0)
 S GUID=$G(ID) Q:GUID=""  ;invalid GUID
"RTN","HMPDJ03",186,0)
 D QRYOBS^HMPDMDC("HMPC",GUID) Q:'$D(HMPC)  ;doesn't exist
"RTN","HMPDJ03",187,0)
 Q:$L($G(HMPC("PARENT_ID","E")))            ;PARENT also in list
"RTN","HMPDJ03",188,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ03",189,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ03",190,0)
 S ERRMSG="A problem occurred converting record "_ID_" for the clinical observation domain"
"RTN","HMPDJ03",191,0)
 ;
"RTN","HMPDJ03",192,0)
 S CLIO("localId")=GUID,CLIO("uid")=$$SETUID^HMPUTILS("obs",DFN,GUID)
"RTN","HMPDJ03",193,0)
 S X=$G(HMPC("TERM_ID","I")) S:X CLIO("typeVuid")="urn:va:vuid:"_X
"RTN","HMPDJ03",194,0)
 S CLIO("typeCode")="urn:va:clioterminology:"_$G(HMPC("TERM_ID","GUID"))
"RTN","HMPDJ03",195,0)
 S CLIO("typeName")=$G(HMPC("TERM_ID","E"))
"RTN","HMPDJ03",196,0)
 S CLIO("result")=$G(HMPC("SVALUE","E"))
"RTN","HMPDJ03",197,0)
 S X=$G(HMPC("UNIT_ID","ABBV")) S:$L(X) CLIO("units")=X
"RTN","HMPDJ03",198,0)
 S X=$G(HMPC("ENTERED_DATE_TIME","I")),CLIO("entered")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",199,0)
 S X=$G(HMPC("OBSERVED_DATE_TIME","I")),CLIO("observed")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",200,0)
 D QRYTYPES^HMPDMDC("HMPT")
"RTN","HMPDJ03",201,0)
 F I=3,5 S X=$G(HMPT(I,"XML")) I $L($G(HMPC(X,"E"))) D
"RTN","HMPDJ03",202,0)
 . S Y=HMPT(I,"NAME"),Y=$S(Y="LOCATION":"bodySite",1:$$LOW^XLFSTR(Y))
"RTN","HMPDJ03",203,0)
 . S CLIO(Y_"Code")=HMPC(X,"I"),CLIO(Y_"Name")=HMPC(X,"E")
"RTN","HMPDJ03",204,0)
 F I=4,6,7 S X=$G(HMPT(I,"XML")) I $L($G(HMPC(X,"E"))) D
"RTN","HMPDJ03",205,0)
 . S CLIO("qualifiers",I,"type")=$$LOW^XLFSTR(HMPT(I,"NAME"))
"RTN","HMPDJ03",206,0)
 . S CLIO("qualifiers",I,"code")=HMPC(X,"I")
"RTN","HMPDJ03",207,0)
 . S CLIO("qualifiers",I,"name")=HMPC(X,"E")
"RTN","HMPDJ03",208,0)
 S X=$G(HMPC("RANGE","E")) I $L(X) D
"RTN","HMPDJ03",209,0)
 . S Y=$S(X="Out of Bounds Low":"<",X="Out of Bounds High":">",1:$E(X))
"RTN","HMPDJ03",210,0)
 . S CLIO("interpretationCode")="urn:hl7:observation-interpretation:"_Y
"RTN","HMPDJ03",211,0)
 . S CLIO("interpretationName")=$S(X="<":"Low off scale",X=">":"High off scale",1:X)
"RTN","HMPDJ03",212,0)
 ; X=$G(HMPC("STATUS","E")) S:$L(X) CLIO("resultStatus")=$S(X="unverified":"active",1:"complete")
"RTN","HMPDJ03",213,0)
 I $D(HMPC("SUPP_PAGE")) D  ;add set info
"RTN","HMPDJ03",214,0)
 . S CLIO("setID")=$G(HMPC("SUPP_PAGE","GUID"))
"RTN","HMPDJ03",215,0)
 . S CLIO("setName")=$G(HMPC("SUPP_PAGE","DISPLAY_NAME"))
"RTN","HMPDJ03",216,0)
 . S X=$G(HMPC("SUPP_PAGE","TYPE")) S:$L(X) CLIO("setType")=X
"RTN","HMPDJ03",217,0)
 . S X=$G(HMPC("SUPP_PAGE","ACTIVATED_DATE_TIME")) S:X CLIO("setStart")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",218,0)
 . S X=$G(HMPC("SUPP_PAGE","DEACTIVATED_DATE_TIME")) S:X CLIO("setStop")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ03",219,0)
 S CLIO("statusCode")="urn:va:observation-status:complete",CLIO("statusName")="complete"
"RTN","HMPDJ03",220,0)
 S LOC=$G(HMPC("HOSPITAL_LOCATION_ID","I")),FAC=$$FAC^HMPD(LOC)
"RTN","HMPDJ03",221,0)
 S CLIO("locationUid")=$$SETUID^HMPUTILS("location",,LOC)
"RTN","HMPDJ03",222,0)
 S CLIO("locationName")=$G(HMPC("HOSPITAL_LOCATION_ID","E"))
"RTN","HMPDJ03",223,0)
 D FACILITY^HMPUTILS(FAC,"CLIO")
"RTN","HMPDJ03",224,0)
 S X=$G(HMPC("COMMENT","E")) S:$L(X) CLIO("comment")=X
"RTN","HMPDJ03",225,0)
 S CLIO("lastUpdateTime")=$$EN^HMPSTMP("obs") ; RHL 20141231
"RTN","HMPDJ03",226,0)
 S CLIO("stampTime")=CLIO("lastUpdateTime") ; RHL 20141231
"RTN","HMPDJ03",227,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ03",228,0)
 I $G(HMPMETA) D ADD^HMPMETA("obs",CLIO("uid"),CLIO("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ03",229,0)
 D ADD^HMPDJ("CLIO","obs")
"RTN","HMPDJ03",230,0)
 Q
"RTN","HMPDJ08")
0^30^B76812256^B73570854
"RTN","HMPDJ08",1,0)
HMPDJ08 ;SLC/MKB,ASMR/RRB,HM - TIU Documents;May 15, 2016 14:15
"RTN","HMPDJ08",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJ08",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ08",4,0)
 ;
"RTN","HMPDJ08",5,0)
 ;11/19/14 - Fix missing MCAR documents tag EN1+4, EN1+13  js
"RTN","HMPDJ08",6,0)
 ;
"RTN","HMPDJ08",7,0)
 ; External References          DBIA#
"RTN","HMPDJ08",8,0)
 ; -------------------          -----
"RTN","HMPDJ08",9,0)
 ; ^SC                          10040
"RTN","HMPDJ08",10,0)
 ; ^TIU(8925.1              2321,5677
"RTN","HMPDJ08",11,0)
 ; ^TIU(8926.1                   5678
"RTN","HMPDJ08",12,0)
 ; ^VA(200                      10060
"RTN","HMPDJ08",13,0)
 ; DIQ                           2056
"RTN","HMPDJ08",14,0)
 ; RAO7PC1                       2043
"RTN","HMPDJ08",15,0)
 ; TIUCNSLT                      5546
"RTN","HMPDJ08",16,0)
 ; TIUCP                         3568
"RTN","HMPDJ08",17,0)
 ; TIULQ                         2693
"RTN","HMPDJ08",18,0)
 ; TIULX                         3058
"RTN","HMPDJ08",19,0)
 ; TIUSROI                       5676
"RTN","HMPDJ08",20,0)
 ; TIUSRVLO                 2834,2865
"RTN","HMPDJ08",21,0)
 ; XLFSTR                       10104
"RTN","HMPDJ08",22,0)
 ;
"RTN","HMPDJ08",23,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ08",24,0)
 Q
"RTN","HMPDJ08",25,0)
 ;
"RTN","HMPDJ08",26,0)
TIU1(ID) ; -- document
"RTN","HMPDJ08",27,0)
 I ID[";" D   Q
"RTN","HMPDJ08",28,0)
 . I ID D EN1($$CP1^HMPDJ08A(DFN,ID),"CP") Q  ;CP
"RTN","HMPDJ08",29,0)
 . D EN1($$LR1^HMPDJ08A(DFN,ID),"LR") Q       ;Lab
"RTN","HMPDJ08",30,0)
 I ID["-" D  Q                                ;Radiology
"RTN","HMPDJ08",31,0)
 . S (BEG,END)=9999999.9999-+ID D EN1^RAO7PC1(DFN,BEG,END,"99P")
"RTN","HMPDJ08",32,0)
 . Q:'$D(^TMP($J,"RAE1",DFN,ID))              ;deleted
"RTN","HMPDJ08",33,0)
 . D EN1($$RA1^HMPDJ08A(DFN,ID),"RA") K ^TMP($J,"RAE1")
"RTN","HMPDJ08",34,0)
 D EN1(ID,38)
"RTN","HMPDJ08",35,0)
 Q
"RTN","HMPDJ08",36,0)
 ;
"RTN","HMPDJ08",37,0)
EN1(HMPX,TIU,OUTPUT) ; -- document
"RTN","HMPDJ08",38,0)
 ;  Expects DFN, HMPX=IEN^$$RESOLVE^TIUSRVLO(IEN) or equivalent
"RTN","HMPDJ08",39,0)
 ;          TIU = document class#, or code (CP, RA, LR) if non-TIU
"RTN","HMPDJ08",40,0)
 ;          OUTPUT = store the result in the output array instead (by reference)
"RTN","HMPDJ08",41,0)
 N DOC,IEN,X,HMPTIU,NT,ES,I,TEXT,SUB,HMPY,ERR
"RTN","HMPDJ08",42,0)
 ; --- CP HMPX records with $p1 not the file ien  --- 
"RTN","HMPDJ08",43,0)
 S IEN=$P($G(HMPX),U),TIU=$G(TIU) I TIU="CP" I IEN="" D  Q:IEN=""  ;invalid ien
"RTN","HMPDJ08",44,0)
 . S HMPIEN=+$P(HMPX,$J_",""",2)
"RTN","HMPDJ08",45,0)
 . I +HMPIEN>0 S IEN=+HMPIEN
"RTN","HMPDJ08",46,0)
 . Q
"RTN","HMPDJ08",47,0)
 ; ---
"RTN","HMPDJ08",48,0)
 I +HMPX=HMPX,TIU D  ;get TIU data string, if needed
"RTN","HMPDJ08",49,0)
 . N SHOWADD,DA S SHOWADD=1,DA=+HMPX
"RTN","HMPDJ08",50,0)
 . S HMPX=DA_U_$$RESOLVE^TIUSRVLO(DA)
"RTN","HMPDJ08",51,0)
 ; --- CP HMPX records with $p1 not the file ien  ---
"RTN","HMPDJ08",52,0)
 I +HMPX="" I TIU="CP" D  ;get TIU data string, if needed
"RTN","HMPDJ08",53,0)
 . N SHOWADD,DA S SHOWADD=1,DA=+IEN
"RTN","HMPDJ08",54,0)
 . S HMPX=DA_U_$$RESOLVE^TIUSRVLO(DA)
"RTN","HMPDJ08",55,0)
 ; ---
"RTN","HMPDJ08",56,0)
 Q:"UNKNOWN"[$P($G(HMPX),U,2)  ;null or invalid
"RTN","HMPDJ08",57,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ08",58,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ08",59,0)
 S ERRMSG="A problem occurred converting record "_IEN_" for the document domain"
"RTN","HMPDJ08",60,0)
 S DOC("localId")=IEN,DOC("uid")=$$SETUID^HMPUTILS("document",DFN,IEN)
"RTN","HMPDJ08",61,0)
 S DOC("localTitle")=$P(HMPX,U,2)
"RTN","HMPDJ08",62,0)
 S DOC("referenceDateTime")=$$JSONDT^HMPUTILS($P(HMPX,U,3))
"RTN","HMPDJ08",63,0)
 S X=$P(HMPX,U,6) D  ;S:$L(X) DOC("location")=X
"RTN","HMPDJ08",64,0)
 . N LOC,FAC S LOC=$S($L(X):+$O(^SC("B",X,0)),1:0) ;ICR 10040 DE2818 ASF 11/10/15
"RTN","HMPDJ08",65,0)
 . S X=$$FAC^HMPD(LOC)
"RTN","HMPDJ08",66,0)
 . S DOC("facilityCode")=$P(X,U),DOC("facilityName")=$P(X,U,2)
"RTN","HMPDJ08",67,0)
 S X=$P(HMPX,U,7) I $L(X) S DOC("status")=$$UP^XLFSTR(X)
"RTN","HMPDJ08",68,0)
 S:$P(HMPX,U,11) DOC("images")=+$P(HMPX,U,11)
"RTN","HMPDJ08",69,0)
 S:$L($P(HMPX,U,12)) DOC("subject")=$P(HMPX,U,12)
"RTN","HMPDJ08",70,0)
 I $P(HMPX,U,14)>5 S DOC("parentUid")=$$SETUID^HMPUTILS("document",DFN,$P(HMPX,U,14)) ;ID notes
"RTN","HMPDJ08",71,0)
B ; other TIU data
"RTN","HMPDJ08",72,0)
 D:TIU EXTRACT^TIULQ(IEN,"HMPTIU",,,,1,,1) ;".01:.04;1501:1508")
"RTN","HMPDJ08",73,0)
 S X=$G(HMPTIU(IEN,.01,"I")) S:X DOC("documentDefUid")=$$SETUID^HMPUTILS("doc-def",,X)
"RTN","HMPDJ08",74,0)
 S NT=$S(X:+$G(^TIU(8925.1,X,15)),1:$P(HMPX,U,10)) I NT D  ;ICR 2321 DE2818 ASF 11/110/15
"RTN","HMPDJ08",75,0)
 . S DOC("nationalTitle","vuid")="urn:va:vuid:"_$$VUID^HMPD(NT,8926.1)
"RTN","HMPDJ08",76,0)
 . S DOC("nationalTitle","name")=$$GET1^DIQ(8926.1,NT_",",.01)
"RTN","HMPDJ08",77,0)
 S X=$G(HMPTIU(IEN,1201,"I")) S:X DOC("entered")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ08",78,0)
 S X=$G(HMPTIU(IEN,.09,"E")) S:$L(X) DOC("urgency")=X
"RTN","HMPDJ08",79,0)
 S X=TIU I TIU S X=+$G(HMPTIU(IEN,.01,"I")),X=$$CATG^HMPDTIU(X) ;2U type code
"RTN","HMPDJ08",80,0)
 S DOC("documentTypeCode")=X,DOC("documentTypeName")=$$TYPE(X)
"RTN","HMPDJ08",81,0)
 S DOC("documentClass")=$S(X="LR":"LR LABORATORY REPORTS",X="SR":"SURGICAL REPORTS",X="CP":"CLINICAL PROCEDURES",X="RA":"RADIOLOGY REPORTS",X="DS":"DISCHARGE SUMMARY",1:"PROGRESS NOTES")
"RTN","HMPDJ08",82,0)
 S X=$S(TIU:$G(HMPTIU(IEN,.03,"I")),1:$P(HMPX,U,8)) ;visit#
"RTN","HMPDJ08",83,0)
 S:X DOC("encounterUid")=$$SETUID^HMPUTILS("visit",DFN,X),DOC("encounterName")=$$NAME^HMPDJ04(X)
"RTN","HMPDJ08",84,0)
C ; text blocks, signatures
"RTN","HMPDJ08",85,0)
 N HMPT,HMPA,HMPADD
"RTN","HMPDJ08",86,0)
 S DOC("text",1,"dateTime")=DOC("referenceDateTime")
"RTN","HMPDJ08",87,0)
 S DOC("text",1,"status")=$G(DOC("status"))
"RTN","HMPDJ08",88,0)
 S DOC("text",1,"uid")=DOC("uid")
"RTN","HMPDJ08",89,0)
 S HMPT=1,X=$P(HMPX,U,5),I=0
"RTN","HMPDJ08",90,0)
 I X D USER(.I,+X,$P(X,";",3),"AU")    ;author
"RTN","HMPDJ08",91,0)
 M ES=HMPTIU(IEN) S X=$P(HMPX,"//",2) ;non-TIU, put into ES for use:
"RTN","HMPDJ08",92,0)
 I $L(X) S ES(1502,"I")=+X,ES(1502,"E")=$P(X,";",2),ES(1501,"I")=$P(X,";",3)
"RTN","HMPDJ08",93,0)
 I $G(ES(1501,"I")) D USER(.I,ES(1502,"I"),ES(1502,"E"),"S",ES(1501,"I"),$G(ES(1503,"E")),$G(ES(1504,"E")))
"RTN","HMPDJ08",94,0)
 I $G(ES(1507,"I")) D USER(.I,ES(1508,"I"),ES(1508,"E"),"C",ES(1507,"I"),$G(ES(1509,"E")),$G(ES(1510,"E")))
"RTN","HMPDJ08",95,0)
 I $G(ES(1204,"I")) D USER(.I,ES(1204,"I"),ES(1204,"E"),"ES")    ;expected signer
"RTN","HMPDJ08",96,0)
 I $G(ES(1208,"I")) D USER(.I,ES(1208,"I"),ES(1208,"E"),"EC")    ;expected cosigner
"RTN","HMPDJ08",97,0)
 I $G(ES(1302,"I")) D USER(.I,ES(1302,"I"),ES(1302,"E"),"E")     ;entered
"RTN","HMPDJ08",98,0)
 I $G(ES(1209,"I")) D USER(.I,ES(1209,"I"),ES(1209,"E"),"ATT")   ;attending
"RTN","HMPDJ08",99,0)
 I $G(HMPTEXT) D
"RTN","HMPDJ08",100,0)
 . S X=$S(TIU:$NA(HMPTIU(IEN,"TEXT")),1:$NA(^TMP("HMPTEXT",$J,IEN)))
"RTN","HMPDJ08",101,0)
 . K ^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",102,0)
 . D SETTEXT^HMPUTILS(X,$NA(^TMP($J,"HMP TIU TEXT")))
"RTN","HMPDJ08",103,0)
 . M DOC("text",1,"content","\")=^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",104,0)
D ; addenda
"RTN","HMPDJ08",105,0)
 S HMPA=0 F  S HMPA=$O(HMPTIU(IEN,"ZADD",HMPA)) Q:HMPA<1  D
"RTN","HMPDJ08",106,0)
 . S HMPT=HMPT+1,I=0 K HMPADD M HMPADD=HMPTIU(IEN,"ZADD",HMPA)
"RTN","HMPDJ08",107,0)
 . S DOC("text",HMPT,"status")=$G(HMPADD(.05,"E"))
"RTN","HMPDJ08",108,0)
 . S DOC("text",HMPT,"uid")=$$SETUID^HMPUTILS("document",DFN,HMPA)
"RTN","HMPDJ08",109,0)
 . S DOC("text",HMPT,"dateTime")=$$JSONDT^HMPUTILS($G(HMPADD(1301,"I")))
"RTN","HMPDJ08",110,0)
 . I $G(HMPADD(1302,"I")) D USER(.I,HMPADD(1302,"I"),HMPADD(1302,"E"),"E")
"RTN","HMPDJ08",111,0)
 . I $G(HMPADD(1202,"I")) D USER(.I,HMPADD(1202,"I"),HMPADD(1202,"E"),"AU")
"RTN","HMPDJ08",112,0)
 . I $G(HMPADD(1501,"I")) D USER(.I,HMPADD(1502,"I"),HMPADD(1502,"E"),"S",HMPADD(1501,"I"))
"RTN","HMPDJ08",113,0)
 . I $G(HMPADD(1507,"I")) D USER(.I,HMPADD(1508,"I"),HMPADD(1508,"E"),"C",HMPADD(1507,"I"))
"RTN","HMPDJ08",114,0)
 . I $G(HMPADD(1204,"I")) D USER(.I,HMPADD(1204,"I"),HMPADD(1204,"E"),"ES")
"RTN","HMPDJ08",115,0)
 . I $G(HMPADD(1208,"I")) D USER(.I,HMPADD(1208,"I"),HMPADD(1208,"E"),"EC")
"RTN","HMPDJ08",116,0)
 . I $G(HMPADD(1209,"I")) D USER(.I,HMPADD(1209,"I"),HMPADD(1209,"E"),"ATT")
"RTN","HMPDJ08",117,0)
 . Q:'$G(HMPTEXT)  K ^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",118,0)
 . D  ; DE3153, replace "not PRINT" with "not VIEW" MARCH 17, 2016 HM
"RTN","HMPDJ08",119,0)
 ..  N V,X,T,R,L S V="HMPTIU",T=" You may not PRINT",R=" You may not VIEW",L=$L(T)
"RTN","HMPDJ08",120,0)
 ..  F  S V=$Q(@V) Q:V=""  S X=@V S:$E(X,1,L)=T @V=R_$E(X,L+1,$L(X))
"RTN","HMPDJ08",121,0)
 . S X=$NA(HMPTIU(IEN,"ZADD",HMPA,"TEXT"))
"RTN","HMPDJ08",122,0)
 . D SETTEXT^HMPUTILS(X,$NA(^TMP($J,"HMP TIU TEXT")))
"RTN","HMPDJ08",123,0)
 . M DOC("text",HMPT,"content","\")=^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",124,0)
ENQ ; end
"RTN","HMPDJ08",125,0)
 K ^TMP($J,"HMP TIU TEXT")
"RTN","HMPDJ08",126,0)
 S DOC("lastUpdateTime")=$$EN^HMPSTMP("document") ;RHL 20150102
"RTN","HMPDJ08",127,0)
 S DOC("stampTime")=DOC("lastUpdateTime") ; RHL 20150102
"RTN","HMPDJ08",128,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ08",129,0)
 I '$D(OUTPUT),$G(HMPMETA) D ADD^HMPMETA("document",DOC("uid"),DOC("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ08",130,0)
 I '$D(OUTPUT) D ADD^HMPDJ("DOC","document") Q
"RTN","HMPDJ08",131,0)
 M OUTPUT=DOC
"RTN","HMPDJ08",132,0)
 Q
"RTN","HMPDJ08",133,0)
 ;
"RTN","HMPDJ08",134,0)
USER(N,IEN,NAME,ROLE,DATE,SBN,SBT) ; -- set author, signer(s)
"RTN","HMPDJ08",135,0)
 Q:'$G(IEN)  S N=+$G(N)+1
"RTN","HMPDJ08",136,0)
 S DOC("text",HMPT,"clinicians",N,"uid")=$$SETUID^HMPUTILS("user",,IEN)
"RTN","HMPDJ08",137,0)
 S DOC("text",HMPT,"clinicians",N,"name")=$S($L($G(NAME)):NAME,1:$P($G(^VA(200,IEN,0)),U)) ;ICR 10060 DE2818 ASF 11/10/15
"RTN","HMPDJ08",138,0)
 S DOC("text",HMPT,"clinicians",N,"role")=$G(ROLE)
"RTN","HMPDJ08",139,0)
 Q:'$G(DATE)  ;not co/signed
"RTN","HMPDJ08",140,0)
 S DOC("text",HMPT,"clinicians",N,"signedDateTime")=$$JSONDT^HMPUTILS(DATE)
"RTN","HMPDJ08",141,0)
 I '$D(SBN) S SBN=NAME
"RTN","HMPDJ08",142,0)
 S DOC("text",HMPT,"clinicians",N,"signature")=SBN_$S($L($G(SBT)):" "_SBT,1:"")
"RTN","HMPDJ08",143,0)
 ;$$SIG^HMPDTIU(IEN)
"RTN","HMPDJ08",144,0)
 Q
"RTN","HMPDJ08",145,0)
 ;
"RTN","HMPDJ08",146,0)
 ;
"RTN","HMPDJ08",147,0)
 ; ------------ Get/apply search criteria ------------
"RTN","HMPDJ08",148,0)
 ;               [from DOCUMENT^HMPDJ0]
"RTN","HMPDJ08",149,0)
 ;
"RTN","HMPDJ08",150,0)
SETUP ; -- convert FILTER("attribute") = value to TIU criteria
"RTN","HMPDJ08",151,0)
 ; Expects: FILTER("category") = code (see $$CATG)
"RTN","HMPDJ08",152,0)
 ;          FILTER("status")   = 'signed','unsigned','all'
"RTN","HMPDJ08",153,0)
 ; Returns: CLASS,[SUBCLASS,STATUS]
"RTN","HMPDJ08",154,0)
 ;
"RTN","HMPDJ08",155,0)
 K CLASS,SUBCLASS,STATUS
"RTN","HMPDJ08",156,0)
 N TYPE,STS,CP
"RTN","HMPDJ08",157,0)
 S TYPE=$$UP^XLFSTR($G(FILTER("category")))
"RTN","HMPDJ08",158,0)
 S CLASS=0,(SUBCLASS,STATUS)=""
"RTN","HMPDJ08",159,0)
 ;
"RTN","HMPDJ08",160,0)
 ; status [default='signed']
"RTN","HMPDJ08",161,0)
 S STS=$$LOW^XLFSTR($G(FILTER("status")))
"RTN","HMPDJ08",162,0)
 S STATUS=$S(STS?1"unsig".E:2,STS="all":"5^2",1:5)     ;TIUSRVLO statuses
"RTN","HMPDJ08",163,0)
 ;
"RTN","HMPDJ08",164,0)
 ; all documents
"RTN","HMPDJ08",165,0)
 S:TYPE="" TYPE="ALL"
"RTN","HMPDJ08",166,0)
 I TYPE="ALL" S CLASS="3^244^"_+$$CLASS^TIUSROI("SURGICAL REPORTS")_"^CP^LR^RA" Q
"RTN","HMPDJ08",167,0)
 ;
"RTN","HMPDJ08",168,0)
 I TYPE="PN"   S CLASS=3 Q                            ;Progress Notes
"RTN","HMPDJ08",169,0)
 I TYPE="CR"   S CLASS=3,SUBCLASS=$$CLASS^TIUCNSLT Q  ;Consults
"RTN","HMPDJ08",170,0)
 I TYPE="CWAD" S CLASS=3,SUBCLASS="25^27^30^31" Q     ;CWAD
"RTN","HMPDJ08",171,0)
 I TYPE="C"    S CLASS=3,SUBCLASS=30 Q                ;Crisis Note
"RTN","HMPDJ08",172,0)
 I TYPE="W"    S CLASS=3,SUBCLASS=31 Q                ;Clinical Warning
"RTN","HMPDJ08",173,0)
 I TYPE="A"    S CLASS=3,SUBCLASS=25 Q                ;Allergy Note
"RTN","HMPDJ08",174,0)
 I TYPE="D"    S CLASS=3,SUBCLASS=27 Q                ;Advance Directive
"RTN","HMPDJ08",175,0)
 ;
"RTN","HMPDJ08",176,0)
 I TYPE="DS"   S CLASS=244 Q                          ;Discharge Summary
"RTN","HMPDJ08",177,0)
 ;
"RTN","HMPDJ08",178,0)
 I TYPE="SR"   S CLASS=$$CLASS^TIUSROI("SURGICAL REPORTS") Q
"RTN","HMPDJ08",179,0)
 I TYPE="CP" D  Q                                     ;Clin Procedures
"RTN","HMPDJ08",180,0)
 . I STATUS'=2 S CLASS="CP"                           ; if unsigned,
"RTN","HMPDJ08",181,0)
 . E  D CPCLASS^TIUCP(.CP) S CLASS=CP                 ; use TIU class#
"RTN","HMPDJ08",182,0)
 ;
"RTN","HMPDJ08",183,0)
 I TYPE="LR"   S CLASS=$S(STATUS=2:$$LR,1:"LR") Q     ;Lab/Pathology
"RTN","HMPDJ08",184,0)
 ;
"RTN","HMPDJ08",185,0)
 I TYPE="RA"   S CLASS="RA" Q                         ;Radiology
"RTN","HMPDJ08",186,0)
 ;
"RTN","HMPDJ08",187,0)
 Q
"RTN","HMPDJ08",188,0)
 ;
"RTN","HMPDJ08",189,0)
LR() ; -- Return ien of Lab class
"RTN","HMPDJ08",190,0)
 N Y S Y=+$O(^TIU(8925.1,"B","LR LABORATORY REPORTS",0)) ;ICR 2321 DE2818 ASF 11/10/15
"RTN","HMPDJ08",191,0)
 I Y>0,$S($P($G(^TIU(8925.1,Y,0)),U,4)="CL":0,$P($G(^(0)),U,4)="DC":0,1:1) S Y=0
"RTN","HMPDJ08",192,0)
 Q Y
"RTN","HMPDJ08",193,0)
 ;
"RTN","HMPDJ08",194,0)
MATCH(DOC,STS) ; -- Return 1 or 0, if document DA matches search criteria
"RTN","HMPDJ08",195,0)
 N Y,DA,LOCAL,OK S Y=0
"RTN","HMPDJ08",196,0)
 S DA=+$G(DOC) G:DA<1 MQ
"RTN","HMPDJ08",197,0)
 ; include addenda if pulling only unsigned items
"RTN","HMPDJ08",198,0)
 I $P(DOC,U,2)?1"Addendum ".E,STATUS'=2 G MQ
"RTN","HMPDJ08",199,0)
 ; TIU unsigned list can include completed parent notes
"RTN","HMPDJ08",200,0)
 I $G(STS)=2,$P(DOC,U,7)'="unsigned" G MQ
"RTN","HMPDJ08",201,0)
 S LOCAL=$$GET1^DIQ(8925,DA_",",.01,"I") ;local Title 8925.1 ien
"RTN","HMPDJ08",202,0)
 I $L(SUBCLASS) D  G:'OK MQ
"RTN","HMPDJ08",203,0)
 . N I,X S OK=0
"RTN","HMPDJ08",204,0)
 . F I=1:1:$L(SUBCLASS,"^") S X=$P(SUBCLASS,U,I) I $$ISA^TIULX(LOCAL,X) S OK=1 Q
"RTN","HMPDJ08",205,0)
 S Y=1
"RTN","HMPDJ08",206,0)
MQ Q Y
"RTN","HMPDJ08",207,0)
 ;
"RTN","HMPDJ08",208,0)
TYPE(X) ; -- Return name of category type X
"RTN","HMPDJ08",209,0)
 S X=$G(X)
"RTN","HMPDJ08",210,0)
 I X="PN" Q "Progress Note"
"RTN","HMPDJ08",211,0)
 I X="DS" Q "Discharge Summary"
"RTN","HMPDJ08",212,0)
 I X="CP" Q "Clinical Procedure"
"RTN","HMPDJ08",213,0)
 I X="SR" Q "Surgery Report"
"RTN","HMPDJ08",214,0)
 I X="LR" Q "Laboratory Report"
"RTN","HMPDJ08",215,0)
 I X="RA" Q "Radiology Report"
"RTN","HMPDJ08",216,0)
 I X="CR" Q "Consult Report"
"RTN","HMPDJ08",217,0)
 I X="C"  Q "Crisis Note"
"RTN","HMPDJ08",218,0)
 I X="W"  Q "Clinical Warning"
"RTN","HMPDJ08",219,0)
 I X="A"  Q "Allergy/Adverse Reaction"
"RTN","HMPDJ08",220,0)
 I X="D"  Q "Advance Directive"
"RTN","HMPDJ08",221,0)
 Q ""
"RTN","HMPDJ09")
0^32^B58540657^B47251770
"RTN","HMPDJ09",1,0)
HMPDJ09 ;SLC/MKB,ASMR/RRB,CPC - PCE;May 15, 2016 14:15
"RTN","HMPDJ09",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJ09",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ09",4,0)
 ;
"RTN","HMPDJ09",5,0)
 ;DE4068 - reworked all PCRMINDX references to include ICD10
"RTN","HMPDJ09",6,0)
 ;
"RTN","HMPDJ09",7,0)
 ; External References          DBIA#
"RTN","HMPDJ09",8,0)
 ; -------------------          -----
"RTN","HMPDJ09",9,0)
 ; ^AUPNVSIT                     2028
"RTN","HMPDJ09",10,0)
 ; ^PXRMINDX                     4290
"RTN","HMPDJ09",11,0)
 ; ^SC                          10040
"RTN","HMPDJ09",12,0)
 ; ^VA(200                      10060
"RTN","HMPDJ09",13,0)
 ; DIC                           2051
"RTN","HMPDJ09",14,0)
 ; DILFD                         2055
"RTN","HMPDJ09",15,0)
 ; DIQ                           2056
"RTN","HMPDJ09",16,0)
 ; PXAPI,^TMP("PXKENC"           1894
"RTN","HMPDJ09",17,0)
 ; VALM1                        10116
"RTN","HMPDJ09",18,0)
 ; XUAF4                         2171
"RTN","HMPDJ09",19,0)
 ;
"RTN","HMPDJ09",20,0)
 ; All tags expect DFN, ID, [HMPSTART, HMPSTOP, HMPMAX, HMPTEXT]
"RTN","HMPDJ09",21,0)
 Q
"RTN","HMPDJ09",22,0)
 ;
"RTN","HMPDJ09",23,0)
PX(FNUM) ; -- PCE item(s)
"RTN","HMPDJ09",24,0)
 I $G(HMPID) D PXA(HMPID) Q
"RTN","HMPDJ09",25,0)
 N HMPIDT,ID D SORT ;sort ^PXRMINDX into ^TMP("HMPPX",$J,IDT)
"RTN","HMPDJ09",26,0)
 S HMPIDT=0 F  S HMPIDT=$O(^TMP("HMPPX",$J,HMPIDT)) Q:HMPIDT<1  D  Q:HMPI'<HMPMAX
"RTN","HMPDJ09",27,0)
 . S ID=0 F  S ID=$O(^TMP("HMPPX",$J,HMPIDT,ID)) Q:ID<1  D PX1 Q:HMPI'<HMPMAX
"RTN","HMPDJ09",28,0)
 K ^TMP("HMPPX",$J)
"RTN","HMPDJ09",29,0)
 Q
"RTN","HMPDJ09",30,0)
 ;
"RTN","HMPDJ09",31,0)
PXA(ID) ; -- find ID in ^PXRMINDX(FNUM), fall thru to PX1 if successful
"RTN","HMPDJ09",32,0)
 N N,ROOT,IDX,P,ITEM,DATE,HMPIDT,ICDSYS
"RTN","HMPDJ09",33,0)
 S N=+$P(FNUM,".",2) K ^TMP("HMPPX",$J)
"RTN","HMPDJ09",34,0)
 I N=7!(N=18) S ROOT="^PXRMINDX("_FNUM_",""PPI"","_+$G(DFN)
"RTN","HMPDJ09",35,0)
 E  S ROOT="^PXRMINDX("_FNUM_",""PI"","_+$G(DFN)
"RTN","HMPDJ09",36,0)
 S IDX=ROOT_")" F  S IDX=$Q(@IDX) Q:$P(IDX,",",1,3)'=ROOT  D
"RTN","HMPDJ09",37,0)
 . S P=$L(IDX,",") Q:ID'=+$P(IDX,",",P)  ;last subscript
"RTN","HMPDJ09",38,0)
 . S DATE=+$P(IDX,",",P-1),ITEM=+$P(IDX,",",P-2)
"RTN","HMPDJ09",39,0)
 . S HMPIDT=9999999-DATE,^TMP("HMPPX",$J,HMPIDT,ID)=ITEM_U_DATE
"RTN","HMPDJ09",40,0)
 ;DE4068 also check for ICD10
"RTN","HMPDJ09",41,0)
 I N=7 S ROOT="^PXRMINDX("_FNUM_",""10D"",""PPI"","_+$G(DFN) D
"RTN","HMPDJ09",42,0)
 . S IDX=ROOT_")" F  S IDX=$Q(@IDX) Q:$P(IDX,",",1,4)'=ROOT  D
"RTN","HMPDJ09",43,0)
 ..  S P=$L(IDX,",") Q:ID'=+$P(IDX,",",P)  ;last subscript
"RTN","HMPDJ09",44,0)
 ..  S DATE=+$P(IDX,",",P-1),ITEM=+$P(IDX,",",P-2)
"RTN","HMPDJ09",45,0)
 ..  S HMPIDT=9999999-DATE,^TMP("HMPPX",$J,HMPIDT,ID)=ITEM_U_DATE
"RTN","HMPDJ09",46,0)
 Q:'$D(^TMP("HMPPX",$J))  ;not found
"RTN","HMPDJ09",47,0)
PX1 ; -- PCE ^TMP("HMPPX",$J,HMPIDT,ID)=ITM^DATE for FNUM
"RTN","HMPDJ09",48,0)
 N N,COLL,TAG,HMPF,FLD,TMP,VISIT,X0,X12,FAC,LOC,X,Y,PCE
"RTN","HMPDJ09",49,0)
 N $ES,$ET,ERRPAT,ERRMSG
"RTN","HMPDJ09",50,0)
 S $ET="D ERRHDLR^HMPDERRH",ERRPAT=DFN
"RTN","HMPDJ09",51,0)
 S N=+$P(FNUM,".",2),TAG=$S(N=7:"VPOV",N=11:"VIMM",N=12:"VSKIN",N=13:"VXAM",N=16:"VPEDU",N=18:"VCPT",1:"VHF")
"RTN","HMPDJ09",52,0)
 S ERRMSG="A problem occurred converting record "_ID_" for "_TAG
"RTN","HMPDJ09",53,0)
 D @(TAG_"^PXPXRM(ID,.HMPF)")
"RTN","HMPDJ09",54,0)
 ;
"RTN","HMPDJ09",55,0)
 S PCE("localId")=ID,TMP=$G(^TMP("HMPPX",$J,HMPIDT,ID))
"RTN","HMPDJ09",56,0)
 S COLL=$S(N=7:"pov",N=11:"immunization",N=12:"skin",N=13:"exam",N=16:"education",N=18:"cpt",1:"factor")
"RTN","HMPDJ09",57,0)
 S PCE("uid")=$$SETUID^HMPUTILS(COLL,DFN,ID)
"RTN","HMPDJ09",58,0)
 ; TAG=$S(N=23:"recorded",N=11:"administeredDateTime",1:"dateTimeEntered")
"RTN","HMPDJ09",59,0)
 S TAG=$S(N=11:"administeredDateTime",1:"entered")
"RTN","HMPDJ09",60,0)
 S PCE(TAG)=$$JSONDT^HMPUTILS($P(TMP,U,2))
"RTN","HMPDJ09",61,0)
 I N=7!(N=18) I $G(FILTER("freshnessDateTime")) S PCE(TAG)=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime")) ;DE4068
"RTN","HMPDJ09",62,0)
 S PCE("name")=$$EXTERNAL^DILFD(FNUM,.01,,+TMP)
"RTN","HMPDJ09",63,0)
 S VISIT=+$G(HMPF("VISIT")),PCE("encounterUid")=$$SETUID^HMPUTILS("visit",DFN,VISIT)
"RTN","HMPDJ09",64,0)
 S PCE("encounterName")=$$NAME^HMPDJ04(VISIT)
"RTN","HMPDJ09",65,0)
 ;DE2818, ^AUPNVSIT - ICR 2028
"RTN","HMPDJ09",66,0)
 S X0=$G(^AUPNVSIT(+VISIT,0)),FAC=+$P(X0,U,6),LOC=+$P(X0,U,22)  ;(#.06) LOC. OF ENCOUNTER, (#.22) HOSPITAL LOCATION
"RTN","HMPDJ09",67,0)
 S:FAC X=$$STA^XUAF4(FAC)_U_$P($$NS^XUAF4(FAC),U)
"RTN","HMPDJ09",68,0)
 S:'FAC X=$$FAC^HMPD(LOC)
"RTN","HMPDJ09",69,0)
 D FACILITY^HMPUTILS(X,"PCE")
"RTN","HMPDJ09",70,0)
 ;DE2818 ^SC global reference changed to FileMan
"RTN","HMPDJ09",71,0)
 S:LOC PCE("locationUid")=$$SETUID^HMPUTILS("location",,LOC),PCE("locationName")=$$GET1^DIQ(44,LOC_",",.01)
"RTN","HMPDJ09",72,0)
 S X=$G(HMPF("COMMENTS")) S:$L(X) PCE("comment")=X
"RTN","HMPDJ09",73,0)
POV I FNUM=9000010.07 D  G PXQ
"RTN","HMPDJ09",74,0)
 . S X=$G(HMPF("PRIMARY/SECONDARY")),PCE("type")=$S($L(X):X,1:"U")
"RTN","HMPDJ09",75,0)
 . S X=PCE("name"),PCE("icdCode")=$$SETNCS^HMPUTILS("icd",X)
"RTN","HMPDJ09",76,0)
 . S X=$G(HMPF("PROVIDER NARRATIVE")),PCE("name")=$$EXTERNAL^DILFD(9000010.07,.04,,X)
"RTN","HMPDJ09",77,0)
CPT I FNUM=9000010.18 D  G PXQ
"RTN","HMPDJ09",78,0)
 . S X=$G(HMPF("PRINCIPAL PROCEDURE")),PCE("type")=$S($L(X):X,1:"U")
"RTN","HMPDJ09",79,0)
 . S X=PCE("name"),PCE("cptCode")=$$SETNCS^HMPUTILS("cpt",X)
"RTN","HMPDJ09",80,0)
 . S X=$G(HMPF("PROVIDER NARRATIVE")),PCE("name")=$$EXTERNAL^DILFD(9000010.18,.04,,X)
"RTN","HMPDJ09",81,0)
 . S PCE("quantity")=HMPF("QUANTITY")
"RTN","HMPDJ09",82,0)
 S X=$G(HMPF("VALUE")),FLD=$S(FNUM=9000010.16:.06,1:.04)
"RTN","HMPDJ09",83,0)
 S Y=$$EXTERNAL^DILFD(FNUM,FLD,,X)
"RTN","HMPDJ09",84,0)
IM I FNUM=9000010.11 D  G PXQ ;immunization
"RTN","HMPDJ09",85,0)
 . S:$L(Y) PCE("seriesName")=Y,PCE("seriesCode")=$$SETUID^HMPUTILS("series",DFN,Y)
"RTN","HMPDJ09",86,0)
 . S X=$G(HMPF("REACTION")) I $L(X) D
"RTN","HMPDJ09",87,0)
 .. S PCE("reactionName")=$$EXTERNAL^DILFD(9000010.11,.06,,X)
"RTN","HMPDJ09",88,0)
 .. S PCE("reactionCode")=$$SETUID^HMPUTILS("reaction",DFN,X)
"RTN","HMPDJ09",89,0)
 . S PCE("contraindicated")=$S(+$G(HMPF("CONTRAINDICATED")):"true",1:"false")
"RTN","HMPDJ09",90,0)
 . I '$D(^TMP("PXKENC",$J,VISIT)) D ENCEVENT^PXAPI(VISIT,1)
"RTN","HMPDJ09",91,0)
 . S X12=$G(^TMP("PXKENC",$J,VISIT,"IMM",ID,12))
"RTN","HMPDJ09",92,0)
 . S X=$P(X12,U,4) S:'X X=$P(X12,U,2)
"RTN","HMPDJ09",93,0)
 . I 'X S I=0 F  S I=$O(^TMP("PXKENC",$J,VISIT,"PRV",I)) Q:I<1  I $P($G(^(I,0)),U,4)="P" S X=+^(0) Q
"RTN","HMPDJ09",94,0)
 . ;DE2818, ^VA(200 reference changed to FileMan
"RTN","HMPDJ09",95,0)
 . S:X PCE("performerUid")=$$SETUID^HMPUTILS("user",,+X),PCE("performerName")=$$GET1^DIQ(200,X_",",.01)
"RTN","HMPDJ09",96,0)
 . ; CPT mapping
"RTN","HMPDJ09",97,0)
 . S X=+$$FIND1^DIC(811.1,,"QX",+TMP_";AUTTIMM(","B") I X>0 D
"RTN","HMPDJ09",98,0)
 .. S Y=$$GET1^DIQ(811.1,X_",",.02,"I") Q:Y<1
"RTN","HMPDJ09",99,0)
 .. N CPT S CPT=$G(@(U_$P(Y,";",2)_+Y_",0)"))
"RTN","HMPDJ09",100,0)
 .. S PCE("cptCode")=$$SETNCS^HMPUTILS("cpt",+CPT)
"RTN","HMPDJ09",101,0)
 .. S (PCE("summary"),PCE("cptName"))=$P(CPT,U,2)
"RTN","HMPDJ09",102,0)
HF I FNUM=9000010.23 D  G PXQ ;health factor
"RTN","HMPDJ09",103,0)
 . S:$L(X) PCE("severityUid")=$$SETVURN^HMPUTILS("factor-severity",X),PCE("severityName")=$$LOWER^VALM1(Y)
"RTN","HMPDJ09",104,0)
 . S X=$$GET1^DIQ(9999999.64,+TMP_",",.03,"I") I X D
"RTN","HMPDJ09",105,0)
 .. S PCE("categoryUid")=$$SETVURN^HMPUTILS("factor-category",X)
"RTN","HMPDJ09",106,0)
 .. S PCE("categoryName")=$$EXTERNAL^DILFD(9999999.64,.03,"",X)
"RTN","HMPDJ09",107,0)
 . S X=$$GET1^DIQ(9999999.64,+TMP_",",.08)
"RTN","HMPDJ09",108,0)
 . I $E(X)="Y" S PCE("display")="true"
"RTN","HMPDJ09",109,0)
 . S PCE("kind")="Health Factor",PCE("summary")=PCE("name")
"RTN","HMPDJ09",110,0)
SK I FNUM=9000010.12 D  ;skin test [fall thru to set result]
"RTN","HMPDJ09",111,0)
 . S X=$G(HMPF("READING")) S:$L(X) PCE("reading")=X
"RTN","HMPDJ09",112,0)
 . S X=$G(HMPF("DATE READ")) S:X PCE("dateRead")=$$JSONDT^HMPUTILS(X)
"RTN","HMPDJ09",113,0)
 S:$L(Y) PCE("result")=Y
"RTN","HMPDJ09",114,0)
PXQ ;finish
"RTN","HMPDJ09",115,0)
 S PCE("lastUpdateTime")=$$EN^HMPSTMP(COLL) ; RHL 20150115
"RTN","HMPDJ09",116,0)
 S PCE("stampTime")=PCE("lastUpdateTime")   ; RHL 20150115
"RTN","HMPDJ09",117,0)
 ;US6734 - pre-compile metastamp
"RTN","HMPDJ09",118,0)
 I $G(HMPMETA) D ADD^HMPMETA(COLL,PCE("uid"),PCE("stampTime")) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPDJ09",119,0)
 D ADD^HMPDJ("PCE",COLL)
"RTN","HMPDJ09",120,0)
 Q
"RTN","HMPDJ09",121,0)
 ;
"RTN","HMPDJ09",122,0)
SORT ; -- build ^TMP("HMPPX",$J,9999999-DATE,DA)=ITEM^DATE in range
"RTN","HMPDJ09",123,0)
 N TYPE,ITEM,DATE,DA,IDT K ^TMP("HMPPX",$J)
"RTN","HMPDJ09",124,0)
 I FNUM=9000010.07!(FNUM=9000010.18) G PPI
"RTN","HMPDJ09",125,0)
PI ; from ^PXRMINDX(FNUM,"PI",DFN,ITEM,DATE,DA)
"RTN","HMPDJ09",126,0)
 ;DE2818, ^PXRMINDX - ICR 4290
"RTN","HMPDJ09",127,0)
 S ITEM=0 F  S ITEM=$O(^PXRMINDX(FNUM,"PI",+$G(DFN),ITEM)) Q:ITEM<1  D
"RTN","HMPDJ09",128,0)
 . S DATE=0 F  S DATE=$O(^PXRMINDX(FNUM,"PI",+$G(DFN),ITEM,DATE)) Q:DATE<1  D
"RTN","HMPDJ09",129,0)
 .. Q:DATE<HMPSTART  Q:DATE>HMPSTOP  S IDT=9999999-DATE
"RTN","HMPDJ09",130,0)
 .. S DA=0 F  S DA=$O(^PXRMINDX(FNUM,"PI",+$G(DFN),ITEM,DATE,DA)) Q:DA<1  S ^TMP("HMPPX",$J,IDT,DA)=ITEM_U_DATE
"RTN","HMPDJ09",131,0)
 Q
"RTN","HMPDJ09",132,0)
PPI ; from ^PXRMINDX(FNUM,"PPI",DFN,TYPE,ITEM,DATE,DA)
"RTN","HMPDJ09",133,0)
 S TYPE="" F  S TYPE=$O(^PXRMINDX(FNUM,"PPI",+$G(DFN),TYPE)) Q:TYPE=""  D
"RTN","HMPDJ09",134,0)
 . S ITEM=0 F  S ITEM=$O(^PXRMINDX(FNUM,"PPI",+$G(DFN),TYPE,ITEM)) Q:ITEM<1  D
"RTN","HMPDJ09",135,0)
 .. S DATE=0 F  S DATE=$O(^PXRMINDX(FNUM,"PPI",+$G(DFN),TYPE,ITEM,DATE)) Q:DATE<1  D
"RTN","HMPDJ09",136,0)
 ... Q:DATE<HMPSTART  Q:DATE>HMPSTOP  S IDT=9999999-DATE
"RTN","HMPDJ09",137,0)
 ... S DA=0 F  S DA=$O(^PXRMINDX(FNUM,"PPI",+$G(DFN),TYPE,ITEM,DATE,DA)) Q:DA<1  S ^TMP("HMPPX",$J,IDT,DA)=ITEM_U_DATE
"RTN","HMPDJ09",138,0)
 Q:FNUM=9000010.18  ;
"RTN","HMPDJ09",139,0)
 ;for POV also check ICD10 CODES
"RTN","HMPDJ09",140,0)
 S TYPE="" F  S TYPE=$O(^PXRMINDX(FNUM,"10D","PPI",+$G(DFN),TYPE)) Q:TYPE=""  D
"RTN","HMPDJ09",141,0)
 . S ITEM="" F  S ITEM=$O(^PXRMINDX(FNUM,"10D","PPI",+$G(DFN),TYPE,ITEM)) Q:ITEM=""  D
"RTN","HMPDJ09",142,0)
 ..  S DATE=0 F  S DATE=$O(^PXRMINDX(FNUM,"10D","PPI",+$G(DFN),TYPE,ITEM,DATE)) Q:DATE<1  D
"RTN","HMPDJ09",143,0)
 ...   Q:DATE<HMPSTART  Q:DATE>HMPSTOP  S IDT=9999999-DATE
"RTN","HMPDJ09",144,0)
 ...   S DA=0 F  S DA=$O(^PXRMINDX(FNUM,"10D","PPI",+$G(DFN),TYPE,ITEM,DATE,DA)) Q:DA<1  S ^TMP("HMPPX",$J,IDT,DA)=ITEM_U_DATE
"RTN","HMPDJ09",145,0)
 Q
"RTN","HMPDJ09",146,0)
 ;
"RTN","HMPDJ09",147,0)
PTF ; from ^PXRMINDX(45,"ICD9","PNI",DFN,TYPE,ITEM,DATE,DA)
"RTN","HMPDJ09",148,0)
 ;Purpose - Build ^TMP("HMPPX") from ^PXRMINDX(45,HMPISYS,"PNI",DFN)
"RTN","HMPDJ09",149,0)
 ;
"RTN","HMPDJ09",150,0)
 ;Called by - PTF^HMPDJ0 (if HMPID is not set)
"RTN","HMPDJ09",151,0)
 ;
"RTN","HMPDJ09",152,0)
 ;Assumptions -
"RTN","HMPDJ09",153,0)
 ;1. DFN, HMPSTART and HMPSTOP variables have been set in prior code
"RTN","HMPDJ09",154,0)
 ;2. ^TMP("HMPPX") does not exist and needs to be built
"RTN","HMPDJ09",155,0)
 ;3. '$G(HMPID)
"RTN","HMPDJ09",156,0)
 ;
"RTN","HMPDJ09",157,0)
 ;Modification History -
"RTN","HMPDJ09",158,0)
 ;US5630 (TW) - HMPISYS can be either "ICD" or "10D" (ICD-10)
"RTN","HMPDJ09",159,0)
 ;
"RTN","HMPDJ09",160,0)
 N HMPISYS,HMPTYP,HMPDX,HMPDT,HMPITEM,HMPRDT
"RTN","HMPDJ09",161,0)
 S HMPISYS="" F  S HMPISYS=$O(^PXRMINDX(45,HMPISYS)) Q:HMPISYS=""  D 
"RTN","HMPDJ09",162,0)
 . Q:'$D(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN)))
"RTN","HMPDJ09",163,0)
 . S HMPTYP="" F  S HMPTYP=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP)) Q:HMPTYP=""  D
"RTN","HMPDJ09",164,0)
 .. S HMPDX=0 F  S HMPDX=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX)) Q:HMPDX=""  D
"RTN","HMPDJ09",165,0)
 ... S HMPDT=0 F  S HMPDT=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX,HMPDT)) Q:HMPDT<1  D
"RTN","HMPDJ09",166,0)
 .... Q:HMPDT<HMPSTART  Q:HMPDT>HMPSTOP  S HMPRDT=9999999-HMPDT
"RTN","HMPDJ09",167,0)
 .... S HMPITEM="" F  S HMPITEM=$O(^PXRMINDX(45,HMPISYS,"PNI",+$G(DFN),HMPTYP,HMPDX,HMPDT,HMPITEM)) Q:HMPITEM=""  S ^TMP("HMPPX",$J,HMPRDT,HMPITEM_";"_HMPTYP)=HMPDX_U_HMPDT_U_HMPISYS
"RTN","HMPDJ09",168,0)
 Q
"RTN","HMPDJ09",169,0)
 ;
"RTN","HMPDJ1")
0^34^B18382483^B18644090
"RTN","HMPDJ1",1,0)
HMPDJ1 ;SLC/MKB,ASMR/RRB,CK - HMP Patient Object RPCs;May 15, 2016 14:15
"RTN","HMPDJ1",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJ1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ1",4,0)
 ;
"RTN","HMPDJ1",5,0)
 Q
"RTN","HMPDJ1",6,0)
 ;
"RTN","HMPDJ1",7,0)
PUT(HMP,PAT,TYPE,JSON) ; -- Save/update JSON OBJECT in ^HMP(800000.1), return UID if successful
"RTN","HMPDJ1",8,0)
 ; RPC = HMP PUT PATIENT DATA
"RTN","HMPDJ1",9,0)
 ;
"RTN","HMPDJ1",10,0)
 N ARRAY,CNT,ERR,HMPERR,UID,DA,X,I,DFN,HMPSYS
"RTN","HMPDJ1",11,0)
 ;M JSON=INPUT(0)
"RTN","HMPDJ1",12,0)
 D DECODE^HMPJSON("JSON","ARRAY","HMPERR")
"RTN","HMPDJ1",13,0)
 ;N XCNT S XCNT=$O(^XTMP("AGPARRAY",""),-1),XCNT=XCNT+1
"RTN","HMPDJ1",14,0)
 ;M ^XTMP("AGPARRAY",XCNT,"DATA")=ARRAY
"RTN","HMPDJ1",15,0)
 ;S ^XTMP("AGPARRAY",XCNT,"TYPE")=TYPE
"RTN","HMPDJ1",16,0)
 ;M ^XTMP("AGPARRAY")=ARRAY
"RTN","HMPDJ1",17,0)
 I $D(HMPERR) D  Q  ;S X=$G(ERR(1)) K ERR S ERR=X G PTQ
"RTN","HMPDJ1",18,0)
 . K ARRAY N HMPTMP,HMPTXT
"RTN","HMPDJ1",19,0)
 . S HMPTXT(1)="Problem decoding json input."
"RTN","HMPDJ1",20,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.JSON)
"RTN","HMPDJ1",21,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","ARRAY","HMPERR")
"RTN","HMPDJ1",22,0)
 . S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPDJ1",23,0)
 . M HMP(1)=ARRAY
"RTN","HMPDJ1",24,0)
 . S HMP(2)="}}"
"RTN","HMPDJ1",25,0)
 ;
"RTN","HMPDJ1",26,0)
 S UID=$G(ARRAY("uid")),HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJ1",27,0)
 I $L(UID) S DA=+$O(^HMP(800000.1,"B",UID,0)) I DA<1 S ERR=$$ERR(3,UID) G PTQ
"RTN","HMPDJ1",28,0)
 I '$L(UID) D  G:$D(ERR) PTQ Q:$D(HMPERR)
"RTN","HMPDJ1",29,0)
 . D NEW Q:$D(ERR)
"RTN","HMPDJ1",30,0)
 . S ARRAY("uid")=UID K JSON
"RTN","HMPDJ1",31,0)
 . D ENCODE^HMPJSON("ARRAY","JSON","HMPERR")
"RTN","HMPDJ1",32,0)
 . I $D(HMPERR) D  Q  ;S X=$G(ERR(1)) K ERR S ERR=X Q
"RTN","HMPDJ1",33,0)
 .. K JSON N HMPTMP,HMPTXT
"RTN","HMPDJ1",34,0)
 .. S HMPTXT(1)="Problem encoding json output."
"RTN","HMPDJ1",35,0)
 .. D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.ARRAY)
"RTN","HMPDJ1",36,0)
 .. K HMPERR D ENCODE^HMPJSON("HMPTMP","JSON","HMPERR")
"RTN","HMPDJ1",37,0)
 .. S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPDJ1",38,0)
 .. M HMP(1)=JSON
"RTN","HMPDJ1",39,0)
 .. S HMP(2)="}}"
"RTN","HMPDJ1",40,0)
 ;
"RTN","HMPDJ1",41,0)
 K ^HMP(800000.1,DA,1) S ^(1,0)="^800000.101^^",CNT=0
"RTN","HMPDJ1",42,0)
 S I="" F  S I=$O(JSON(I)) Q:I=""  S CNT=CNT+1,^HMP(800000.1,DA,1,CNT,0)=JSON(I)
"RTN","HMPDJ1",43,0)
 S:$G(CNT) ^HMP(800000.1,DA,1,0)="^800000.101^"_CNT_U_CNT
"RTN","HMPDJ1",44,0)
 ;
"RTN","HMPDJ1",45,0)
PTQ ; add item count and terminating characters
"RTN","HMPDJ1",46,0)
 I $D(ERR) S HMP="{""apiVersion"":""1.01"",""error"":{""message"":"""_ERR_"""},""success"":false}" Q
"RTN","HMPDJ1",47,0)
 S HMP="{""apiVersion"":""1.01"",""data"":{""updated"":"_""""_$$HL7NOW_""""_",""uid"":"""_UID_"""},""success"":true}"
"RTN","HMPDJ1",48,0)
 S DFN=+$P(UID,":",5)
"RTN","HMPDJ1",49,0)
 D POST^HMPEVNT(DFN,TYPE,DA) ;UID)
"RTN","HMPDJ1",50,0)
 Q
"RTN","HMPDJ1",51,0)
 ;
"RTN","HMPDJ1",52,0)
NEW ; -- create new entry in ^HMP(800000.1) from PAT,TYPE,HMPSYS
"RTN","HMPDJ1",53,0)
 ;  Return UID & DA, or ERR
"RTN","HMPDJ1",54,0)
 N DFN,ICN
"RTN","HMPDJ1",55,0)
 S DFN=+$G(PAT),ICN="",TYPE=$G(TYPE)
"RTN","HMPDJ1",56,0)
 I DFN<1,DFN[";" S ICN=+$P($G(DFN),";",2),DFN=+$G(DFN)
"RTN","HMPDJ1",57,0)
 I DFN<1,ICN S DFN=+$$GETDFN^MPIF001(ICN)
"RTN","HMPDJ1",58,0)
 I DFN<1!'$D(^DPT(DFN)) S ERR=$$ERR(1,DFN) Q  ; IA 10035, DE2818
"RTN","HMPDJ1",59,0)
 I TYPE="" S ERR=$$ERR(2,"null") Q
"RTN","HMPDJ1",60,0)
 ;
"RTN","HMPDJ1",61,0)
 S DA=$$NEXTIFN I DA<1 S ERR=$$ERR(4) Q
"RTN","HMPDJ1",62,0)
 S UID="urn:va:"_TYPE_":"_HMPSYS_":"_DFN_":"_DA
"RTN","HMPDJ1",63,0)
 S ^HMP(800000.1,DA,0)=UID_U_DFN_U_TYPE
"RTN","HMPDJ1",64,0)
 S ^HMP(800000.1,"B",UID,DA)=""
"RTN","HMPDJ1",65,0)
 S ^HMP(800000.1,"C",DFN,TYPE,DA)=""
"RTN","HMPDJ1",66,0)
 Q
"RTN","HMPDJ1",67,0)
 ;
"RTN","HMPDJ1",68,0)
NEXTIFN() ; -- Returns next available IFN
"RTN","HMPDJ1",69,0)
 N I,HDR,TOTAL,DA
"RTN","HMPDJ1",70,0)
 L +^HMP(800000.1,0):$S($G(DILOCKTM)>0:DILOCKTM,1:5)
"RTN","HMPDJ1",71,0)
 I '$T Q "^"
"RTN","HMPDJ1",72,0)
 S HDR=$G(^HMP(800000.1,0)),TOTAL=+$P(HDR,U,4),I=$O(^HMP(800000.1,"?"),-1)
"RTN","HMPDJ1",73,0)
 F I=(I+1):1 Q:'$D(^HMP(800000.1,I,0))
"RTN","HMPDJ1",74,0)
 S DA=I,$P(HDR,U,3,4)=DA_U_(TOTAL+1) S ^HMP(800000.1,0)=HDR
"RTN","HMPDJ1",75,0)
 L -^HMP(800000.1,0)
"RTN","HMPDJ1",76,0)
 Q DA
"RTN","HMPDJ1",77,0)
 ;
"RTN","HMPDJ1",78,0)
ERR(X,VAL) ; -- return error message
"RTN","HMPDJ1",79,0)
 N MSG  S MSG="Error"
"RTN","HMPDJ1",80,0)
 I X=1  S MSG="Patient with dfn '"_$G(VAL)_"' not found"
"RTN","HMPDJ1",81,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPDJ1",82,0)
 I X=3  S MSG="UID '"_$G(VAL)_"' not found"
"RTN","HMPDJ1",83,0)
 I X=4  S MSG="Unable to create new object"
"RTN","HMPDJ1",84,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPDJ1",85,0)
 Q MSG
"RTN","HMPDJ1",86,0)
 ;
"RTN","HMPDJ1",87,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPDJ1",88,0)
 Q $P($$FMTHL7^XLFDT($$NOW^XLFDT),"-")
"RTN","HMPDJ1",89,0)
 ;
"RTN","HMPDJ1",90,0)
CONV ; -- convert uid format
"RTN","HMPDJ1",91,0)
 N DA,X0,UID,HMPSYS,DFN,COLL,NEW,I,JSON,HMPY,ERR,CNT
"RTN","HMPDJ1",92,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJ1",93,0)
 S DA=0 F  S DA=$O(^HMP(800000.1,DA)) Q:DA<1  D
"RTN","HMPDJ1",94,0)
 . S X0=$G(^HMP(800000.1,DA,0)),UID=$P(X0,U)
"RTN","HMPDJ1",95,0)
 . K ^HMP(800000.1,"B",UID,DA),JSON
"RTN","HMPDJ1",96,0)
 . S DFN=$P(X0,"^",2),COLL=$P(X0,"^",3)
"RTN","HMPDJ1",97,0)
 . S NEW="urn:va:"_COLL_":"_HMPSYS_":"_DFN_":"_DA
"RTN","HMPDJ1",98,0)
 . S $P(^HMP(800000.1,DA,0),U)=NEW,^HMP(800000.1,"B",NEW,DA)=""
"RTN","HMPDJ1",99,0)
 . ;decode JSON object, reset uid
"RTN","HMPDJ1",100,0)
 . S I=0 F  S I=$O(^HMP(800000.1,DA,1,I)) Q:I<1  S JSON(I)=$G(^(I,0))
"RTN","HMPDJ1",101,0)
 . Q:'$D(JSON)  K HMPY,ERR
"RTN","HMPDJ1",102,0)
 . D DECODE^HMPJSON("JSON","HMPY","ERR") I $D(ERR) W !,DA Q
"RTN","HMPDJ1",103,0)
 . S HMPY("uid")=NEW K JSON
"RTN","HMPDJ1",104,0)
 . D ENCODE^HMPJSON("HMPY","JSON","ERR") I $D(ERR) W !,DA Q
"RTN","HMPDJ1",105,0)
 . K ^HMP(800000.1,DA,1) S ^(1,0)="^800000.101^^",CNT=0
"RTN","HMPDJ1",106,0)
 . S I="" F  S I=$O(JSON(I)) Q:I=""  S CNT=CNT+1,^HMP(800000.1,DA,1,CNT,0)=JSON(I)
"RTN","HMPDJ1",107,0)
 . S:$G(CNT) ^HMP(800000.1,DA,1,0)="^800000.101^"_CNT_U_CNT
"RTN","HMPDJ1",108,0)
 Q
"RTN","HMPDJ2")
0^35^B21292359^B21439862
"RTN","HMPDJ2",1,0)
HMPDJ2 ;SLC/MKB,ASMR/RRB,CK - HMP Object RPCs;May 15, 2016 14:15
"RTN","HMPDJ2",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJ2",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJ2",4,0)
 ;
"RTN","HMPDJ2",5,0)
 Q
"RTN","HMPDJ2",6,0)
 ;
"RTN","HMPDJ2",7,0)
GET(HMP,FILTER) ; -- Return search results as JSON in @HMP@(n)
"RTN","HMPDJ2",8,0)
 ; RPC = HMP GET OBJECT
"RTN","HMPDJ2",9,0)
 N TYPE,HMPMAX,HMPI,HMPID,HMPERR,IEN
"RTN","HMPDJ2",10,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPDJ2",11,0)
 ;
"RTN","HMPDJ2",12,0)
 ; parse & validate input parameters
"RTN","HMPDJ2",13,0)
 S TYPE=$G(FILTER("collection")),TYPE=$$LOW^XLFSTR(TYPE)
"RTN","HMPDJ2",14,0)
 S HMPMAX=+$G(FILTER("max"),9999) ;??
"RTN","HMPDJ2",15,0)
 S HMPID=$G(FILTER("id"))
"RTN","HMPDJ2",16,0)
 ;
"RTN","HMPDJ2",17,0)
 ;set error trap
"RTN","HMPDJ2",18,0)
 N $ES,$ET,ERRARRY,ERRDOM,ERRPAT,ERRMSG
"RTN","HMPDJ2",19,0)
 ;S $ET="D ERRHDLR^HMPDERRH G ERRQ^HMPDJ0"
"RTN","HMPDJ2",20,0)
 S ERRDOM="hmp",ERRMSG=$G(TYPE)
"RTN","HMPDJ2",21,0)
 K ^TMP($J,"HMP ERROR")
"RTN","HMPDJ2",22,0)
 ;
"RTN","HMPDJ2",23,0)
 ; extract data
"RTN","HMPDJ2",24,0)
 I $L(HMPID) D  G GQ
"RTN","HMPDJ2",25,0)
 . S IEN=+HMPID I 'IEN S IEN=+$O(^HMP(800000.11,"B",HMPID,0)) ;IEN or UID
"RTN","HMPDJ2",26,0)
 . D:IEN HMP1^HMPDJ02(800000.11,IEN)
"RTN","HMPDJ2",27,0)
 I TYPE="" S HMPERR="Missing or invalid collection type" G GQ
"RTN","HMPDJ2",28,0)
 S IEN=0 F  S IEN=$O(^HMP(800000.11,"C",TYPE,IEN)) Q:IEN<1  D HMP1^HMPDJ02(800000.11,IEN)
"RTN","HMPDJ2",29,0)
 ;
"RTN","HMPDJ2",30,0)
GQ ;build return JSON
"RTN","HMPDJ2",31,0)
 D GTQ^HMPDJ
"RTN","HMPDJ2",32,0)
 Q
"RTN","HMPDJ2",33,0)
 ;
"RTN","HMPDJ2",34,0)
DEL(HMP,HMPID) ; -- Delete object HMPID from ^HMP(800000.11)
"RTN","HMPDJ2",35,0)
 ; RPC = HMP DELETE OBJECT
"RTN","HMPDJ2",36,0)
 ;
"RTN","HMPDJ2",37,0)
 N ACTION,ERR,UID,DA,DIK,TYPE
"RTN","HMPDJ2",38,0)
 S UID=$G(HMPID) I '$L(UID) S ERR=$$ERR(3,"null") G PTQ
"RTN","HMPDJ2",39,0)
 S DA=+$O(^HMP(800000.11,"B",UID,0)) I DA<1 S ERR=$$ERR(3,UID) G PTQ
"RTN","HMPDJ2",40,0)
 S DIK="^HMP(800000.11," D ^DIK
"RTN","HMPDJ2",41,0)
 S ACTION="@",TYPE=$P(UID,":",3)
"RTN","HMPDJ2",42,0)
 G PTQ
"RTN","HMPDJ2",43,0)
 Q
"RTN","HMPDJ2",44,0)
 ;
"RTN","HMPDJ2",45,0)
PUT(HMP,TYPE,JSON) ; -- Save/update JSON OBJECT in ^HMP(800000.11), return UID if successful
"RTN","HMPDJ2",46,0)
 ; RPC = HMP PUT OBJECT
"RTN","HMPDJ2",47,0)
 ;
"RTN","HMPDJ2",48,0)
 N ACTION,ARRAY,CNT,ERR,HMPERR,UID,DA,X,I,HMPSYS
"RTN","HMPDJ2",49,0)
 D DECODE^HMPJSON("JSON","ARRAY","HMPERR")
"RTN","HMPDJ2",50,0)
 ;N XCNT S XCNT=$O(^XTMP("AGPARRAY",""),-1),XCNT=XCNT+1
"RTN","HMPDJ2",51,0)
 ;M ^XTMP("AGPARRAY",XCNT,"DATA")=ARRAY
"RTN","HMPDJ2",52,0)
 ;S ^XTMP("AGPARRAY",XCNT,"TYPE")=TYPE
"RTN","HMPDJ2",53,0)
 I $D(HMPERR) D  Q  ;S X=$G(ERR(1)) K ERR S ERR=X G PTQ
"RTN","HMPDJ2",54,0)
 . K ARRAY N HMPTMP,HMPTXT
"RTN","HMPDJ2",55,0)
 . S HMPTXT(1)="Problem decoding json input."
"RTN","HMPDJ2",56,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.JSON)
"RTN","HMPDJ2",57,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","ARRAY","HMPERR")
"RTN","HMPDJ2",58,0)
 . S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPDJ2",59,0)
 . M HMP(1)=ARRAY
"RTN","HMPDJ2",60,0)
 . S HMP(2)="}}"
"RTN","HMPDJ2",61,0)
 ;
"RTN","HMPDJ2",62,0)
 S UID=$G(ARRAY("uid")),HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJ2",63,0)
 I $L(UID) S DA=+$O(^HMP(800000.11,"B",UID,0)) I DA<1 S ERR=$$ERR(3,UID) G PTQ
"RTN","HMPDJ2",64,0)
 ;I $L(UID) S DA=+$O(^HMP(800000.11,"B",UID,0)) I DA<1 D NEW1(UID)
"RTN","HMPDJ2",65,0)
 I '$L(UID) D  G:$D(ERR) PTQ Q:$D(HMPERR)
"RTN","HMPDJ2",66,0)
 . D NEW Q:$D(ERR)
"RTN","HMPDJ2",67,0)
 . S ARRAY("uid")=UID K JSON
"RTN","HMPDJ2",68,0)
 . D ENCODE^HMPJSON("ARRAY","JSON","HMPERR")
"RTN","HMPDJ2",69,0)
 . I $D(HMPERR) D  Q  ;S X=$G(ERR(1)) K ERR S ERR=X Q
"RTN","HMPDJ2",70,0)
 .. K JSON N HMPTMP,HMPTXT
"RTN","HMPDJ2",71,0)
 .. S HMPTXT(1)="Problem encoding json output."
"RTN","HMPDJ2",72,0)
 .. D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.ARRAY)
"RTN","HMPDJ2",73,0)
 .. K HMPERR D ENCODE^HMPJSON("HMPTMP","JSON","HMPERR")
"RTN","HMPDJ2",74,0)
 .. S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPDJ2",75,0)
 .. M HMP(1)=JSON
"RTN","HMPDJ2",76,0)
 .. S HMP(2)="}}"
"RTN","HMPDJ2",77,0)
 ;
"RTN","HMPDJ2",78,0)
 K ^HMP(800000.11,DA,1) S ^(1,0)="^800000.111^^",CNT=0
"RTN","HMPDJ2",79,0)
 S I="" F  S I=$O(JSON(I)) Q:I=""  S CNT=CNT+1,^HMP(800000.11,DA,1,CNT,0)=JSON(I)
"RTN","HMPDJ2",80,0)
 S:$G(CNT) ^HMP(800000.11,DA,1,0)="^800000.111^"_CNT_U_CNT
"RTN","HMPDJ2",81,0)
 ;
"RTN","HMPDJ2",82,0)
PTQ ; add item count and terminating characters
"RTN","HMPDJ2",83,0)
 I $D(ERR) S HMP="{""apiVersion"":""1.01"",""error"":{""message"":"""_ERR_"""},""success"":false}" Q
"RTN","HMPDJ2",84,0)
 S HMP="{""apiVersion"":""1.01"",""data"":{""updated"":"_""""_$$HL7NOW_""""_",""uid"":"""_UID_"""},""success"":true}"
"RTN","HMPDJ2",85,0)
 D POSTX^HMPEVNT(TYPE,DA,$G(ACTION)) ;UID)
"RTN","HMPDJ2",86,0)
 Q
"RTN","HMPDJ2",87,0)
 ;
"RTN","HMPDJ2",88,0)
NEW1(UID) ; -- create new entry in ^HMP(800000.11) from PAT,TYPE,HMPSYS
"RTN","HMPDJ2",89,0)
 ;  Return UID & DA, or ERR
"RTN","HMPDJ2",90,0)
 S TYPE=$G(TYPE)
"RTN","HMPDJ2",91,0)
 I TYPE="" S ERR=$$ERR(2,"null") Q
"RTN","HMPDJ2",92,0)
 ;
"RTN","HMPDJ2",93,0)
 S DA=$$NEXTIFN I DA<1 S ERR=$$ERR(4) Q
"RTN","HMPDJ2",94,0)
 S UID="urn:va:"_TYPE_":"_HMPSYS_":"_DA
"RTN","HMPDJ2",95,0)
 S ^HMP(800000.11,DA,0)=UID_U_U_TYPE
"RTN","HMPDJ2",96,0)
 S ^HMP(800000.11,"B",UID,DA)=""
"RTN","HMPDJ2",97,0)
 S ^HMP(800000.11,"C",TYPE,DA)=""
"RTN","HMPDJ2",98,0)
 Q
"RTN","HMPDJ2",99,0)
 ;
"RTN","HMPDJ2",100,0)
NEW ; -- create new entry in ^HMP(800000.11) from PAT,TYPE,HMPSYS
"RTN","HMPDJ2",101,0)
 ;  Return UID & DA, or ERR
"RTN","HMPDJ2",102,0)
 S TYPE=$G(TYPE)
"RTN","HMPDJ2",103,0)
 I TYPE="" S ERR=$$ERR(2,"null") Q
"RTN","HMPDJ2",104,0)
 ;
"RTN","HMPDJ2",105,0)
 S DA=$$NEXTIFN I DA<1 S ERR=$$ERR(4) Q
"RTN","HMPDJ2",106,0)
 S UID="urn:va:"_TYPE_":"_HMPSYS_":"_DA
"RTN","HMPDJ2",107,0)
 S ^HMP(800000.11,DA,0)=UID_U_U_TYPE
"RTN","HMPDJ2",108,0)
 S ^HMP(800000.11,"B",UID,DA)=""
"RTN","HMPDJ2",109,0)
 S ^HMP(800000.11,"C",TYPE,DA)=""
"RTN","HMPDJ2",110,0)
 Q
"RTN","HMPDJ2",111,0)
 ;
"RTN","HMPDJ2",112,0)
NEXTIFN() ; -- Returns next available IFN
"RTN","HMPDJ2",113,0)
 N I,HDR,TOTAL,DA
"RTN","HMPDJ2",114,0)
 L +^HMP(800000.11,0):$S($G(DILOCKTM)>0:DILOCKTM,1:5)
"RTN","HMPDJ2",115,0)
 I '$T Q "^"
"RTN","HMPDJ2",116,0)
 S HDR=$G(^HMP(800000.11,0)),TOTAL=+$P(HDR,U,4),I=$O(^HMP(800000.11,"?"),-1)
"RTN","HMPDJ2",117,0)
 F I=(I+1):1 Q:'$D(^HMP(800000.11,I,0))
"RTN","HMPDJ2",118,0)
 S DA=I,$P(HDR,U,3,4)=DA_U_(TOTAL+1) S ^HMP(800000.11,0)=HDR
"RTN","HMPDJ2",119,0)
 L -^HMP(800000.11,0)
"RTN","HMPDJ2",120,0)
 Q DA
"RTN","HMPDJ2",121,0)
 ;
"RTN","HMPDJ2",122,0)
ERR(X,VAL) ; -- return error message
"RTN","HMPDJ2",123,0)
 N MSG  S MSG="Error"
"RTN","HMPDJ2",124,0)
 I X=1  S MSG="Patient with dfn '"_$G(VAL)_"' not found"
"RTN","HMPDJ2",125,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPDJ2",126,0)
 I X=3  S MSG="UID '"_$G(VAL)_"' not found"
"RTN","HMPDJ2",127,0)
 I X=4  S MSG="Unable to create new object"
"RTN","HMPDJ2",128,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPDJ2",129,0)
 Q MSG
"RTN","HMPDJ2",130,0)
 ;
"RTN","HMPDJ2",131,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPDJ2",132,0)
 Q $P($$FMTHL7^XLFDT($$NOW^XLFDT),"-")
"RTN","HMPDJFS")
0^36^B72336462^B74871558
"RTN","HMPDJFS",1,0)
HMPDJFS ;SLC/KCM,ASMR/RRB,CK -- Asynchronous Extracts and Freshness via stream;May 15, 2016 14:15
"RTN","HMPDJFS",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJFS",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFS",4,0)
 ;
"RTN","HMPDJFS",5,0)
 ; JD - 1/14/15 - Removed "+" from "$$GETICN^MPIF001(DFN)" so that the
"RTN","HMPDJFS",6,0)
 ;                full value of icn (<icn>V<checksum>) could be captured. US4194.
"RTN","HMPDJFS",7,0)
 ; JD - 3/16/15 - Added checks to prevent restaging of data if the data has
"RTN","HMPDJFS",8,0)
 ;                already been staged.  US4304
"RTN","HMPDJFS",9,0)
 ; CPC - 3/4/16 - Prevent dual execution. DE3411
"RTN","HMPDJFS",10,0)
 ;
"RTN","HMPDJFS",11,0)
 ; PUT/POST   call $$TAG^ROUTINE(.args,.body)
"RTN","HMPDJFS",12,0)
 ; GET/DELETE call   TAG^ROUTINE(.response,.args)
"RTN","HMPDJFS",13,0)
 ;
"RTN","HMPDJFS",14,0)
 Q
"RTN","HMPDJFS",15,0)
 ;
"RTN","HMPDJFS",16,0)
API(HMPFRSP,ARGS) ;
"RTN","HMPDJFS",17,0)
 N HMPFERR,HMPFHMP,HMPFLOG,CNT,ACNT
"RTN","HMPDJFS",18,0)
 K ^TMP("HMPF",$J)
"RTN","HMPDJFS",19,0)
 S HMPFHMP=$TR($G(ARGS("server")),"~","=")
"RTN","HMPDJFS",20,0)
 S HMPFRSP=$NA(^TMP("HMPF",$J))
"RTN","HMPDJFS",21,0)
 S HMPFLOG=+$$GET^XPAR("ALL","HMP LOG LEVEL")
"RTN","HMPDJFS",22,0)
 I HMPFLOG D LOGREQ(HMPFHMP,.ARGS)
"RTN","HMPDJFS",23,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJFS",24,0)
 I '$L(HMPFHMP) D SETERR("Missing HMP Server ID") QUIT
"RTN","HMPDJFS",25,0)
 I '$O(^HMP(800000,"B",HMPFHMP,0)) D SETERR("HMP Server not registered") QUIT
"RTN","HMPDJFS",26,0)
 ;
"RTN","HMPDJFS",27,0)
 ; begin select case
"RTN","HMPDJFS",28,0)
 I ARGS("command")="putPtSubscription" D  G XAPI
"RTN","HMPDJFS",29,0)
 . N LOC
"RTN","HMPDJFS",30,0)
 . S LOC=$$PUTSUB^HMPDJFSP(.ARGS) ; Added ELSE for US4304
"RTN","HMPDJFS",31,0)
 . I $L(LOC) S ^TMP("HMPF",$J,1)="{""apiVersion"":""1.0"",""location"":"""_LOC_""""_$$PROGRESS_"}"
"RTN","HMPDJFS",32,0)
 I ARGS("command")="startOperationalDataExtract" D  G XAPI
"RTN","HMPDJFS",33,0)
 . N HMPX2,LOC
"RTN","HMPDJFS",34,0)
 . S ARGS("localId")="OPD"  ; use OPD to indicate "sync operational"
"RTN","HMPDJFS",35,0)
 . ; Next 2 lines added for US4304
"RTN","HMPDJFS",36,0)
 . S HMPX2="HMPFX~"_$G(HMPFHMP)_"~OPD"
"RTN","HMPDJFS",37,0)
 . I $D(^XTMP(HMPX2)) S LOC="/hmp/subscription/operational data/"
"RTN","HMPDJFS",38,0)
 . E  S LOC=$$PUTSUB^HMPDJFSP(.ARGS) ; Added ELSE for US4304
"RTN","HMPDJFS",39,0)
 . I $L(LOC) S ^TMP("HMPF",$J,1)="{""apiVersion"":""1.0"",""location"":"""_LOC_"""}"
"RTN","HMPDJFS",40,0)
 I ARGS("command")="getPtUpdates" D  G XAPI
"RTN","HMPDJFS",41,0)
 . L +^TMP("HMPDJFSG "_$G(HMPFHMP)):2 E  D SETERR^HMPDJFS("Only one extract can run for a single server") Q  ;DE3411
"RTN","HMPDJFS",42,0)
 . D GETSUB^HMPDJFSG(HMPFRSP,.ARGS)
"RTN","HMPDJFS",43,0)
 . L -^TMP("HMPDJFSG "_$G(HMPFHMP)) ;DE3411
"RTN","HMPDJFS",44,0)
 I ARGS("command")="resetAllSubscriptions" D  G XAPI
"RTN","HMPDJFS",45,0)
 . D RESETSVR(.ARGS)
"RTN","HMPDJFS",46,0)
 . S ^TMP("HMPF",$J,1)="{""apiVersion"":""1.0"",""removed"":""true""}"
"RTN","HMPDJFS",47,0)
 I ARGS("command")="checkHealth" D  G XAPI
"RTN","HMPDJFS",48,0)
 . D HLTHCHK^HMPDJFSM(.ARGS)
"RTN","HMPDJFS",49,0)
 ; else
"RTN","HMPDJFS",50,0)
 D SETERR("command not recognized")  ; should not get this far
"RTN","HMPDJFS",51,0)
 ;
"RTN","HMPDJFS",52,0)
XAPI ; end select case
"RTN","HMPDJFS",53,0)
 ;
"RTN","HMPDJFS",54,0)
 I HMPFLOG=2 D LOGRSP(HMPFHMP)
"RTN","HMPDJFS",55,0)
 Q
"RTN","HMPDJFS",56,0)
 ;
"RTN","HMPDJFS",57,0)
LOGREQ(SRV,ARGS) ; Log the request
"RTN","HMPDJFS",58,0)
 I $D(^XTMP("HMPFLOG",0,"start")) D  Q:'$$GET^XPAR("ALL","HMP LOG LEVEL")
"RTN","HMPDJFS",59,0)
 . N ELAPSED S ELAPSED=$$HDIFF^XLFDT($H,^XTMP("HMPFLOG",0,"start"),2)
"RTN","HMPDJFS",60,0)
 . I ELAPSED>$$GET^XPAR("ALL","HMP LOG LIMIT") D PUT^XPAR("SYS","HMP LOG LEVEL",1,0)
"RTN","HMPDJFS",61,0)
 E  D
"RTN","HMPDJFS",62,0)
 . D NEWXTMP("HMPFLOG",1,"HMP Freshness Logging")
"RTN","HMPDJFS",63,0)
 . S ^XTMP("HMPFLOG",0,"start")=$H
"RTN","HMPDJFS",64,0)
 S ^XTMP("HMPFLOG",0,"total")=$G(^XTMP("HMPFLOG",0,"total"))+1
"RTN","HMPDJFS",65,0)
 S:'$L(SRV) SRV="unknown"
"RTN","HMPDJFS",66,0)
 N SEQ
"RTN","HMPDJFS",67,0)
 S SEQ=+$G(^XTMP("HMPFLOG",SRV))+1,^XTMP("HMPFLOG",SRV)=SEQ
"RTN","HMPDJFS",68,0)
 M ^XTMP("HMPFLOG",SRV,SEQ,"request")=ARGS
"RTN","HMPDJFS",69,0)
 S HMPFLOG("seq")=SEQ
"RTN","HMPDJFS",70,0)
 Q
"RTN","HMPDJFS",71,0)
LOGRSP(SRV) ; Log the response
"RTN","HMPDJFS",72,0)
 M ^XTMP("HMPFLOG",SRV,HMPFLOG("seq"),"response")=^TMP("HMPF",$J)
"RTN","HMPDJFS",73,0)
 Q
"RTN","HMPDJFS",74,0)
 ;
"RTN","HMPDJFS",75,0)
 ; delete a patient subscription
"RTN","HMPDJFS",76,0)
DELSUB(RSP,ARGS) ; cancel a subscription
"RTN","HMPDJFS",77,0)
 ; DELETE with: /hmp/subscription/{hmpSrvId}/patient/{pid}
"RTN","HMPDJFS",78,0)
 ; remove patient from HMP SUBSCRIPTION file
"RTN","HMPDJFS",79,0)
 ; remove ^XTMP(HMPX and ^XTMP(HMPH nodes
"RTN","HMPDJFS",80,0)
 ; look ahead (from lastId) and remove any nodes for the patient
"RTN","HMPDJFS",81,0)
 N DFN,HMPSRV,BATCH,HMPSRVID
"RTN","HMPDJFS",82,0)
 K ^TMP("HMPF",$J)
"RTN","HMPDJFS",83,0)
 S DFN=$$DFN(ARGS("pid")) Q:$D(HMPFERR)
"RTN","HMPDJFS",84,0)
 S HMPSRV=ARGS("hmpSrvId")
"RTN","HMPDJFS",85,0)
 S BATCH="HMPFX~"_HMPSRV_"~"_DFN
"RTN","HMPDJFS",86,0)
 L +^XTMP("HMPFP",DFN,HMPSRV):20 E  D SETERR("unable to get lock") Q
"RTN","HMPDJFS",87,0)
 ; if extract still running, it should remove itself when it finishes
"RTN","HMPDJFS",88,0)
 K ^XTMP("HMPFX~"_HMPSRV_"~"_DFN) ; kill extract nodes
"RTN","HMPDJFS",89,0)
 K ^XTMP("HMPFH~"_HMPSRV_"~"_DFN) ; kill held freshness updates
"RTN","HMPDJFS",90,0)
 ; remove all nodes for this patient between "last" and "next"
"RTN","HMPDJFS",91,0)
 ; loop forward from "last" in ^XTMP("HMPFP",0,hmpSrv) and remove nodes for this DFN
"RTN","HMPDJFS",92,0)
 K ^XTMP("HMPFP",DFN,HMPSRV)      ; kill subscription
"RTN","HMPDJFS",93,0)
 D DELPT(DFN,HMPSRV)
"RTN","HMPDJFS",94,0)
 L -^XTMP("HMPFP",DFN,HMPSRV)
"RTN","HMPDJFS",95,0)
 S RSP="{""apiVersion"":""1.0"",""success"":""true""}" ; if successful
"RTN","HMPDJFS",96,0)
 Q
"RTN","HMPDJFS",97,0)
DELPT(DFN,SRV) ; delete patient DFN for server SRV
"RTN","HMPDJFS",98,0)
 N DIK,DA
"RTN","HMPDJFS",99,0)
 S DA(1)=$O(^HMP(800000,"B",SRV,"")) Q:'DA(1)
"RTN","HMPDJFS",100,0)
 S DA=DFN Q:'DA
"RTN","HMPDJFS",101,0)
 S DIK="^HMP(800000,"_DA(1)_",1,"
"RTN","HMPDJFS",102,0)
 D ^DIK
"RTN","HMPDJFS",103,0)
 Q
"RTN","HMPDJFS",104,0)
 ;
"RTN","HMPDJFS",105,0)
 ; --- post freshness updates (internal to VistA)
"RTN","HMPDJFS",106,0)
 ;
"RTN","HMPDJFS",107,0)
POST(DFN,TYPE,ID,ACT,SERVER,NODES) ; adds new freshness item, return DT-seq
"RTN","HMPDJFS",108,0)
 ; if initializing use: ^XTMP("HMPFH-hmpserverid-dfn",seq#)    -hold
"RTN","HMPDJFS",109,0)
 ;       otherwise use: ^XTMP("HMPFS-hmpserverid-date",seq#)   -stream
"RTN","HMPDJFS",110,0)
 ;
"RTN","HMPDJFS",111,0)
 ; loop through subscribing streams for this patient
"RTN","HMPDJFS",112,0)
 ; if patient is initialized for an hmp server send events directly to stream
"RTN","HMPDJFS",113,0)
 ; otherwise, events go to temporary holding area
"RTN","HMPDJFS",114,0)
 ; initial extracts always sent directly to stream
"RTN","HMPDJFS",115,0)
 N HMPSRV,INIT,STREAM,DATE,SEQ,CNT
"RTN","HMPDJFS",116,0)
 S DATE=$$DT^XLFDT
"RTN","HMPDJFS",117,0)
 S HMPSRV="" F  S HMPSRV=$O(^HMP(800000,"AITEM",DFN,HMPSRV)) Q:'$L(HMPSRV)  D
"RTN","HMPDJFS",118,0)
 . I SERVER'="",HMPSRV'=SERVER Q
"RTN","HMPDJFS",119,0)
 . I '$D(^HMP(800000,"AITEM",DFN,HMPSRV)) Q          ; patient not subscribed
"RTN","HMPDJFS",120,0)
 . S INIT=(^HMP(800000,"AITEM",DFN,HMPSRV)=2),CNT=1  ; 2 means patient initialized
"RTN","HMPDJFS",121,0)
 . I $E(TYPE,1,4)="sync" S INIT=1                 ; sync* goes to main stream
"RTN","HMPDJFS",122,0)
 . I TYPE="syncDomain" S CNT=+$P(ID,":",3) S:CNT<1 CNT=1 ; CNT must be >0
"RTN","HMPDJFS",123,0)
 . S STREAM=$S(INIT:"HMPFS~",1:"HMPFH~")_HMPSRV_"~"_$S(INIT:DATE,1:DFN)
"RTN","HMPDJFS",124,0)
 . I '$D(^XTMP(STREAM)) D NEWXTMP(STREAM,8,"HMP Freshness Stream")
"RTN","HMPDJFS",125,0)
 . L +^XTMP(STREAM):5 E  S $EC=",Uno lock obtained," Q  ; throw error
"RTN","HMPDJFS",126,0)
 . S SEQ=$G(^XTMP(STREAM,"last"),0)+CNT
"RTN","HMPDJFS",127,0)
 . S ^XTMP(STREAM,SEQ)=DFN_U_TYPE_U_ID_U_$G(ACT)_U_$P($H,",",2)
"RTN","HMPDJFS",128,0)
 . S ^XTMP(STREAM,"last")=SEQ
"RTN","HMPDJFS",129,0)
 . L -^XTMP(STREAM)
"RTN","HMPDJFS",130,0)
 . ; NODES(hmpserverid)=streamDate^sequence -- optionally returned
"RTN","HMPDJFS",131,0)
 . S NODES($P(STREAM,"~",2))=$S(INIT:DATE,1:0)_U_SEQ
"RTN","HMPDJFS",132,0)
 Q
"RTN","HMPDJFS",133,0)
 ;
"RTN","HMPDJFS",134,0)
NEWXTMP(NODE,DAYS,DESC) ; Set a new node in ^XTMP
"RTN","HMPDJFS",135,0)
 K ^XTMP(NODE)
"RTN","HMPDJFS",136,0)
 S ^XTMP(NODE,0)=$$HTFM^XLFDT(+$H+DAYS)_U_$$HTFM^XLFDT(+$H)_U_DESC
"RTN","HMPDJFS",137,0)
 Q
"RTN","HMPDJFS",138,0)
PIDS(DFN) ; return string containing patient id's ready for JSON
"RTN","HMPDJFS",139,0)
 ; expects HMPFSYS, HMPFHMP
"RTN","HMPDJFS",140,0)
 Q:'DFN ""
"RTN","HMPDJFS",141,0)
 ;
"RTN","HMPDJFS",142,0)
 N X
"RTN","HMPDJFS",143,0)
 S X=",""pid"":"""_$$PID(DFN)_""""
"RTN","HMPDJFS",144,0)
 S X=X_",""systemId"":"""_HMPSYS_""""
"RTN","HMPDJFS",145,0)
 S X=X_",""localId"":"""_DFN_""""
"RTN","HMPDJFS",146,0)
 S X=X_",""icn"":"""_$$GETICN^MPIF001(DFN)_"""" ; US4194
"RTN","HMPDJFS",147,0)
 Q X
"RTN","HMPDJFS",148,0)
 ;
"RTN","HMPDJFS",149,0)
PID(DFN) ; return most likely PID (ICN or SYS;DFN)
"RTN","HMPDJFS",150,0)
 Q:'DFN ""
"RTN","HMPDJFS",151,0)
 I '$D(HMPSYS) S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJFS",152,0)
 Q HMPSYS_";"_DFN            ; otherwise use SysId;DFN
"RTN","HMPDJFS",153,0)
 ;
"RTN","HMPDJFS",154,0)
DFN(PID) ; return the DFN given the PID (ICN or SYS;DFN)
"RTN","HMPDJFS",155,0)
 N DFN
"RTN","HMPDJFS",156,0)
 S PID=$TR(PID,":",";")
"RTN","HMPDJFS",157,0)
 I PID'[";" D  Q DFN  ; treat as ICN
"RTN","HMPDJFS",158,0)
 . S DFN=$$GETDFN^MPIF001(PID)
"RTN","HMPDJFS",159,0)
 . I DFN<0 D SETERR($P(DFN,"^",2))
"RTN","HMPDJFS",160,0)
 ; otherwise
"RTN","HMPDJFS",161,0)
 I $P(PID,";")'=$$SYS^HMPUTILS D SETERR("DFN unknown to this system") Q 0
"RTN","HMPDJFS",162,0)
 Q $P(PID,";",2)
"RTN","HMPDJFS",163,0)
 ;
"RTN","HMPDJFS",164,0)
PROGRESS(LASTITM) ; set the node in REF with progress properties
"RTN","HMPDJFS",165,0)
 ; expects HMPFHMP,HMPSYS
"RTN","HMPDJFS",166,0)
 N RSLT,HMPIEN,CNT,STS,TS,DFN,FIRST
"RTN","HMPDJFS",167,0)
 S HMPIEN=$O(^HMP(800000,"B",HMPFHMP,0)) Q:'HMPIEN ""
"RTN","HMPDJFS",168,0)
 S CNT=0,RSLT=""
"RTN","HMPDJFS",169,0)
 F STS=0,1 D  ; 0=uninitialized, 1=initializing
"RTN","HMPDJFS",170,0)
 . S FIRST=1
"RTN","HMPDJFS",171,0)
 . S RSLT=$S(STS=0:",""waitingPids"":[",1:RSLT_"],""processingPids"":[")
"RTN","HMPDJFS",172,0)
 . S TS=0 F  S TS=$O(^HMP(800000,HMPIEN,1,"AP",STS,TS)) Q:'TS  D  Q:CNT>99
"RTN","HMPDJFS",173,0)
 . . S DFN=0 F  S DFN=$O(^HMP(800000,HMPIEN,1,"AP",STS,TS,DFN)) Q:'DFN  D
"RTN","HMPDJFS",174,0)
 . . . S CNT=CNT+1
"RTN","HMPDJFS",175,0)
 . . . S RSLT=RSLT_$S(FIRST=1:"",1:",")_""""_HMPSYS_";"_DFN_""""
"RTN","HMPDJFS",176,0)
 . . . S FIRST=0
"RTN","HMPDJFS",177,0)
 S RSLT=RSLT_"]"
"RTN","HMPDJFS",178,0)
 ;
"RTN","HMPDJFS",179,0)
 N STRM,STRMDT,CURRDT
"RTN","HMPDJFS",180,0)
 I $G(LASTITM)="" S LASTITM=$P(^HMP(800000,HMPIEN,0),U,2)
"RTN","HMPDJFS",181,0)
 I $L(LASTITM,"-")<2 S LASTITM=$$DT^XLFDT_"-"_+LASTITM
"RTN","HMPDJFS",182,0)
 S STRMDT=$P(LASTITM,"-"),CURRDT=$$DT^XLFDT,SEQ=$P(LASTITM,"-",2)
"RTN","HMPDJFS",183,0)
 S CNT=0 F  D  Q:$$FMDIFF^XLFDT(STRMDT,CURRDT,1)'<0
"RTN","HMPDJFS",184,0)
 . S STRM="HMPFS~"_HMPFHMP_"~"_STRMDT
"RTN","HMPDJFS",185,0)
 . S CNT=CNT+$G(^XTMP(STRM,"last"))-SEQ
"RTN","HMPDJFS",186,0)
 . S STRMDT=$$FMADD^XLFDT(STRMDT,1),SEQ=0
"RTN","HMPDJFS",187,0)
 S RSLT=RSLT_",""remainingObjects"":"_CNT
"RTN","HMPDJFS",188,0)
 Q RSLT
"RTN","HMPDJFS",189,0)
 ;
"RTN","HMPDJFS",190,0)
 ; --- handle errors
"RTN","HMPDJFS",191,0)
 ;
"RTN","HMPDJFS",192,0)
SETERR(MSG) ; create error object in ^TMP("HMPFERR",$J) and set HMPFERR
"RTN","HMPDJFS",193,0)
 ; TODO: escape MSG for JSON
"RTN","HMPDJFS",194,0)
 S @HMPFRSP@(1)="{""apiVersion"":""1.0"",""error"":{""message"":"""_MSG_"""}}"
"RTN","HMPDJFS",195,0)
 S ^TMP("HMPFERR",$J,$H)=MSG
"RTN","HMPDJFS",196,0)
 S HMPFERR=1
"RTN","HMPDJFS",197,0)
 Q
"RTN","HMPDJFS",198,0)
 ;
"RTN","HMPDJFS",199,0)
DEBUG(MSG) ;
"RTN","HMPDJFS",200,0)
 S ^TMP("HMPDEBUG",$J,0)=$G(^TMP("HMPDEBUG",$J,0),0)+1
"RTN","HMPDJFS",201,0)
 I $D(MSG)'=1 M ^TMP("HMPDEBUG",$J,^TMP("HMPDEBUG",$J,0))=MSG Q
"RTN","HMPDJFS",202,0)
 S ^TMP("HMPDEBUG",$J,^TMP("HMPDEBUG",$J,0))=MSG
"RTN","HMPDJFS",203,0)
 Q
"RTN","HMPDJFS",204,0)
RESETSVR(ARGS) ;
"RTN","HMPDJFS",205,0)
 N DA,DIE,DIK,DR,IEN,SRV,SRVIEN,X
"RTN","HMPDJFS",206,0)
 S SRV=$G(ARGS("server")) I SRV="" Q
"RTN","HMPDJFS",207,0)
 S DA=$O(^HMP(800000,"B",SRV,"")) I DA'>0 Q
"RTN","HMPDJFS",208,0)
 S SRVIEN=DA
"RTN","HMPDJFS",209,0)
 L +^HMP(800000,SRVIEN):5 E  S $EC=",Uno lock obtained," Q
"RTN","HMPDJFS",210,0)
 ;delete operational data field
"RTN","HMPDJFS",211,0)
 S DIE="^HMP(800000,",DR=".03///@" D ^DIE
"RTN","HMPDJFS",212,0)
 S DA(1)=DA,DA=0
"RTN","HMPDJFS",213,0)
 ;delete patient multiple values
"RTN","HMPDJFS",214,0)
 S DIK="^HMP(800000,"_DA(1)_",1,"
"RTN","HMPDJFS",215,0)
 F  S DA=$O(^HMP(800000,DA(1),1,DA)) Q:DA'>0  D ^DIK
"RTN","HMPDJFS",216,0)
 ;kill server ^XTMP
"RTN","HMPDJFS",217,0)
 S X="HMPF" F  S X=$O(^XTMP(X)) Q:$E(X,1,4)'="HMPF"  D
"RTN","HMPDJFS",218,0)
 . I X[SRV K ^XTMP(X) I 1
"RTN","HMPDJFS",219,0)
 ;kill tidy node
"RTN","HMPDJFS",220,0)
 K ^XTMP("HMPFP","tidy",SRV)
"RTN","HMPDJFS",221,0)
 L -^HMP(800000,SRVIEN)
"RTN","HMPDJFS",222,0)
 Q
"RTN","HMPDJFS",223,0)
 ;
"RTN","HMPDJFS",224,0)
CLEARDOM(SVR,PAT) ;
"RTN","HMPDJFS",225,0)
 Q
"RTN","HMPDJFS",226,0)
 ;
"RTN","HMPDJFS",227,0)
CLEARPAT(SVR,PAT) ;
"RTN","HMPDJFS",228,0)
 I '$D(^XTMP("HMPFP",PAT,SVR)) Q
"RTN","HMPDJFS",229,0)
 ;do we need a check for patient initialized?
"RTN","HMPDJFS",230,0)
 K ^XTMP("HMPFP",PAT,SVR)
"RTN","HMPDJFS",231,0)
 Q
"RTN","HMPDJFS",232,0)
 ;
"RTN","HMPDJFS",233,0)
HMPSET(DA,NEW) ;
"RTN","HMPDJFS",234,0)
 N IEN,NAME
"RTN","HMPDJFS",235,0)
 S IEN=0 F  S IEN=$O(^HMP(800000,IEN)) Q:IEN'>0  D
"RTN","HMPDJFS",236,0)
 .S NAME=$P(^HMP(800000,IEN,0),U)
"RTN","HMPDJFS",237,0)
 .I $D(^HMP(800000,IEN,1,NEW(1)))>0 S ^HMP(800000,"AITEM",NEW(1),NAME)=NEW(2)
"RTN","HMPDJFS",238,0)
 Q
"RTN","HMPDJFS",239,0)
 ;
"RTN","HMPDJFS",240,0)
HMPKILL(DA,OLD) ;
"RTN","HMPDJFS",241,0)
 N NAME
"RTN","HMPDJFS",242,0)
 S NAME=$P($G(^HMP(800000,DA(1),0)),U) I NAME="" Q
"RTN","HMPDJFS",243,0)
 K ^HMP(800000,"AITEM",OLD(1),NAME)
"RTN","HMPDJFS",244,0)
 Q
"RTN","HMPDJFS",245,0)
 ;
"RTN","HMPDJFS",246,0)
HMPOSET(DA,NEW) ;
"RTN","HMPDJFS",247,0)
 N IEN,NAME
"RTN","HMPDJFS",248,0)
 S IEN=0 F  S IEN=$O(^HMP(800000,IEN)) Q:IEN'>0  D
"RTN","HMPDJFS",249,0)
 .S NAME=$P(^HMP(800000,IEN,0),U)
"RTN","HMPDJFS",250,0)
 .S ^HMP(800000,"AITEM","OPD",NAME)=NEW
"RTN","HMPDJFS",251,0)
 Q
"RTN","HMPDJFS",252,0)
 ;
"RTN","HMPDJFS",253,0)
HMPOKILL(DA) ;
"RTN","HMPDJFS",254,0)
 N NAME
"RTN","HMPDJFS",255,0)
 S NAME=$P($G(^HMP(800000,DA,0)),U) I NAME="" Q
"RTN","HMPDJFS",256,0)
 K ^HMP(800000,"AITEM","OPD",NAME)
"RTN","HMPDJFS",257,0)
 Q
"RTN","HMPDJFS",258,0)
KILL ; clear out all ^XTMP nodes
"RTN","HMPDJFS",259,0)
 N X
"RTN","HMPDJFS",260,0)
 S X="HMPF" F  S X=$O(^XTMP(X)) Q:$E(X,1,4)'="HMPF"  W !,X  K ^XTMP(X)
"RTN","HMPDJFS",261,0)
 Q
"RTN","HMPDJFS",262,0)
KILLSVR(SVR) ; clear out for specific machine
"RTN","HMPDJFS",263,0)
 N X
"RTN","HMPDJFS",264,0)
 S X="HMPF" F  S X=$O(^XTMP(X)) Q:$E(X,1,4)'="HMPF"  D
"RTN","HMPDJFS",265,0)
 . I X[SVR W !,X  K ^XTMP(X) I 1
"RTN","HMPDJFS",266,0)
 S X="" F  S X=$O(^XTMP("HMPFP",X)) Q:X=""  D
"RTN","HMPDJFS",267,0)
 . I $D(^XTMP("HMPFP",X,SVR)) K ^XTMP("HMPFP",X,SVR)
"RTN","HMPDJFS",268,0)
 Q
"RTN","HMPDJFSG")
0^39^B236965209^B216382035
"RTN","HMPDJFSG",1,0)
HMPDJFSG ;SLC/KCM,ASMR/RRB,CPC,JD,ASF,CK -- GET for Extract and Freshness Stream;May 15, 2016 14:15
"RTN","HMPDJFSG",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJFSG",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFSG",4,0)
 ;
"RTN","HMPDJFSG",5,0)
 ; US3907 - Allow for jobId and rootJobId to be retrieved from ^XTMP.  JD - 1/20/15
"RTN","HMPDJFSG",6,0)
 ; DE2818 - SQA findings. Newed ERRCNT in BLDSERR+2.  RRB - 10/24/2015
"RTN","HMPDJFSG",7,0)
 ; DE3869 - Remove the freshness stream entries with undefined DFNs.  JD - 3/4/16
"RTN","HMPDJFSG",8,0)
 ;
"RTN","HMPDJFSG",9,0)
 ; --- retrieve updates for an HMP server's subscriptions
"RTN","HMPDJFSG",10,0)
 ;
"RTN","HMPDJFSG",11,0)
GETSUB(HMPFRSP,ARGS) ; retrieve items from stream
"RTN","HMPDJFSG",12,0)
 ;      GET from: /hmp/subscription/{hmpSrvId}/{last}?limit={limit}
"RTN","HMPDJFSG",13,0)
 ; ARGS("last") : date-seq of last item retrieved (ex. 3131206-27)
"RTN","HMPDJFSG",14,0)
 ; ARGS("max")    : maximum number of items to return (default 99999)   *S68-JCH*
"RTN","HMPDJFSG",15,0)
 ; ARGS("maxSize"): approximate number bytes to return                  *S68-JCH*
"RTN","HMPDJFSG",16,0)
 ;
"RTN","HMPDJFSG",17,0)
 ; HMPFSYS : the id (hash) of the VistA system
"RTN","HMPDJFSG",18,0)
 ; HMPFHMP : the name of the HMP server 
"RTN","HMPDJFSG",19,0)
 ; HMPFSEQ : final sequence (becomes next LASTSEQ)
"RTN","HMPDJFSG",20,0)
 ; HMPFIDX : index to iterate from LASTSEQ to final sequence
"RTN","HMPDJFSG",21,0)
 ; HMPFLAST: used to clean up extracts prior to this
"RTN","HMPDJFSG",22,0)
 ; HMPFSTRM: the extract/freshness stream (HMPFS~hmpSrvId~fmDate) 
"RTN","HMPDJFSG",23,0)
 ; (most variables namespaced since calling variety of extracts)
"RTN","HMPDJFSG",24,0)
 ;
"RTN","HMPDJFSG",25,0)
 K ^TMP("HMPF",$J)
"RTN","HMPDJFSG",26,0)
 N HMPFSYS,HMPFSTRM,HMPFLAST,HMPFDT,HMPFLIM,HMPFMAX,HMPFSIZE,HMPCLFLG
"RTN","HMPDJFSG",27,0)
 N HMPFSEQ,HMPFIDX,HMPFCNT,SNODE,STYPE,HMPFERR,HMPDEL,HMPERR,HMPSTGET,HMPLITEM  ;*S68-JCH*, DE3502
"RTN","HMPDJFSG",28,0)
 S HMPFRSP=$NA(^TMP("HMPF",$J))
"RTN","HMPDJFSG",29,0)
 ; Next line added for US6734 - Make sure OPD metastamp data has been completed before fetching.
"RTN","HMPDJFSG",30,0)
 I '$$OPD^HMPMETA(HMPFHMP) S @HMPFRSP@(1)="{""warning"":""Staging is not complete yet!""}" Q
"RTN","HMPDJFSG",31,0)
 ;
"RTN","HMPDJFSG",32,0)
 S HMPFSYS=$$SYS^HMPUTILS
"RTN","HMPDJFSG",33,0)
 S HMPFHMP("ien")=$O(^HMP(800000,"B",HMPFHMP,0))
"RTN","HMPDJFSG",34,0)
 S HMPFDT=$P($G(ARGS("lastUpdate")),"-")
"RTN","HMPDJFSG",35,0)
 S HMPFSEQ=+$P($G(ARGS("lastUpdate")),"-",2)
"RTN","HMPDJFSG",36,0)
 S HMPSTGET=$G(ARGS("getStatus"))
"RTN","HMPDJFSG",37,0)
 S HMPLITEM="" ; DE3502 initialise tracking of last item type
"RTN","HMPDJFSG",38,0)
 ; stream goes back a maximum of 8 days
"RTN","HMPDJFSG",39,0)
 I HMPFDT<$$FMADD^XLFDT($$DT^XLFDT,-8) S HMPFDT=$$HTFM^XLFDT(+$H-8),HMPFSEQ=0
"RTN","HMPDJFSG",40,0)
 S HMPFLAST=HMPFDT_"-"_HMPFSEQ
"RTN","HMPDJFSG",41,0)
 D LASTUPD(HMPFHMP,HMPFLAST)
"RTN","HMPDJFSG",42,0)
 D SETLIMIT(.ARGS)                            ; set HMPFLIM, HMPFMAX, HMPFSIZE ;*S68-PJH*
"RTN","HMPDJFSG",43,0)
 S HMPFLIM=$G(ARGS("max"),99999)
"RTN","HMPDJFSG",44,0)
 S HMPFSTRM="HMPFS~"_HMPFHMP_"~"_HMPFDT       ; stream identifier
"RTN","HMPDJFSG",45,0)
 I '$D(^XTMP(HMPFSTRM,"job",$J)) S ^XTMP(HMPFSTRM,"job",$J,"start")=$H
"RTN","HMPDJFSG",46,0)
 S ^XTMP(HMPFSTRM,"job",$J)=$H                ; record connection info
"RTN","HMPDJFSG",47,0)
 I '$$VERMATCH(HMPFHMP("ien"),$G(ARGS("extractSchema"))) D NOOP(HMPFLAST) QUIT
"RTN","HMPDJFSG",48,0)
 S HMPFCNT=0,HMPFIDX=HMPFSEQ
"RTN","HMPDJFSG",49,0)
 F  D  Q:HMPFSIZE'<HMPFMAX  D NXTSTRM Q:HMPFSTRM=""  ; *S68-JCH*
"RTN","HMPDJFSG",50,0)
 . F  S HMPFIDX=$O(^XTMP(HMPFSTRM,HMPFIDX)) Q:'HMPFIDX  D  Q:HMPFCNT'<HMPFLIM
"RTN","HMPDJFSG",51,0)
 ..  S SNODE=^XTMP(HMPFSTRM,HMPFIDX),STYPE=$P(SNODE,U,2)
"RTN","HMPDJFSG",52,0)
 ..  ;===JD START===
"RTN","HMPDJFSG",53,0)
 ..  K ARGS("hmp-fst") I $P(SNODE,U,4)="@" S ARGS("hmp-fst")=$P(SNODE,U,5)
"RTN","HMPDJFSG",54,0)
 ..  ;===JD END===
"RTN","HMPDJFSG",55,0)
 ..  S $P(^XTMP(HMPFSTRM,HMPFIDX),U,6)=$P($H,",",2) ; timestamp when sent
"RTN","HMPDJFSG",56,0)
 ..  I STYPE="syncNoop" Q                      ; skip, patient was unsubscribed
"RTN","HMPDJFSG",57,0)
 ..  I STYPE="syncDomain" D DOMITMS Q          ; add multiple extract items
"RTN","HMPDJFSG",58,0)
 ..  S HMPFSEQ=HMPFIDX
"RTN","HMPDJFSG",59,0)
 ..  I STYPE="syncCommand" D SYNCCMD(SNODE) Q  ; command to middle tier
"RTN","HMPDJFSG",60,0)
 ..  I STYPE="syncError" D SYNCERR(SNODE,.HMPERR) Q
"RTN","HMPDJFSG",61,0)
 ..  I STYPE="syncStart" D SYNCSTRT(SNODE) S HMPLITEM="SYNC" Q  ; begin initial extraction ;DE3502
"RTN","HMPDJFSG",62,0)
 ..  I STYPE="syncMeta" D SYNCMETA(SNODE) S HMPLITEM="SYNC" Q   ; US11019 - Build replacement syncstart ;DE3502
"RTN","HMPDJFSG",63,0)
 ..  I STYPE="syncDone" D SYNCDONE(SNODE) S HMPLITEM="SYNC" Q   ; end of initial extraction ;DE3502
"RTN","HMPDJFSG",64,0)
 ..  D FRESHITM(SNODE,.HMPDEL,.HMPERR) S HMPLITEM="FRESH"       ; otherwise, freshness item ;DE3502
"RTN","HMPDJFSG",65,0)
 Q:$G(HMPFERR)
"RTN","HMPDJFSG",66,0)
 D FINISH(.HMPDEL,.HMPERR)
"RTN","HMPDJFSG",67,0)
 ;Check if HMP GLOBAL USAGE MONITOR mail message is required - US8228
"RTN","HMPDJFSG",68,0)
 D CHECK^HMPMETA(HMPFHMP) ; US8228
"RTN","HMPDJFSG",69,0)
 Q
"RTN","HMPDJFSG",70,0)
DOMITMS ; loop thru extract items, OFFSET is last sent
"RTN","HMPDJFSG",71,0)
 ; expects HMPFSTRM,HMPFIDX,HMPFHMP,HMPFSYS
"RTN","HMPDJFSG",72,0)
 ; changes HMPFSEQ,HMPFCNT,HMPFSIZE as each item added  ; *S68-JCH*
"RTN","HMPDJFSG",73,0)
 N X,OFFSET,DFN,PIDS,DOMAIN,TASK,BATCH,COUNT,ITEMNUM,DOMSIZE,SECSIZE
"RTN","HMPDJFSG",74,0)
 S X=^XTMP(HMPFSTRM,HMPFIDX),DFN=$P(X,U),X=$P(X,U,3)
"RTN","HMPDJFSG",75,0)
 S PIDS=$S(DFN:$$PIDS^HMPDJFS(DFN),1:"")
"RTN","HMPDJFSG",76,0)
 S DOMAIN=$P(X,":")               ; domain{#sectionNumber}
"RTN","HMPDJFSG",77,0)
 S TASK=$P(X,":",2)               ; task number in ^XTMP
"RTN","HMPDJFSG",78,0)
 S COUNT=$P(X,":",3)              ; count in this section
"RTN","HMPDJFSG",79,0)
 S DOMSIZE=$P(X,":",4)            ; estimated total for the domain
"RTN","HMPDJFSG",80,0)
 S SECSIZE=$P(X,":",5)            ; section size (for operational)
"RTN","HMPDJFSG",81,0)
 S BATCH="HMPFX~"_HMPFHMP_"~"_DFN ; extract node in ^XTMP
"RTN","HMPDJFSG",82,0)
 S OFFSET=COUNT-(HMPFIDX-HMPFSEQ)
"RTN","HMPDJFSG",83,0)
 F  S OFFSET=$O(^XTMP(BATCH,TASK,DOMAIN,OFFSET)) Q:'OFFSET  D  Q:HMPFCNT'<HMPFLIM
"RTN","HMPDJFSG",84,0)
 . ;;PJH;;S HMPFCNT=HMPFCNT+1            ; increment the count of returned items
"RTN","HMPDJFSG",85,0)
 . S HMPFSEQ=HMPFSEQ+1            ; increment the sequence number in the stream
"RTN","HMPDJFSG",86,0)
 . S HMPFSIZE=$$INCITEM($P(DOMAIN,"#"))  ;                  *S68-JCH*
"RTN","HMPDJFSG",87,0)
 . S ITEMNUM=OFFSET+($P(DOMAIN,"#",2)*SECSIZE)
"RTN","HMPDJFSG",88,0)
 . M ^TMP("HMPF",$J,HMPFCNT)=^XTMP(BATCH,TASK,DOMAIN,OFFSET)
"RTN","HMPDJFSG",89,0)
 . ;S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER(DOMAIN,PIDS,$S('COUNT:0,1:ITEMNUM),+DOMSIZE)
"RTN","HMPDJFSG",90,0)
 . S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER(DOMAIN,PIDS,$S('COUNT:0,1:ITEMNUM),+DOMSIZE,1)  ; *S68-JCH*
"RTN","HMPDJFSG",91,0)
 . S HMPLITEM="SYNC",HMPCLFLG=0 ; DE3502
"RTN","HMPDJFSG",92,0)
 Q
"RTN","HMPDJFSG",93,0)
MIDXTRCT() ; Return true if mid-extract
"RTN","HMPDJFSG",94,0)
 ; from GETSUB expects HMPFSTRM,HMPFSEQ
"RTN","HMPDJFSG",95,0)
 I 'HMPFSEQ Q 0
"RTN","HMPDJFSG",96,0)
 I '$D(^XTMP(HMPFSTRM,HMPFSEQ)) Q 1                  ; middle of extract
"RTN","HMPDJFSG",97,0)
 I $P(^XTMP(HMPFSTRM,HMPFSEQ),U,2)="syncDomain" Q 1  ; just starting extract
"RTN","HMPDJFSG",98,0)
 Q 0
"RTN","HMPDJFSG",99,0)
 ;
"RTN","HMPDJFSG",100,0)
NXTSTRM ; Reset variables for next date in this HMP stream
"RTN","HMPDJFSG",101,0)
 ; from GETSUB expects HMPFSTRM,HMPFDT,HMPFIDX
"RTN","HMPDJFSG",102,0)
 ; HMPFSTRM set to "" if no next stream
"RTN","HMPDJFSG",103,0)
 ; HMPFIDX  set to 0 if next stream, or left as is
"RTN","HMPDJFSG",104,0)
 ; HMPFDT   set to last date actually used
"RTN","HMPDJFSG",105,0)
 N NEXTDT,DONE
"RTN","HMPDJFSG",106,0)
 S NEXTDT=HMPFDT,DONE=0
"RTN","HMPDJFSG",107,0)
 F  D  Q:DONE
"RTN","HMPDJFSG",108,0)
 . S NEXTDT=$$FMADD^XLFDT(NEXTDT,1)
"RTN","HMPDJFSG",109,0)
 . I NEXTDT>$$DT^XLFDT S HMPFSTRM="" S DONE=1 Q
"RTN","HMPDJFSG",110,0)
 . S $P(HMPFSTRM,"~",3)=NEXTDT
"RTN","HMPDJFSG",111,0)
 . I '+$O(^XTMP(HMPFSTRM,0)) Q  ; nothing here, try next date
"RTN","HMPDJFSG",112,0)
 . S HMPFDT=NEXTDT,HMPFIDX=0,HMPFSEQ=0,DONE=1
"RTN","HMPDJFSG",113,0)
 Q
"RTN","HMPDJFSG",114,0)
 ;
"RTN","HMPDJFSG",115,0)
SETLIMIT(ARGS) ; sets HMPFLIM, HMPFMAX, HMPFSIZE variables  *BEGIN*S68-JCH*
"RTN","HMPDJFSG",116,0)
 I $G(ARGS("maxSize")) D  Q
"RTN","HMPDJFSG",117,0)
 . S HMPFLIM="s"
"RTN","HMPDJFSG",118,0)
 . S HMPFMAX=ARGS("maxSize")
"RTN","HMPDJFSG",119,0)
 . D GETLST^XPAR(.HMPFSIZE,"PKG","HMP DOMAIN SIZES","I")
"RTN","HMPDJFSG",120,0)
 . S HMPFSIZE=0
"RTN","HMPDJFSG",121,0)
 ; otherwise
"RTN","HMPDJFSG",122,0)
 S HMPFLIM="c"
"RTN","HMPDJFSG",123,0)
 S HMPFMAX=$G(ARGS("max"),99999)
"RTN","HMPDJFSG",124,0)
 S HMPFSIZE=0
"RTN","HMPDJFSG",125,0)
 Q
"RTN","HMPDJFSG",126,0)
 ;
"RTN","HMPDJFSG",127,0)
INCITEM(DOMAIN) ; increment counters as item added *BEGIN*S68-JCH*
"RTN","HMPDJFSG",128,0)
 S HMPFCNT=HMPFCNT+1
"RTN","HMPDJFSG",129,0)
 I HMPFLIM="s" Q HMPFSIZE+$G(HMPFSIZE(DOMAIN),1200)
"RTN","HMPDJFSG",130,0)
 I HMPFLIM="c" Q HMPFCNT
"RTN","HMPDJFSG",131,0)
 Q 0
"RTN","HMPDJFSG",132,0)
 ;                                                     *END*S68-JCH*
"RTN","HMPDJFSG",133,0)
 ;
"RTN","HMPDJFSG",134,0)
FINISH(HMPDEL,HMPERR) ;reset the FIRST object delimiter, add header and tail
"RTN","HMPDJFSG",135,0)
 ; expects HMPFCNT,HMPFDT,HMPFSEQ,HMPFHMP,HMPFLAST
"RTN","HMPDJFSG",136,0)
 N CLOSE,I,START,TEXT,UID,X,II
"RTN","HMPDJFSG",137,0)
 S X=$G(^TMP("HMPF",$J,1,.3))
"RTN","HMPDJFSG",138,0)
 I $E(X,1,2)="}," S X=$E(X,3,$L(X)),^TMP("HMPF",$J,1,.3)=X
"RTN","HMPDJFSG",139,0)
 S ^TMP("HMPF",$J,.5)=$$APIHDR(HMPFCNT,HMPFDT_"-"_HMPFSEQ)
"RTN","HMPDJFSG",140,0)
 I $D(HMPERR) D
"RTN","HMPDJFSG",141,0)
 .S CLOSE=$S(HMPFCNT:"},",1:""),START=1
"RTN","HMPDJFSG",142,0)
 .S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)=CLOSE_"{""error"":["
"RTN","HMPDJFSG",143,0)
 .S I=0 F  S I=$O(HMPERR(I)) Q:I'>0  D
"RTN","HMPDJFSG",144,0)
 ..S TEXT=HMPERR(I)
"RTN","HMPDJFSG",145,0)
 ..S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)=$S(START:"",1:",")_TEXT S START=0
"RTN","HMPDJFSG",146,0)
 .S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)="]"
"RTN","HMPDJFSG",147,0)
 ; operational sync item or patient
"RTN","HMPDJFSG",148,0)
 ; Check for closing flag & HMPFCNT and if it doesn't exist add a closing brace, always close array
"RTN","HMPDJFSG",149,0)
 S ^TMP("HMPF",$J,HMPFCNT+1)=$S(HMPFCNT&('$G(HMPCLFLG)):"}",1:"")_"]",HMPFCNT=HMPFCNT+1
"RTN","HMPDJFSG",150,0)
 ; modified
"RTN","HMPDJFSG",151,0)
 I $G(HMPSTGET)="true" D  ; true if "getStatus" argument passed in
"RTN","HMPDJFSG",152,0)
 . S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)=",""syncStatii"":[",START=1
"RTN","HMPDJFSG",153,0)
 . S I=0 F  S I=$O(^HMP(800000,I)) Q:+I=0  D
"RTN","HMPDJFSG",154,0)
 . . I $P($G(^HMP(800000,I,0)),"^",1)=HMPFHMP D
"RTN","HMPDJFSG",155,0)
 . . . S II=0 F  S II=$O(^HMP(800000,I,1,II)) Q:+II=0  D
"RTN","HMPDJFSG",156,0)
 . . . . S TEXT="{""pid"":"_II_",""status"":"_$P(^HMP(800000,I,1,II,0),"^",2)_"}"
"RTN","HMPDJFSG",157,0)
 . . . . S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)=$S(START:"",1:",")_TEXT S START=0
"RTN","HMPDJFSG",158,0)
 . S HMPFCNT=HMPFCNT+1,^TMP("HMPF",$J,HMPFCNT)="]"
"RTN","HMPDJFSG",159,0)
 ;
"RTN","HMPDJFSG",160,0)
 S ^TMP("HMPF",$J,HMPFCNT+1)="}}"
"RTN","HMPDJFSG",161,0)
 ; remove any ^XTMP nodes that have been successfully sent based on LAST
"RTN","HMPDJFSG",162,0)
 N DATE,SEQ,LASTDT,LASTSEQ,STRM,LSTRM,RSTRM
"RTN","HMPDJFSG",163,0)
 S LASTDT=+$P(HMPFLAST,"-"),LASTSEQ=+$P(HMPFLAST,"-",2)
"RTN","HMPDJFSG",164,0)
 S RSTRM="HMPFS~"_HMPFHMP_"~",LSTRM=$L(RSTRM),STRM=RSTRM
"RTN","HMPDJFSG",165,0)
 F  S STRM=$O(^XTMP(STRM)) Q:'$L(STRM)  Q:$E(STRM,1,LSTRM)'=RSTRM  D
"RTN","HMPDJFSG",166,0)
 . S DATE=$P(STRM,"~",3) Q:DATE>LASTDT
"RTN","HMPDJFSG",167,0)
 . S SEQ=0 F  S SEQ=$O(^XTMP(STRM,"tidy",SEQ)) Q:'SEQ  Q:(DATE=LASTDT)&(SEQ>LASTSEQ)  D TIDYX(STRM,SEQ)
"RTN","HMPDJFSG",168,0)
 Q
"RTN","HMPDJFSG",169,0)
TIDYX(STREAM,SEQ) ; clean up extracts after they have been retrieved
"RTN","HMPDJFSG",170,0)
 ; from FINISH
"RTN","HMPDJFSG",171,0)
 N BATCH,DOMAIN,TASK
"RTN","HMPDJFSG",172,0)
 S BATCH=^XTMP(STREAM,"tidy",SEQ,"batch")
"RTN","HMPDJFSG",173,0)
 S DOMAIN=^XTMP(STREAM,"tidy",SEQ,"domain")
"RTN","HMPDJFSG",174,0)
 S TASK=^XTMP(STREAM,"tidy",SEQ,"task")
"RTN","HMPDJFSG",175,0)
 I DOMAIN="<done>" K ^XTMP(BATCH) I 1
"RTN","HMPDJFSG",176,0)
 E  K ^XTMP(BATCH,TASK,DOMAIN)
"RTN","HMPDJFSG",177,0)
 K ^XTMP(STREAM,"tidy",SEQ)
"RTN","HMPDJFSG",178,0)
 Q
"RTN","HMPDJFSG",179,0)
SYNCCMD(SEQNODE) ; Build syncCommand object and stick in ^TMP
"RTN","HMPDJFSG",180,0)
 ; expects: HMPSYS, HMPFCNT
"RTN","HMPDJFSG",181,0)
 N DFN,CMD,CMDJSON,ERR
"RTN","HMPDJFSG",182,0)
 S DFN=+SEQNODE
"RTN","HMPDJFSG",183,0)
 S CMD("command")=$P($P(SEQNODE,U,3),":")
"RTN","HMPDJFSG",184,0)
 S CMD("domain")=$P($P(SEQNODE,U,3),":",2)
"RTN","HMPDJFSG",185,0)
 S:DFN CMD("pid")=$$PID^HMPDJFS(DFN)
"RTN","HMPDJFSG",186,0)
 S CMD("system")=HMPSYS
"RTN","HMPDJFSG",187,0)
 D ENCODE^HMPJSON("CMD","CMDJSON","ERR")
"RTN","HMPDJFSG",188,0)
 I $D(ERR) S $EC=",UJSON encode error," Q
"RTN","HMPDJFSG",189,0)
 S HMPFSIZE=$$INCITEM("syncCommand")  ; *S68-JCH*
"RTN","HMPDJFSG",190,0)
 M ^TMP("HMPF",$J,HMPFCNT)=CMDJSON
"RTN","HMPDJFSG",191,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER("syncCommand",$$PIDS^HMPDJFS(DFN),1,1)
"RTN","HMPDJFSG",192,0)
 Q
"RTN","HMPDJFSG",193,0)
SYNCSTRT(SEQNODE) ; Build syncStart object with demograhics
"RTN","HMPDJFSG",194,0)
 ; expects HMPFSYS, HMPFHMP, HMPFCNT, HMPFSIZE   *S68-JCH*
"RTN","HMPDJFSG",195,0)
 S HMPFSIZE=$$INCITEM("patient")  ;              *S68-JCH*
"RTN","HMPDJFSG",196,0)
 N DFN,FILTER,DFN,WRAP
"RTN","HMPDJFSG",197,0)
 S DFN=$P($P(SEQNODE,U,3),"~",3) ; HMPFX~hmpSrvId~dfn
"RTN","HMPDJFSG",198,0)
 I DFN D
"RTN","HMPDJFSG",199,0)
 . N RSLT ;cpc 2015/10/01
"RTN","HMPDJFSG",200,0)
 . S FILTER("patientId")=DFN,FILTER("domain")="patient"
"RTN","HMPDJFSG",201,0)
 . D GET^HMPDJ(.RSLT,.FILTER)
"RTN","HMPDJFSG",202,0)
 . M ^TMP("HMPF",$J,HMPFCNT)=^TMP("HMP",$J,1)
"RTN","HMPDJFSG",203,0)
 ; for OPD there is no object, so 4th argument is 0 
"RTN","HMPDJFSG",204,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER("syncStart",$$PIDS^HMPDJFS(DFN),$S(DFN:1,1:-1),$S(DFN:1,1:-1))
"RTN","HMPDJFSG",205,0)
 Q
"RTN","HMPDJFSG",206,0)
SYNCDONE(SEQNODE) ; Build syncStatus object and stick in ^TMP
"RTN","HMPDJFSG",207,0)
 ;  expects: HMPFSYS, HMPFCNT, HMPFHMP, HMPFSIZE  *S68-JCH*
"RTN","HMPDJFSG",208,0)
 N HMPBATCH,DFN,STS,STSJSON,X,ERR
"RTN","HMPDJFSG",209,0)
 S HMPBATCH=$P(SEQNODE,U,3) ; HMPFX~hmpSrvId~dfn
"RTN","HMPDJFSG",210,0)
 S DFN=$P(HMPBATCH,"~",3)
"RTN","HMPDJFSG",211,0)
 S STS("uid")="urn:va:syncStatus:"_HMPFSYS_":"_DFN
"RTN","HMPDJFSG",212,0)
 S STS("initialized")="true"
"RTN","HMPDJFSG",213,0)
 I DFN S STS("localId")=DFN
"RTN","HMPDJFSG",214,0)
 S X="" F  S X=$O(^XTMP(HMPBATCH,0,"count",X)) Q:'$L(X)  D
"RTN","HMPDJFSG",215,0)
 . S STS("domainTotals",X)=^XTMP(HMPBATCH,0,"count",X)
"RTN","HMPDJFSG",216,0)
 ;===JD START===
"RTN","HMPDJFSG",217,0)
 ; If resubscribing a patient, just send demographics
"RTN","HMPDJFSG",218,0)
 I DFN'="OPD",$D(^HMP(800000,"AITEM",DFN)) D
"RTN","HMPDJFSG",219,0)
 . N HMP99
"RTN","HMPDJFSG",220,0)
 . S HMP99=""
"RTN","HMPDJFSG",221,0)
 . ; Reset all domain counts to zero except for demographics
"RTN","HMPDJFSG",222,0)
 . F  S HMP99=$O(STS("domainTotals",HMP99)) Q:'HMP99  I HMP99'="patient" S STS("domainTotals",HMP99)=0
"RTN","HMPDJFSG",223,0)
 ;===JD   END===
"RTN","HMPDJFSG",224,0)
 D ENCODE^HMPJSON("STS","STSJSON","ERR")
"RTN","HMPDJFSG",225,0)
 I $D(ERR) S $EC=",UJSON encode error," Q
"RTN","HMPDJFSG",226,0)
 S HMPFSIZE=$$INCITEM("syncstatus")  ; *S68-JCH*
"RTN","HMPDJFSG",227,0)
 M ^TMP("HMPF",$J,HMPFCNT)=STSJSON
"RTN","HMPDJFSG",228,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER("syncStatus",$$PIDS^HMPDJFS(DFN),1,1)
"RTN","HMPDJFSG",229,0)
 Q
"RTN","HMPDJFSG",230,0)
 ;
"RTN","HMPDJFSG",231,0)
SYNCMETA(SNODE) ; US11019 Build NEW syncStart object
"RTN","HMPDJFSG",232,0)
 ; expects HMPFSYS, HMPFHMP, HMPFCNT
"RTN","HMPDJFSG",233,0)
 ; need to rebuild SNODE because WRAPPER expects it to fall in
"RTN","HMPDJFSG",234,0)
 N BATCH,DFN,WRAP,METADOM
"RTN","HMPDJFSG",235,0)
 S DFN=$P(SNODE,U,1)
"RTN","HMPDJFSG",236,0)
 S METADOM=$P(SNODE,U,3)
"RTN","HMPDJFSG",237,0)
 S BATCH="HMPFX~"_HMPFHMP_"~"_DFN
"RTN","HMPDJFSG",238,0)
 S $P(SNODE,U,3)=BATCH
"RTN","HMPDJFSG",239,0)
 S HMPFSIZE=$$INCITEM("syncmeta") ;need to increment count
"RTN","HMPDJFSG",240,0)
 S ^TMP("HMPF",$J,HMPFCNT,.3)=$$WRAPPER("syncStart"_"#"_METADOM,$$PIDS^HMPDJFS(DFN),$S(DFN:1,1:-1),$S(DFN:1,1:-1))
"RTN","HMPDJFSG",241,0)
 S ^TMP("HMPF",$J,HMPFCNT,1)="null" ;always null object with this record
"RTN","HMPDJFSG",242,0)
 S HMPCLFLG=0 ; DE3502
"RTN","HMPDJFSG",243,0)
 Q
"RTN","HMPDJFSG",244,0)
 ;
"RTN","HMPDJFSG",245,0)
SYNCERR(SNODE,HMPERR) ;
"RTN","HMPDJFSG",246,0)
 N BATCH,CNT,DFN,NUM,OFFSET,PIDS,TASK,TOTAL,X
"RTN","HMPDJFSG",247,0)
 S DFN=$P(SNODE,U),X=$P(SNODE,U,3)
"RTN","HMPDJFSG",248,0)
 S PIDS=$$PIDS^HMPDJFS(DFN)
"RTN","HMPDJFSG",249,0)
 S TASK=$P(X,":",2),TOTAL=$P(X,":",4)
"RTN","HMPDJFSG",250,0)
 S BATCH="HMPFX~"_HMPFHMP_"~"_DFN       ; extract node in ^XTMP
"RTN","HMPDJFSG",251,0)
 S CNT=$O(HMPERR(""),-1)
"RTN","HMPDJFSG",252,0)
 S NUM=0 F  S NUM=$O(^XTMP(BATCH,TASK,"error",NUM)) Q:NUM'>0  D
"RTN","HMPDJFSG",253,0)
 .S CNT=CNT+1 S HMPERR(CNT)=$G(^XTMP(BATCH,TASK,"error",NUM,1))
"RTN","HMPDJFSG",254,0)
 Q
"RTN","HMPDJFSG",255,0)
 ;
"RTN","HMPDJFSG",256,0)
FRESHITM(SEQNODE,DELETE,ERROR) ; Get freshness item and stick in ^TMP
"RTN","HMPDJFSG",257,0)
 ; expects HMPFSYS, HMPFHMP
"RTN","HMPDJFSG",258,0)
 N ACT,DFN,DOMAIN,ECNT,FILTER,ID,RSLT,UID,HMP97,HMPI,WRAP,HMPPAT7,HMPPAT8
"RTN","HMPDJFSG",259,0)
 S FILTER("noHead")=1
"RTN","HMPDJFSG",260,0)
 S DFN=$P(SEQNODE,U),DOMAIN=$P(SEQNODE,U,2),ID=$P(SEQNODE,U,3),ACT=$P(SEQNODE,U,4)
"RTN","HMPDJFSG",261,0)
 ;Next 2 IFs added to prevent <UNDEFINED> in LKUP^HMPDJ00.  JD - 3/4/16. DE3869
"RTN","HMPDJFSG",262,0)
 ;Make sure deletes ('@') are not included.
"RTN","HMPDJFSG",263,0)
 ;HMPFSTRM and HMPFIDX are defined in the GETSUB section above.
"RTN","HMPDJFSG",264,0)
 ;For "pt-select", which is an operational data domain, ID=patient IEN and DFN="OPD".
"RTN","HMPDJFSG",265,0)
 ;For ptient domains ID=DFN=patient IEN.
"RTN","HMPDJFSG",266,0)
 ;We want the checks to be for all patient domains and pt-select of the operational data domain.
"RTN","HMPDJFSG",267,0)
 ;Kill the freshness stream entry with the bad patient IEN.
"RTN","HMPDJFSG",268,0)
 I ACT'="@",DFN=+DFN,'$D(^DPT(DFN,0)) K ^XTMP(HMPFSTRM,HMPFIDX) Q  ;For patient domains
"RTN","HMPDJFSG",269,0)
 I ACT'="@",DOMAIN="pt-select",ID=+ID,'$D(^DPT(ID,0)) K ^XTMP(HMPFSTRM,HMPFIDX) Q
"RTN","HMPDJFSG",270,0)
 ;
"RTN","HMPDJFSG",271,0)
 ;==JD START
"RTN","HMPDJFSG",272,0)
 ;Create a phantom "patient" if visit is the domain
"RTN","HMPDJFSG",273,0)
 I DOMAIN="visit" D
"RTN","HMPDJFSG",274,0)
 .S HMPPAT7=HMPFIDX_".99",HMPPAT8=^XTMP(HMPFSTRM,HMPFIDX),$P(HMPPAT8,U,2)="patient"  ;BL;DE2280
"RTN","HMPDJFSG",275,0)
 .S ^XTMP(HMPFSTRM,HMPPAT7)=HMPPAT8
"RTN","HMPDJFSG",276,0)
 ;==JD END
"RTN","HMPDJFSG",277,0)
 ;
"RTN","HMPDJFSG",278,0)
 I ACT'="@" D
"RTN","HMPDJFSG",279,0)
 . S FILTER("id")=ID
"RTN","HMPDJFSG",280,0)
 . S FILTER("domain")=DOMAIN
"RTN","HMPDJFSG",281,0)
 . I DFN="OPD" D GET^HMPEF(.RSLT,.FILTER)
"RTN","HMPDJFSG",282,0)
 . I +DFN>0 D
"RTN","HMPDJFSG",283,0)
 .. S FILTER("patientId")=DFN
"RTN","HMPDJFSG",284,0)
 ..  D  ; DE3691, add date/time with seconds to FILTER parameters, Feb 29 2016
"RTN","HMPDJFSG",285,0)
 ...  N DAY,SECS,TM S SECS=$P($G(^XTMP(HMPFSTRM,HMPFIDX)),U,5),DAY=$P(HMPFSTRM,"~",3)
"RTN","HMPDJFSG",286,0)
 ...  Q:('DAY)!('$L(SECS))  ; must have date and seconds, could be zero seconds (midnight)
"RTN","HMPDJFSG",287,0)
 ...  S TM=$S(SECS:SECS#60/100+(SECS#3600\60)/100+(SECS\3600)/100,SECS=0:".000001",1:"")  ; if zero (midnight) push to 1 second after
"RTN","HMPDJFSG",288,0)
 ...  Q:'$L(TM)  ; couldn't compute time
"RTN","HMPDJFSG",289,0)
 ...  S FILTER("freshnessDateTime")=DAY+TM
"RTN","HMPDJFSG",290,0)
 .. D GET^HMPDJ(.RSLT,.FILTER)
"RTN","HMPDJFSG",291,0)
 I ACT'="@",$L($G(^TMP("HMP",$J,"error")))>0 D BLDSERR(DFN,.ERROR)  Q
"RTN","HMPDJFSG",292,0)
 I '$D(^TMP("HMP",$J,1)) S ACT="@"
"RTN","HMPDJFSG",293,0)
 I ACT="@" D
"RTN","HMPDJFSG",294,0)
 . S UID=$$SETUID^HMPUTILS(DOMAIN,$S(+DFN>0:DFN,1:""),ID)
"RTN","HMPDJFSG",295,0)
 . S HMP97=UID
"RTN","HMPDJFSG",296,0)
 . K ^TMP("HMP",$J) S ^TMP("HMP",$J,1)="" ; Need to dummy this up or it will never get set later
"RTN","HMPDJFSG",297,0)
 ;
"RTN","HMPDJFSG",298,0)
 ;Add syncstart, data and syncstatus to JSON for unsolicited updates - US4588 & US3682
"RTN","HMPDJFSG",299,0)
 I (DOMAIN="pt-select")!(DOMAIN="user")!(DOMAIN["asu-")!(DOMAIN="doc-def")!(DFN=+DFN) D  Q
"RTN","HMPDJFSG",300,0)
 .D ADHOC^HMPUTIL1(DOMAIN,.HMPFCNT,DFN)
"RTN","HMPDJFSG",301,0)
 .I $P(HMPFIDX,".",2)=99 K ^XTMP(HMPFSTRM,HMPFIDX) ;Remove the phantom "patient"; JD
"RTN","HMPDJFSG",302,0)
 .S HMPLITEM="FRESH" ; DE3502
"RTN","HMPDJFSG",303,0)
 ;
"RTN","HMPDJFSG",304,0)
 S WRAP=$$WRAPPER(DOMAIN,$$PIDS^HMPDJFS(DFN),1,1) ; N.B. this updates the .3 node on this HMPFCNT
"RTN","HMPDJFSG",305,0)
 F HMPI=1:1 Q:'$D(^TMP("HMP",$J,HMPI))  D
"RTN","HMPDJFSG",306,0)
 . S HMPFCNT=HMPFCNT+1
"RTN","HMPDJFSG",307,0)
 . M ^TMP("HMPF",$J,HMPFCNT)=^TMP("HMP",$J,HMPI)
"RTN","HMPDJFSG",308,0)
 . I HMPLITEM="SYNC" S HMPLITEM="FRESH" I WRAP="," S ^TMP("HMPF",$J,HMPFCNT,.3)="}," Q  ; DE3502 add closing
"RTN","HMPDJFSG",309,0)
 . S ^TMP("HMPF",$J,HMPFCNT,.3)=WRAP
"RTN","HMPDJFSG",310,0)
 Q
"RTN","HMPDJFSG",311,0)
 ;
"RTN","HMPDJFSG",312,0)
BLDSERR(DFN,ERROR) ; Create syncError object in ERRJSON
"RTN","HMPDJFSG",313,0)
 ; expects: HMPBATCH, HMPFSYS, HMPFZTSK
"RTN","HMPDJFSG",314,0)
 N COUNT,ERRVAL,ERROBJ,ERR,ERRCNT,ERRMSG,SYNCERR
"RTN","HMPDJFSG",315,0)
 M ERRVAL=^TMP("HMP",$J,"error")
"RTN","HMPDJFSG",316,0)
 I $G(ERRVAL)="" Q
"RTN","HMPDJFSG",317,0)
 S ERRVAL="{"_ERRVAL_"}"
"RTN","HMPDJFSG",318,0)
 D DECODE^HMPJSON("ERRVAL","ERROBJ","ERR")
"RTN","HMPDJFSG",319,0)
 I $D(ERR) S $EC=",UJSON decode error,"
"RTN","HMPDJFSG",320,0)
 S ERRMSG=ERROBJ("error","message")
"RTN","HMPDJFSG",321,0)
 Q:'$L(ERRMSG)
"RTN","HMPDJFSG",322,0)
 S SYNCERR("uid")="urn:va:syncError:"_HMPFSYS_":"_DFN_":FRESHNESS"
"RTN","HMPDJFSG",323,0)
 S SYNCERR("collection")=DOMAIN
"RTN","HMPDJFSG",324,0)
 S SYNCERR("error")=ERRMSG
"RTN","HMPDJFSG",325,0)
 D ENCODE^HMPJSON("SYNCERR","ERRJSON","ERR") I $D(ERR) S $EC=",UJSON encode error," Q
"RTN","HMPDJFSG",326,0)
 S COUNT=$O(ERROR(""),-1)  ;                      *BEGIN*S68-JCH*
"RTN","HMPDJFSG",327,0)
 S ERRCNT=0 F  S ERRCNT=$O(ERRJSON(ERRCNT)) Q:ERRCNT'>0  D
"RTN","HMPDJFSG",328,0)
 .S COUNT=COUNT+1 M ERROR(COUNT)=ERRJSON(COUNT)  ;  *END*S68-JCH*
"RTN","HMPDJFSG",329,0)
 Q
"RTN","HMPDJFSG",330,0)
WRAPPER(DOMAIN,PIDS,OFFSET,DOMSIZE,FROMXTR) ; return JSON wrapper for each item *S68-JCH*
"RTN","HMPDJFSG",331,0)
 ; add object tag if extract total not zero or if total passed as -1
"RTN","HMPDJFSG",332,0)
 ; seq and total tags only added if non-zero
"RTN","HMPDJFSG",333,0)
 N X,Y,Z,HMPSVERS ;US11019
"RTN","HMPDJFSG",334,0)
 ; Ensure that X exists
"RTN","HMPDJFSG",335,0)
 S X=""
"RTN","HMPDJFSG",336,0)
 S Z=$P(SNODE,U,3)
"RTN","HMPDJFSG",337,0)
 S HMPSVERS=$G(^XTMP(Z,"HMPSVERS")) ;US11019 If HMPSVERS=0 then running in previous mode
"RTN","HMPDJFSG",338,0)
 S HMPSTMP=$G(^XTMP(Z,"HMPSTMP")) ;; PJH - THIS USED ONLY FOR OPD COMPILE IN PRIOR VERSION - NEEDS REMOVING US6734
"RTN","HMPDJFSG",339,0)
 ; This was working for operational data, not patient data
"RTN","HMPDJFSG",340,0)
 ; DFN will be OPD if this is operational data (non-obvious I know)
"RTN","HMPDJFSG",341,0)
 I DFN="OPD" D
"RTN","HMPDJFSG",342,0)
 . S:$P($G(DOMAIN),"#")'="syncStart" X="},{""collection"":"""_$P(DOMAIN,"#")_""""_PIDS ;US11019
"RTN","HMPDJFSG",343,0)
 E  S X="},{""collection"":"""_$P(DOMAIN,"#")_""""_PIDS  ; If ONLY patient data exists
"RTN","HMPDJFSG",344,0)
 I HMPLITEM="FRESH" I $E(X)="}" S X=$E(X,2,$L(X)) ; DE3502 - remove closing when coming from Fresh
"RTN","HMPDJFSG",345,0)
 I $P(DOMAIN,"#")="syncStart",$O(^XTMP(Z,0))]"" D  Q X
"RTN","HMPDJFSG",346,0)
 .; --- Start US3907 ---
"RTN","HMPDJFSG",347,0)
 .; Pass JobId and RootJobId back in the response if we were given them
"RTN","HMPDJFSG",348,0)
 .; This bridges the gap between Job status and Sync Status (since VistA will be giving the syncStatus)
"RTN","HMPDJFSG",349,0)
 .; US11019 use domain specific Job id
"RTN","HMPDJFSG",350,0)
 .S Y=$S($P(DOMAIN,"#",2)="":$G(^XTMP(Z,"JOBID")),1:$G(^XTMP(Z,"JOBID",$P(DOMAIN,"#",2)))) ;US11019
"RTN","HMPDJFSG",351,0)
 .I Y]"" S X=X_",""jobId"":"""_Y_""""
"RTN","HMPDJFSG",352,0)
 .S Y=$G(^XTMP(Z,"ROOTJOBID"))
"RTN","HMPDJFSG",353,0)
 .I Y]"" S X=X_",""rootJobId"":"""_Y_""""
"RTN","HMPDJFSG",354,0)
 .; --- End US3907 ---
"RTN","HMPDJFSG",355,0)
 .I DFN'="OPD" D METAPT^HMPMETA(SNODE,$S(HMPSVERS:$P(DOMAIN,"#",2),1:"")) Q  ; US11019 extra para ;Collect Patient metastamp data from XTMP - US6734
"RTN","HMPDJFSG",356,0)
 .D METAOP^HMPMETA(SNODE) ; Collect OPD metastamp data from XTMP - US6734
"RTN","HMPDJFSG",357,0)
 S X=X_","
"RTN","HMPDJFSG",358,0)
 ; if batched by extract  *S68-JCH*
"RTN","HMPDJFSG",359,0)
 I $G(OFFSET)>-1 S X=X_"""seq"":"_OFFSET_","
"RTN","HMPDJFSG",360,0)
 I $G(DOMSIZE)>-1 S X=X_"""total"":"_DOMSIZE_","
"RTN","HMPDJFSG",361,0)
 I $G(OFFSET)>-1 S X=X_"""object"":"
"RTN","HMPDJFSG",362,0)
 Q X
"RTN","HMPDJFSG",363,0)
 ;
"RTN","HMPDJFSG",364,0)
APIHDR(COUNT,LASTITM) ; return JSON
"RTN","HMPDJFSG",365,0)
 ; expects HMPFSYS
"RTN","HMPDJFSG",366,0)
 I $P($G(LASTITM),".",2)="99" S LASTITM=$P(LASTITM,".")  ;make sure lastUpdate is correct;JD;BL;DE2280
"RTN","HMPDJFSG",367,0)
 N X
"RTN","HMPDJFSG",368,0)
 S X="{""apiVersion"":1.02,""params"":{""domain"":"""_$$KSP^XUPARAM("WHERE")_""""
"RTN","HMPDJFSG",369,0)
 S X=X_",""systemId"":"""_HMPFSYS_"""},""data"":{""updated"":"""_$$HL7NOW^HMPDJ_""""
"RTN","HMPDJFSG",370,0)
 S X=X_",""totalItems"":"_COUNT_",""lastUpdate"":"""_LASTITM_""""_$$PROGRESS^HMPDJFS(LASTITM)
"RTN","HMPDJFSG",371,0)
 S X=X_",""items"":["
"RTN","HMPDJFSG",372,0)
 Q X
"RTN","HMPDJFSG",373,0)
 ;
"RTN","HMPDJFSG",374,0)
NOOP(LASTITM) ; No-op, don't return any items
"RTN","HMPDJFSG",375,0)
 S ^TMP("HMPF",$J,.5)=$$APIHDR(0,LASTITM)_"]}}"
"RTN","HMPDJFSG",376,0)
 Q
"RTN","HMPDJFSG",377,0)
VERMATCH(HMPIEN,VERSION) ; true if middle tier HMP and VistA version match
"RTN","HMPDJFSG",378,0)
 ; versions match, queue any patients waiting for match
"RTN","HMPDJFSG",379,0)
 I $P($$GET^XPAR("PKG","HMP JSON SCHEMA"),".")=$P(VERSION,".") D  QUIT 1
"RTN","HMPDJFSG",380,0)
 . Q:'$G(^XTMP("HMPFS~"_HMPIEN,"waiting"))  ; no patients awaiting queuing
"RTN","HMPDJFSG",381,0)
 . S ^XTMP("HMPFS~"_HMPIEN,"waiting")=0
"RTN","HMPDJFSG",382,0)
 . N DOMAINS,BATCH,HMPNAME
"RTN","HMPDJFSG",383,0)
 . S HMPNAME=$P(^HMP(800000,HMPIEN,0),U)
"RTN","HMPDJFSG",384,0)
 . D PTDOMS^HMPDJFSD(.DOMAINS)
"RTN","HMPDJFSG",385,0)
 . S DFN=0 F  S DFN=$O(^XTMP("HMPFS~"_HMPIEN,"waiting",DFN)) Q:'DFN  D
"RTN","HMPDJFSG",386,0)
 . . Q:'$D(^HMP(800000,HMPIEN,1,DFN))  ; subscription cancelled while waiting  *S68-JCH*
"RTN","HMPDJFSG",387,0)
 . . S BATCH="HMPFX~"_HMPNAME_"~"_DFN
"RTN","HMPDJFSG",388,0)
 . . D QUINIT^HMPDJFSP(BATCH,DFN,.DOMAINS)
"RTN","HMPDJFSG",389,0)
 . K ^XTMP("HMPFS~"_HMPIEN)
"RTN","HMPDJFSG",390,0)
 ;
"RTN","HMPDJFSG",391,0)
 ; otherwise, hold things
"RTN","HMPDJFSG",392,0)
 D NEWXTMP^HMPDJFS("HMPFS~"_HMPIEN,8,"HMP Awaiting Version Match")
"RTN","HMPDJFSG",393,0)
 S ^XTMP("HMPFS~"_HMPIEN,"waiting")=1
"RTN","HMPDJFSG",394,0)
 Q 0
"RTN","HMPDJFSG",395,0)
 ;
"RTN","HMPDJFSG",396,0)
LASTUPD(HMPSRV,LASTUPD) ; save the last update
"RTN","HMPDJFSG",397,0)
 ; TODO: change this to use Fileman call
"RTN","HMPDJFSG",398,0)
 N IEN,CURRUPD,REPEAT
"RTN","HMPDJFSG",399,0)
 S IEN=$O(^HMP(800000,"B",HMPSRV,0)) Q:'IEN
"RTN","HMPDJFSG",400,0)
 Q:LASTUPD["^"
"RTN","HMPDJFSG",401,0)
 S CURRUPD=$P(^HMP(800000,IEN,0),"^",2),REPEAT=$P(^HMP(800000,IEN,0),"^",4)
"RTN","HMPDJFSG",402,0)
 I LASTUPD=CURRUPD S $P(^HMP(800000,IEN,0),"^",4)=REPEAT+1 QUIT
"RTN","HMPDJFSG",403,0)
 S $P(^HMP(800000,IEN,0),"^",2)=LASTUPD,$P(^HMP(800000,IEN,0),"^",4)=0
"RTN","HMPDJFSG",404,0)
 Q
"RTN","HMPDJFSG",405,0)
JSONOUT ; Write out JSON in ^TMP
"RTN","HMPDJFSG",406,0)
 N X
"RTN","HMPDJFSG",407,0)
 S X=$NA(^TMP("HMPF",$J))
"RTN","HMPDJFSG",408,0)
 F  S X=$Q(@X) Q:($QS(X,1)'="HMPF")!($QS(X,2)'=$J)  W !,@X
"RTN","HMPDJFSG",409,0)
 Q
"RTN","HMPDJFSG",410,0)
 ;
"RTN","HMPDJFSM")
0^40^B91843339^B91943836
"RTN","HMPDJFSM",1,0)
HMPDJFSM ;SLC/KCM,ASMR/RRB,CK - Monitoring Tools for Extracts;May 15, 2016 14:15
"RTN","HMPDJFSM",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJFSM",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFSM",4,0)
 ;
"RTN","HMPDJFSM",5,0)
 Q
"RTN","HMPDJFSM",6,0)
 ;
"RTN","HMPDJFSM",7,0)
EN ; Show information for one server
"RTN","HMPDJFSM",8,0)
 N IEN
"RTN","HMPDJFSM",9,0)
 S IEN=$$GETSRV() Q:IEN'>0
"RTN","HMPDJFSM",10,0)
 D LOOP(IEN)
"RTN","HMPDJFSM",11,0)
 Q
"RTN","HMPDJFSM",12,0)
ALL ; Show information for all servers
"RTN","HMPDJFSM",13,0)
 S IEN=0 F  S IEN=$O(^HMP(800000,IEN)) Q:'IEN  W ! D SHOWSRV(IEN)
"RTN","HMPDJFSM",14,0)
 Q
"RTN","HMPDJFSM",15,0)
ADDPT(PAT) ; Add patient to server
"RTN","HMPDJFSM",16,0)
 N SRV,ARGS,RESULT
"RTN","HMPDJFSM",17,0)
 I '$G(PAT) S PAT=$$GETPAT() Q:'PAT
"RTN","HMPDJFSM",18,0)
 S SRV=$$GETSRV() Q:SRV'>0
"RTN","HMPDJFSM",19,0)
 I $G(^HMP(800000,"AITEM",PAT,SRV))>0 W !,"Patient "_PAT_" already synced."
"RTN","HMPDJFSM",20,0)
 ;
"RTN","HMPDJFSM",21,0)
 S ARGS("command")="putPtSubscription"
"RTN","HMPDJFSM",22,0)
 S ARGS("server")=$P(^HMP(800000,SRV,0),"^")
"RTN","HMPDJFSM",23,0)
 S ARGS("localId")=PAT
"RTN","HMPDJFSM",24,0)
 D API^HMPDJFS(.RESULT,.ARGS)
"RTN","HMPDJFSM",25,0)
 I ^TMP("HMPF",$J,1)["location" W !,$P($G(^DPT(PAT,0)),"^")," is being synced."  ; IA10035, DE2818
"RTN","HMPDJFSM",26,0)
 E  W !,"Subscription failed."
"RTN","HMPDJFSM",27,0)
 Q
"RTN","HMPDJFSM",28,0)
LOGLVL ; Set log level
"RTN","HMPDJFSM",29,0)
 N DIR,DTOUT,DUOUT,DIRUT,Y,ERR
"RTN","HMPDJFSM",30,0)
 W !,"Set freshness logging level."
"RTN","HMPDJFSM",31,0)
 W !,"Current level is ",$$GET^XPAR("ALL","HMP LOG LEVEL")
"RTN","HMPDJFSM",32,0)
 S DIR(0)="S^0:no logging;1:request logging;2:response logging;C:clear logs"
"RTN","HMPDJFSM",33,0)
 D ^DIR
"RTN","HMPDJFSM",34,0)
 I $D(DTOUT)!$D(DUOUT)!$D(DIRUT) Q
"RTN","HMPDJFSM",35,0)
 I Y="C" K ^XTMP("HMPFLOG") Q
"RTN","HMPDJFSM",36,0)
 I Y>0 K ^XTMP("HMPFLOG")
"RTN","HMPDJFSM",37,0)
 D PUT^XPAR("SYS","HMP LOG LEVEL",1,Y,.ERR)
"RTN","HMPDJFSM",38,0)
 I $G(ERR) W !,"Error saving log level"
"RTN","HMPDJFSM",39,0)
 Q
"RTN","HMPDJFSM",40,0)
THLTH ; test health
"RTN","HMPDJFSM",41,0)
 K ^TMP("HMPF",$J)
"RTN","HMPDJFSM",42,0)
 N ARGS,HMPFHMP,HMPSYS,HMPFRSP
"RTN","HMPDJFSM",43,0)
 S ARGS("server")="Test-Server-1"
"RTN","HMPDJFSM",44,0)
 S HMPFRSP=$NA(^TMP("HMPF",$J))
"RTN","HMPDJFSM",45,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPDJFSM",46,0)
 S HMPFHMP=$TR($G(ARGS("server")),"~","=")
"RTN","HMPDJFSM",47,0)
 D HLTHCHK(.ARGS)
"RTN","HMPDJFSM",48,0)
 N I S I=0 F  S I=$O(^TMP("HMPF",$J,I)) Q:'I  W !,^TMP("HMPF",$J,I)
"RTN","HMPDJFSM",49,0)
 Q
"RTN","HMPDJFSM",50,0)
HLTHCHK(ARGS) ; Check health of VistA Server subscription
"RTN","HMPDJFSM",51,0)
 ; expect HMPFRSP, HMPFHMP, HMPSYS to be created by API^HMPDJFS
"RTN","HMPDJFSM",52,0)
 ; . ARGS("server")=HMP Server Id
"RTN","HMPDJFSM",53,0)
 ; return a list of extracts that are currently active
"RTN","HMPDJFSM",54,0)
 ; {pid="ABCD;229",domainsCompleted=8,domainsPending=20,objectCount=137,
"RTN","HMPDJFSM",55,0)
 ;  subscribeTime=20140609112734,extractStatus="initializing"}
"RTN","HMPDJFSM",56,0)
 ; ^TMP("HMPF",$J,1)=results
"RTN","HMPDJFSM",57,0)
 ;
"RTN","HMPDJFSM",58,0)
 N HMPIEN,STS,TIME,DFN
"RTN","HMPDJFSM",59,0)
 S HMPIEN=$O(^HMP(800000,"B",HMPFHMP,0))
"RTN","HMPDJFSM",60,0)
 I 'HMPIEN D SETERR^HMPDJFS("Server not registered") QUIT
"RTN","HMPDJFSM",61,0)
 S NODE=0
"RTN","HMPDJFSM",62,0)
 S STS="" F  S STS=$O(^HMP(800000,HMPIEN,1,"AP",STS)) Q:'$L(STS)  D
"RTN","HMPDJFSM",63,0)
 . S TIME="" F  S TIME=$O(^HMP(800000,HMPIEN,1,"AP",STS,TIME)) Q:'$L(TIME)  D
"RTN","HMPDJFSM",64,0)
 . . S DFN="" F  S DFN=$O(^HMP(800000,HMPIEN,1,"AP",STS,TIME,DFN)) Q:'DFN  D
"RTN","HMPDJFSM",65,0)
 . . . S NODE=NODE+1
"RTN","HMPDJFSM",66,0)
 . . . S ^TMP("HMPF",$J,NODE)=$$HLTHINFO(HMPFHMP,HMPIEN,DFN)
"RTN","HMPDJFSM",67,0)
 S ^TMP("HMPF",$J,.5)=$$HLTHHDR(NODE)
"RTN","HMPDJFSM",68,0)
 S ^TMP("HMPF",$J,NODE+1)="]}}"
"RTN","HMPDJFSM",69,0)
 Q
"RTN","HMPDJFSM",70,0)
HLTHINFO(SRV,SRVIEN,DFN) ; Return a string of JSON reporting progress for this domain
"RTN","HMPDJFSM",71,0)
 ; {pid,domainsCompleted,domainsPending,objectCount,queuedTime,phase(waiting,extracting)
"RTN","HMPDJFSM",72,0)
 N BATCH,QTIME,DONE,PEND,CNT,DOM,INFO,STS,JSON
"RTN","HMPDJFSM",73,0)
 S BATCH="HMPFX~"_SRV_"~"_DFN
"RTN","HMPDJFSM",74,0)
 S QTIME=$G(^XTMP(BATCH,0,"time")) S:$L(QTIME) QTIME=$$HTFM^XLFDT(QTIME)
"RTN","HMPDJFSM",75,0)
 S DONE=0,PEND=0,CNT=0
"RTN","HMPDJFSM",76,0)
 S DOM="" F  S DOM=$O(^XTMP(BATCH,0,"status",DOM)) Q:DOM=""  D
"RTN","HMPDJFSM",77,0)
 . S CNT=CNT+$G(^XTMP(BATCH,0,"count",DOM))
"RTN","HMPDJFSM",78,0)
 . I $G(^XTMP(BATCH,0,"status",DOM)) S DONE=DONE+1 QUIT
"RTN","HMPDJFSM",79,0)
 . S PEND=PEND+1
"RTN","HMPDJFSM",80,0)
 S INFO("pid")=$$PID^HMPDJFS(DFN)
"RTN","HMPDJFSM",81,0)
 S INFO("domainsCompleted")=DONE
"RTN","HMPDJFSM",82,0)
 S INFO("domainsPending")=PEND
"RTN","HMPDJFSM",83,0)
 S INFO("objectCount")=CNT
"RTN","HMPDJFSM",84,0)
 I $L(QTIME) S INFO("queuedTime")=$P($$FMTHL7^XLFDT(QTIME),"-")
"RTN","HMPDJFSM",85,0)
 S STS=$P($G(^HMP(800000,SRVIEN,1,DFN,0)),"^",2)
"RTN","HMPDJFSM",86,0)
 S INFO("extractStatus")=$S(STS=1:"initializing",STS=2:"initialized",1:"uninitialized")
"RTN","HMPDJFSM",87,0)
 D ENCODE^HMPJSON("INFO","JSON")
"RTN","HMPDJFSM",88,0)
 Q JSON(1)
"RTN","HMPDJFSM",89,0)
 ;
"RTN","HMPDJFSM",90,0)
HLTHHDR(COUNT) ; return JSON
"RTN","HMPDJFSM",91,0)
 ; expects HMPFSYS
"RTN","HMPDJFSM",92,0)
 N X
"RTN","HMPDJFSM",93,0)
 S X="{""apiVersion"":1.02,""params"":{""domain"":"""_$$KSP^XUPARAM("WHERE")_""""
"RTN","HMPDJFSM",94,0)
 S X=X_",""systemId"":"""_HMPSYS_"""},""data"":{""updated"":"""_$$HL7NOW^HMPDJ_""""
"RTN","HMPDJFSM",95,0)
 S X=X_",""totalItems"":"_COUNT
"RTN","HMPDJFSM",96,0)
 S X=X_",""items"":["
"RTN","HMPDJFSM",97,0)
 Q X
"RTN","HMPDJFSM",98,0)
 ;
"RTN","HMPDJFSM",99,0)
LOOP(SRV) ; Monitor refresh loop
"RTN","HMPDJFSM",100,0)
 D HOME^%ZIS
"RTN","HMPDJFSM",101,0)
 N ACT,IEN
"RTN","HMPDJFSM",102,0)
 S ACT="R" F  D  Q:"RV"'[ACT
"RTN","HMPDJFSM",103,0)
 . I ACT="R" D SHOWMAIN(SRV)
"RTN","HMPDJFSM",104,0)
 . I ACT="V" D SHOWHMPN
"RTN","HMPDJFSM",105,0)
 . W ! S ACT=$$GETCMD
"RTN","HMPDJFSM",106,0)
 Q
"RTN","HMPDJFSM",107,0)
GETSRV() ; Return the IEN for the server to monitor
"RTN","HMPDJFSM",108,0)
 N DIC,Y
"RTN","HMPDJFSM",109,0)
 S DIC="^HMP(800000,",DIC(0)="AEMQ",DIC("A")="Select HMP server instance: "
"RTN","HMPDJFSM",110,0)
 D ^DIC
"RTN","HMPDJFSM",111,0)
 Q +Y
"RTN","HMPDJFSM",112,0)
 ;
"RTN","HMPDJFSM",113,0)
GETPAT() ; Return DFN for a patient
"RTN","HMPDJFSM",114,0)
 N DIC,Y
"RTN","HMPDJFSM",115,0)
 S DIC=2,DIC(0)="AEMQ"  ; DE2818, changed to file number, not global
"RTN","HMPDJFSM",116,0)
 D ^DIC
"RTN","HMPDJFSM",117,0)
 Q +Y
"RTN","HMPDJFSM",118,0)
 ;
"RTN","HMPDJFSM",119,0)
GETCMD() ; Get the next command
"RTN","HMPDJFSM",120,0)
 N X,Y,DIR,DTOUT,DUOUT,DIRUT,DIROUT
"RTN","HMPDJFSM",121,0)
 S DIR(0)="SB^R:Refresh;V:View HMP Nodes;Q:Quit"
"RTN","HMPDJFSM",122,0)
 S DIR("B")="Refresh"
"RTN","HMPDJFSM",123,0)
 D ^DIR
"RTN","HMPDJFSM",124,0)
 I $D(DIRUT)!$D(DIROUT) S Y="Q"
"RTN","HMPDJFSM",125,0)
 Q Y
"RTN","HMPDJFSM",126,0)
 ;
"RTN","HMPDJFSM",127,0)
SHOWHMPN ; Show HMP global nodes
"RTN","HMPDJFSM",128,0)
 W !!,"Current HMP temporary nodes",?40,"High Numeric or Last Subscript",!
"RTN","HMPDJFSM",129,0)
 N X,Y,J
"RTN","HMPDJFSM",130,0)
 S X="VPQ~" F  S X=$O(^XTMP(X)) Q:$E(X,1,3)'="HMP"  D
"RTN","HMPDJFSM",131,0)
 . W !,"^XTMP("""_X_""")"
"RTN","HMPDJFSM",132,0)
 . S Y=$O(^XTMP(X," "),-1) S:'$L(Y) Y=$O(^XTMP(X,""),-1) W ?40,Y
"RTN","HMPDJFSM",133,0)
 W !
"RTN","HMPDJFSM",134,0)
 S X="VPQ~" F  S X=$O(^TMP(X)) Q:$E(X,1,3)'="HMP"  D
"RTN","HMPDJFSM",135,0)
 . S J=0 F  S J=$O(^TMP(X,J)) Q:'J  D
"RTN","HMPDJFSM",136,0)
 . . W !,"^TMP("""_X_""","_J_")"
"RTN","HMPDJFSM",137,0)
 . . S Y=$O(^TMP(X,J," "),-1) S:'$L(Y) Y=$O(^TMP(X,J,""),-1) W ?40,Y
"RTN","HMPDJFSM",138,0)
 S J=0 F  S J=$O(^TMP(J)) Q:'J  D
"RTN","HMPDJFSM",139,0)
 . S X="VPQ~" F  S X=$O(^TMP(J,X)) Q:$E(X,1,3)'="HMP"  D
"RTN","HMPDJFSM",140,0)
 . . W !,"^TMP("_J_","""_X_""")"
"RTN","HMPDJFSM",141,0)
 . . S Y=$O(^TMP(J,X," "),-1) S:'$L(Y) Y=$O(^TMP(J,X,""),-1) W ?40,Y
"RTN","HMPDJFSM",142,0)
 Q
"RTN","HMPDJFSM",143,0)
SHOWMAIN(SRV) ; Show main information for server
"RTN","HMPDJFSM",144,0)
 N STREAM
"RTN","HMPDJFSM",145,0)
 S STREAM=$$LSTREAM(SRV)
"RTN","HMPDJFSM",146,0)
 W @IOF
"RTN","HMPDJFSM",147,0)
 W !,$$HTE^XLFDT($H),?64,"Slots Open: ",$$SLOTS,!
"RTN","HMPDJFSM",148,0)
 I STREAM="" W !,"No HMP extract stream found." Q
"RTN","HMPDJFSM",149,0)
 D SHOWSRV(SRV)
"RTN","HMPDJFSM",150,0)
 D LJOBS(SRV)
"RTN","HMPDJFSM",151,0)
 D LQUEUE(SRV,10)
"RTN","HMPDJFSM",152,0)
 Q 
"RTN","HMPDJFSM",153,0)
SHOWSRV(IEN) ; Show information for a server
"RTN","HMPDJFSM",154,0)
 N X0,ROOT,BATCH,STREAM,SRVNM,LASTUP,REPEAT,TASK,TASKS
"RTN","HMPDJFSM",155,0)
 S X0=^HMP(800000,IEN,0)
"RTN","HMPDJFSM",156,0)
 S SRVNM=$P(X0,"^"),LASTUP=$P(X0,"^",2),REPEAT=$P(X0,"^",4)
"RTN","HMPDJFSM",157,0)
 S STREAM=$$LSTREAM(IEN)
"RTN","HMPDJFSM",158,0)
 W !,SRVNM,?30,"Last Update: ",LASTUP W:REPEAT "  x",REPEAT
"RTN","HMPDJFSM",159,0)
 I $D(^XTMP(STREAM)) D
"RTN","HMPDJFSM",160,0)
 . W !,?29,"End of Queue: ",$P(STREAM,"~",3),"-",$G(^XTMP(STREAM,"last"))
"RTN","HMPDJFSM",161,0)
 ; loop thru extracts for this server
"RTN","HMPDJFSM",162,0)
 S ROOT="HMPFX~"_SRVNM_"~",BATCH=ROOT
"RTN","HMPDJFSM",163,0)
 S BATCH=ROOT F  S BATCH=$O(^XTMP(BATCH)) Q:$E(BATCH,1,$L(ROOT))'=ROOT  D
"RTN","HMPDJFSM",164,0)
 . W !,$J($P(BATCH,"~",3),12)
"RTN","HMPDJFSM",165,0)
 . S TASK=0,TASKS=""
"RTN","HMPDJFSM",166,0)
 . F  S TASK=$O(^XTMP(BATCH,0,"task",TASK)) Q:'TASK  S TASKS=TASKS_$S($L(TASKS):",",1:"")_TASK
"RTN","HMPDJFSM",167,0)
 . W ?14,"Task(s)"_TASKS
"RTN","HMPDJFSM",168,0)
 . I '$D(^XTMP(BATCH,0,"wait")) W ?34,"waiting: ",$$WAIT(BATCH)," seconds" Q
"RTN","HMPDJFSM",169,0)
 . W ?31,"extracting: ",$$LOBJ(BATCH,TASK)
"RTN","HMPDJFSM",170,0)
 Q
"RTN","HMPDJFSM",171,0)
WAIT(BATCH) ; Return the number of seconds the batch has been waiting
"RTN","HMPDJFSM",172,0)
 N START
"RTN","HMPDJFSM",173,0)
 S START=$G(^XTMP(BATCH,0,"time")) Q:'START 0
"RTN","HMPDJFSM",174,0)
 Q $$HDIFF^XLFDT($H,START,2)
"RTN","HMPDJFSM",175,0)
 ;
"RTN","HMPDJFSM",176,0)
LOBJ(BATCH,TASK) ; Return the last domain>count retrieved for this batch
"RTN","HMPDJFSM",177,0)
 Q:'TASK "no task"
"RTN","HMPDJFSM",178,0)
 N LASTITM,DOMAIN,NUM
"RTN","HMPDJFSM",179,0)
 S LASTITM=""
"RTN","HMPDJFSM",180,0)
 S DOMAIN="",LASTITM=""
"RTN","HMPDJFSM",181,0)
 F  S DOMAIN=$O(^XTMP(BATCH,0,"status",DOMAIN)) Q:'$L(DOMAIN)  D  Q:$L(LASTITM)
"RTN","HMPDJFSM",182,0)
 . I $G(^XTMP(BATCH,0,"status",DOMAIN)) Q  ; domain complete
"RTN","HMPDJFSM",183,0)
 . S NUM=$O(^XTMP(BATCH,TASK,DOMAIN,""),-1)
"RTN","HMPDJFSM",184,0)
 . S LASTITM=DOMAIN_$S(NUM:" #"_NUM,1:"")
"RTN","HMPDJFSM",185,0)
 Q $S('$L(LASTITM):"<finished>",1:LASTITM)
"RTN","HMPDJFSM",186,0)
 ;
"RTN","HMPDJFSM",187,0)
SLOTS() ; Return the number of slots available
"RTN","HMPDJFSM",188,0)
 N OUT
"RTN","HMPDJFSM",189,0)
 D FIND^DIC(3.54,"","1","BX","HMP EXTRACT RESOURCE","","","","","OUT")
"RTN","HMPDJFSM",190,0)
 Q $G(OUT("DILIST","ID",1,1))
"RTN","HMPDJFSM",191,0)
 ;
"RTN","HMPDJFSM",192,0)
LJOBS(SRV) ; Show jobs polling in this stream
"RTN","HMPDJFSM",193,0)
 N STREAM,JOBLIST,JOBNUM,JOBNA,X,Y
"RTN","HMPDJFSM",194,0)
 S STREAM=$$LSTREAM(SRV),JOBLIST="",JOBNA=0
"RTN","HMPDJFSM",195,0)
 S JOBNUM="" F  S JOBNUM=$O(^XTMP(STREAM,"job",JOBNUM)) Q:'JOBNUM  D
"RTN","HMPDJFSM",196,0)
 . ; check if job is still active
"RTN","HMPDJFSM",197,0)
 . S X=JOBNUM X ^%ZOSF("JOBPARAM") I '$L(Y) S JOBNA=JOBNA+1 QUIT  ; check if job active
"RTN","HMPDJFSM",198,0)
 . S JOBLIST=JOBLIST_$S($L(JOBLIST):", ",1:"")_JOBNUM
"RTN","HMPDJFSM",199,0)
 W !!,"Polling job number(s):  "_JOBLIST
"RTN","HMPDJFSM",200,0)
 I JOBNA W "  ("_JOBNA_" no longer active)"
"RTN","HMPDJFSM",201,0)
 Q
"RTN","HMPDJFSM",202,0)
LQUEUE(SRV,MAX) ; Show last MAX items in freshness queue
"RTN","HMPDJFSM",203,0)
 W !!,"Last items in the queue ---"
"RTN","HMPDJFSM",204,0)
 N CNT,SEQ,LIST,STREAM
"RTN","HMPDJFSM",205,0)
 S STREAM=$$LSTREAM(SRV)
"RTN","HMPDJFSM",206,0)
 S CNT=0,SEQ=" " ; reverse from space to get numeric entries
"RTN","HMPDJFSM",207,0)
 F  S SEQ=$O(^XTMP(STREAM,SEQ),-1) Q:'SEQ  D  Q:CNT>9
"RTN","HMPDJFSM",208,0)
 . S CNT=CNT+1
"RTN","HMPDJFSM",209,0)
 . S LIST(SEQ)=^XTMP(STREAM,SEQ)
"RTN","HMPDJFSM",210,0)
 S SEQ="" F  S SEQ=$O(LIST(SEQ)) Q:'SEQ  W !,SEQ,?8,LIST(SEQ)
"RTN","HMPDJFSM",211,0)
 Q
"RTN","HMPDJFSM",212,0)
LSTREAM(SRV) ; Return the latest stream for this server
"RTN","HMPDJFSM",213,0)
 N STREAM
"RTN","HMPDJFSM",214,0)
 S STREAM="HMPFS~"_$P($G(^HMP(800000,SRV,0)),"^")_"~9999999"
"RTN","HMPDJFSM",215,0)
 S STREAM=$O(^XTMP(STREAM),-1)
"RTN","HMPDJFSM",216,0)
 Q STREAM
"RTN","HMPDJFSM",217,0)
 ;
"RTN","HMPDJFSM",218,0)
EMERSTOP ; Emergency Stop for Freshness
"RTN","HMPDJFSM",219,0)
 D SETFRUP(0)
"RTN","HMPDJFSM",220,0)
 Q
"RTN","HMPDJFSM",221,0)
RSTRTFR ; Re-start freshness updates
"RTN","HMPDJFSM",222,0)
 D SETFRUP(1)
"RTN","HMPDJFSM",223,0)
 Q
"RTN","HMPDJFSM",224,0)
SETFRUP(START) ; Set flag for freshness updates
"RTN","HMPDJFSM",225,0)
 I 'START D
"RTN","HMPDJFSM",226,0)
 . W !,"WARNING!  This will stop freshness updates for the HMP."
"RTN","HMPDJFSM",227,0)
 . W !,"          It will be necessary to re-synch patient data.",!
"RTN","HMPDJFSM",228,0)
 I START D
"RTN","HMPDJFSM",229,0)
 . W !,"This will --RESUME-- freshness updates for the HMP."
"RTN","HMPDJFSM",230,0)
 . W !,"It may be necessary to re-synch patient and operational data.",!
"RTN","HMPDJFSM",231,0)
 N TYPLST,ALPHA,I,TYPE
"RTN","HMPDJFSM",232,0)
 D EVNTYPS(.TYPLST)
"RTN","HMPDJFSM",233,0)
 S I=0 F  S I=$O(TYPLST(I)) Q:'I  S ALPHA(TYPLST(I))=""
"RTN","HMPDJFSM",234,0)
 S TYPE=$$GETFTYP(.ALPHA,START)
"RTN","HMPDJFSM",235,0)
 Q:TYPE=""
"RTN","HMPDJFSM",236,0)
 I TYPE="*" D  Q
"RTN","HMPDJFSM",237,0)
 . S TYPE="" F  S TYPE=$O(ALPHA(TYPE)) Q:TYPE=""  D CHGFTYP(TYPE,START)
"RTN","HMPDJFSM",238,0)
 D CHGFTYP(TYPE,START)
"RTN","HMPDJFSM",239,0)
 Q
"RTN","HMPDJFSM",240,0)
CHGFTYP(TYPE,START) ; Change the freshness update flag for a type
"RTN","HMPDJFSM",241,0)
 I START D STRTFTYP(TYPE) Q
"RTN","HMPDJFSM",242,0)
 ; otherwise
"RTN","HMPDJFSM",243,0)
 D STOPFTYP(TYPE)
"RTN","HMPDJFSM",244,0)
 Q
"RTN","HMPDJFSM",245,0)
STOPFTYP(TYPE) ; Stop freshness updates for type
"RTN","HMPDJFSM",246,0)
 I '$D(^XTMP("HMP-off",0)) D NEWXTMP^HMPDJFS("HMP-off",999,"Switch off HMP freshness updates")
"RTN","HMPDJFSM",247,0)
 W !,"Stopping freshness updates for: ",TYPE
"RTN","HMPDJFSM",248,0)
 S ^XTMP("HMP-off",TYPE)=1
"RTN","HMPDJFSM",249,0)
 Q
"RTN","HMPDJFSM",250,0)
STRTFTYP(TYPE) ; Resume freshness updates for type
"RTN","HMPDJFSM",251,0)
 W !,"Resuming freshness updates for: ",TYPE
"RTN","HMPDJFSM",252,0)
 K ^XTMP("HMP-off",TYPE)
"RTN","HMPDJFSM",253,0)
 Q
"RTN","HMPDJFSM",254,0)
GETFTYP(ALPHA,START) ; Return item from the list
"RTN","HMPDJFSM",255,0)
 N X,T,P
"RTN","HMPDJFSM",256,0)
 S P=$S(START:"start",1:"stop")
"RTN","HMPDJFSM",257,0)
 F  D  Q:X'["?"
"RTN","HMPDJFSM",258,0)
 . D SHOWFTYP(.ALPHA)
"RTN","HMPDJFSM",259,0)
 . W !!,"Choose domain to "_P_" (* "_P_"s all): "
"RTN","HMPDJFSM",260,0)
 . R X:300 S:$E(X)="^" X="" Q:X=""  Q:X="*"
"RTN","HMPDJFSM",261,0)
 . S X=$$LOW^XLFSTR(X)
"RTN","HMPDJFSM",262,0)
 . Q:$D(ALPHA(X))
"RTN","HMPDJFSM",263,0)
 . S T=$O(ALPHA(X))
"RTN","HMPDJFSM",264,0)
 . I X=$E(T,1,$L(X)) W "  ",T S X=T Q
"RTN","HMPDJFSM",265,0)
 . W "  ??",! S X="?"
"RTN","HMPDJFSM",266,0)
 Q X
"RTN","HMPDJFSM",267,0)
 ;
"RTN","HMPDJFSM",268,0)
SHOWFTYP(ALPHA) ; Show freshness types
"RTN","HMPDJFSM",269,0)
 N I,X,P
"RTN","HMPDJFSM",270,0)
 S I=0,X="" F  S X=$O(ALPHA(X)) Q:'$L(X)  D
"RTN","HMPDJFSM",271,0)
 . S I=I+1,P=I#3
"RTN","HMPDJFSM",272,0)
 . W:P=1 !,X
"RTN","HMPDJFSM",273,0)
 . W:P=2 ?26,X
"RTN","HMPDJFSM",274,0)
 . W:P=0 ?52,X
"RTN","HMPDJFSM",275,0)
 Q
"RTN","HMPDJFSM",276,0)
EVNTYPS(LIST) ; load event types
"RTN","HMPDJFSM",277,0)
 ;;allergy
"RTN","HMPDJFSM",278,0)
 ;;med
"RTN","HMPDJFSM",279,0)
 ;;auxiliary
"RTN","HMPDJFSM",280,0)
 ;;appointment
"RTN","HMPDJFSM",281,0)
 ;;diagnosis
"RTN","HMPDJFSM",282,0)
 ;;document
"RTN","HMPDJFSM",283,0)
 ;;factor
"RTN","HMPDJFSM",284,0)
 ;;immunization
"RTN","HMPDJFSM",285,0)
 ;;lab
"RTN","HMPDJFSM",286,0)
 ;;obs
"RTN","HMPDJFSM",287,0)
 ;;order
"RTN","HMPDJFSM",288,0)
 ;;problem
"RTN","HMPDJFSM",289,0)
 ;;procedure
"RTN","HMPDJFSM",290,0)
 ;;consult
"RTN","HMPDJFSM",291,0)
 ;;image
"RTN","HMPDJFSM",292,0)
 ;;surgery
"RTN","HMPDJFSM",293,0)
 ;;task
"RTN","HMPDJFSM",294,0)
 ;;visit
"RTN","HMPDJFSM",295,0)
 ;;vital
"RTN","HMPDJFSM",296,0)
 ;;mh
"RTN","HMPDJFSM",297,0)
 ;;ptf
"RTN","HMPDJFSM",298,0)
 ;;exam
"RTN","HMPDJFSM",299,0)
 ;;cpt
"RTN","HMPDJFSM",300,0)
 ;;education
"RTN","HMPDJFSM",301,0)
 ;;pov
"RTN","HMPDJFSM",302,0)
 ;;skin
"RTN","HMPDJFSM",303,0)
 ;;treatment
"RTN","HMPDJFSM",304,0)
 ;;roadtrip
"RTN","HMPDJFSM",305,0)
 ;;diet
"RTN","HMPDJFSM",306,0)
 ;;pt-select
"RTN","HMPDJFSM",307,0)
 ;;patient
"RTN","HMPDJFSM",308,0)
 ;;roster
"RTN","HMPDJFSM",309,0)
 ;;user
"RTN","HMPDJFSM",310,0)
 ;;zzzzz
"RTN","HMPDJFSM",311,0)
 N I,X
"RTN","HMPDJFSM",312,0)
 F I=1:1 S X=$P($T(EVNTYPS+I),";;",2,99) Q:X="zzzzz"  S LIST(I)=X
"RTN","HMPDJFSM",313,0)
 Q
"RTN","HMPDJFSM",314,0)
 ;
"RTN","HMPDJFSP")
0^92^B228347668^B228347665
"RTN","HMPDJFSP",1,0)
HMPDJFSP ;SLC/KCM,ASMR/RRB,CPC -- PUT/POST for Extract and Freshness Stream;May 15, 2016 14:15
"RTN","HMPDJFSP",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPDJFSP",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPDJFSP",4,0)
 ;
"RTN","HMPDJFSP",5,0)
 ; DE2818/RRB: SQA findings 1st 3 lines
"RTN","HMPDJFSP",6,0)
 Q
"RTN","HMPDJFSP",7,0)
 ;
"RTN","HMPDJFSP",8,0)
 ; --- create a new patient subscription
"RTN","HMPDJFSP",9,0)
 ;
"RTN","HMPDJFSP",10,0)
PUTSUB(ARGS) ; return location after creating a new subscription
"RTN","HMPDJFSP",11,0)
 ;  fn returns      : /hmp/subscription/{hmpSrvId}/patient/{sysId;dfn}
"RTN","HMPDJFSP",12,0)
 ;                  : "" if error, errors in ^TMP("HMPFERR",$J)
"RTN","HMPDJFSP",13,0)
 ; .ARGS("server")  : name of HMP server
"RTN","HMPDJFSP",14,0)
 ; .ARGS("localId") : dfn for patient to subscribe or "OPD" (operational data)
"RTN","HMPDJFSP",15,0)
 ; .ARGS("icn")     : icn for patient to subscribe
"RTN","HMPDJFSP",16,0)
 ; .ARGS("domains") : optional array of domains to initialize (deprecated)
"RTN","HMPDJFSP",17,0)
 ;
"RTN","HMPDJFSP",18,0)
 I '$$TM^%ZTLOAD D SETERR^HMPDJFS("Taskman not running") Q ""
"RTN","HMPDJFSP",19,0)
 ;
"RTN","HMPDJFSP",20,0)
 N HMPSRV,HMPFDFN,HMPBATCH,HMPFERR,I,NEWSUB,DOMAINS,HMPSVERS,HMPSTMP
"RTN","HMPDJFSP",21,0)
 ;
"RTN","HMPDJFSP",22,0)
 ; make sure we can identify the patient ("OPD" signals sync operational)
"RTN","HMPDJFSP",23,0)
 S HMPFDFN=$G(ARGS("localId"))
"RTN","HMPDJFSP",24,0)
 S HMPSVERS=+$G(ARGS("HMPSVERS")) ;US11019 get sync version
"RTN","HMPDJFSP",25,0)
 I HMPFDFN'="OPD" D  Q:$G(HMPFERR) ""
"RTN","HMPDJFSP",26,0)
 . I '$L(HMPFDFN),$L(ARGS("icn")) S HMPFDFN=+$$GETDFN^MPIF001(ARGS("icn"))
"RTN","HMPDJFSP",27,0)
 . I 'HMPFDFN D SETERR^HMPDJFS("No patient specified") Q
"RTN","HMPDJFSP",28,0)
 . I '$D(^DPT(HMPFDFN)) D SETERR^HMPDJFS("Patient not found")  ; IA 10035, DE2818
"RTN","HMPDJFSP",29,0)
 ;
"RTN","HMPDJFSP",30,0)
 ; make sure server is known and create batch id
"RTN","HMPDJFSP",31,0)
 S HMPSRV=HMPFHMP  ; TODO: switch to HMPFHMP as server ien
"RTN","HMPDJFSP",32,0)
 I '$L(HMPSRV) D SETERR^HMPDJFS("Missing HMP Server ID") Q ""
"RTN","HMPDJFSP",33,0)
 S HMPSRV("ien")=$O(^HMP(800000,"B",HMPSRV,0))
"RTN","HMPDJFSP",34,0)
 I 'HMPSRV("ien") D SETERR^HMPDJFS("HMP Server not registered") Q ""
"RTN","HMPDJFSP",35,0)
 S HMPBATCH="HMPFX~"_HMPSRV_"~"_HMPFDFN
"RTN","HMPDJFSP",36,0)
 ;
"RTN","HMPDJFSP",37,0)
 ; set up domains to extract
"RTN","HMPDJFSP",38,0)
 D @($S(HMPFDFN="OPD":"OPDOMS",1:"PTDOMS")_"^HMPDJFSD(.DOMAINS)")
"RTN","HMPDJFSP",39,0)
 ;
"RTN","HMPDJFSP",40,0)
 ; ejk US5647
"RTN","HMPDJFSP",41,0)
 ; code below restores selective domain functionality. 
"RTN","HMPDJFSP",42,0)
 ; once the complete list of domains is returned from HMPDJFSD,
"RTN","HMPDJFSP",43,0)
 ; if ARGS("domains") is passed in, anything not in that parameter
"RTN","HMPDJFSP",44,0)
 ; will be excluded from the ODS extract.
"RTN","HMPDJFSP",45,0)
 I $G(ARGS("domains"))'="" D
"RTN","HMPDJFSP",46,0)
 .F I=1:1 Q:'$D(DOMAINS(I))  I ARGS("domains")'[DOMAINS(I) K DOMAINS(I)
"RTN","HMPDJFSP",47,0)
 ;
"RTN","HMPDJFSP",48,0)
 ; see if this is new subscription and task extract if new
"RTN","HMPDJFSP",49,0)
 D SETPAT(HMPFDFN,HMPSRV,.NEWSUB) Q:$G(HMPFERR) ""
"RTN","HMPDJFSP",50,0)
 ;For operational data set stamptime as time subscription placed US6734
"RTN","HMPDJFSP",51,0)
 S HMPSTMP=$$EN^HMPSTMP("NOW") ;DE3377
"RTN","HMPDJFSP",52,0)
 ;
"RTN","HMPDJFSP",53,0)
 ;cpc US11019 following chunk of code moved out of QUINIT as was being called multiple times
"RTN","HMPDJFSP",54,0)
 ;US11019 get array of job ids by domain
"RTN","HMPDJFSP",55,0)
 ; only done once when beginning the batch, no matter how many tasked jobs
"RTN","HMPDJFSP",56,0)
 L +^XTMP(HMPBATCH):5 E  D SETERR^HMPDJFS("Cannot lock batch:"_HMPBATCH) QUIT
"RTN","HMPDJFSP",57,0)
 I '$D(^XTMP(HMPBATCH)) D
"RTN","HMPDJFSP",58,0)
 . D NEWXTMP^HMPDJFS(HMPBATCH,2,"HMP Patient Extract")
"RTN","HMPDJFSP",59,0)
 . ;US11019 - store domain specific job ids
"RTN","HMPDJFSP",60,0)
 . N EMPB S EMPB="jobDomainId-" ;US11019
"RTN","HMPDJFSP",61,0)
 . F  S EMPB=$O(ARGS(EMPB)) Q:EMPB=""  Q:EMPB'["jobDomainId-"  S:'HMPSVERS HMPSVERS=1 S ^XTMP(HMPBATCH,"JOBID",$P(EMPB,"jobDomainId-",2))=ARGS(EMPB) ; US11019 3rd version
"RTN","HMPDJFSP",62,0)
 . S ^XTMP(HMPBATCH,"HMPSVERS")=HMPSVERS ;US11019 store sync version
"RTN","HMPDJFSP",63,0)
 . I $G(ARGS("jobId"))]"" S ^XTMP(HMPBATCH,"JOBID")=ARGS("jobId")  ;US3907 /US11019
"RTN","HMPDJFSP",64,0)
 . I $G(ARGS("rootJobId"))]"" S ^XTMP(HMPBATCH,"ROOTJOBID")=ARGS("rootJobId")  ;US3907
"RTN","HMPDJFSP",65,0)
 . S ^XTMP(HMPBATCH,0,"time")=$H
"RTN","HMPDJFSP",66,0)
 . ; US6734 - setting of syncStart for OPD only
"RTN","HMPDJFSP",67,0)
 . I HMPFDFN="OPD" D SETMARK("Start",HMPFDFN,HMPBATCH),INIT^HMPMETA(HMPBATCH,HMPFDFN,.ARGS) ; US6734 
"RTN","HMPDJFSP",68,0)
 L -^XTMP(HMPBATCH)
"RTN","HMPDJFSP",69,0)
 ;cpc US11019 end moved code
"RTN","HMPDJFSP",70,0)
 ;Every Domain in it's own task (unless running in original mode)
"RTN","HMPDJFSP",71,0)
 I NEWSUB D  Q:$G(HMPFERR) ""
"RTN","HMPDJFSP",72,0)
 . ; if patient's extracts are held (version mismatch), put DFN on wait list
"RTN","HMPDJFSP",73,0)
 . I +HMPFDFN,$G(^XTMP("HMPFS~"_HMPSRV("ien"),"waiting")) S ^XTMP("HMPFS~"_HMPSRV("ien"),"waiting",HMPFDFN)="" QUIT
"RTN","HMPDJFSP",74,0)
 . D UPDSTS(HMPFDFN,$P(HMPBATCH,"~",2),1) ;moved from background job to once in foreground 12/17/2015
"RTN","HMPDJFSP",75,0)
 . I 'HMPSVERS N HMPFDOM M HMPFDOM=DOMAINS D QUINIT(HMPBATCH,HMPFDFN,.HMPFDOM) Q  ;US11019 Enable previous behavior
"RTN","HMPDJFSP",76,0)
 . S I="" F  S I=$O(DOMAINS(I)) Q:'I  D
"RTN","HMPDJFSP",77,0)
 ..  N HMPFDOM
"RTN","HMPDJFSP",78,0)
 ..  S HMPFDOM(1)=DOMAINS(I)
"RTN","HMPDJFSP",79,0)
 ..  D QUINIT(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPDJFSP",80,0)
 ;===JD START===
"RTN","HMPDJFSP",81,0)
 ; For patient resubscribes, need to send demographics ONLY
"RTN","HMPDJFSP",82,0)
 I 'NEWSUB,HMPFDFN'="OPD",'$D(^XTMP(HMPBATCH,0,"status")) D  ;DE3331 check expanded to ensure not current
"RTN","HMPDJFSP",83,0)
 . N HMPFDOM,HMPDSAVE ;DE3331
"RTN","HMPDJFSP",84,0)
 . M HMPDSAVE=DOMAINS ;DE3331
"RTN","HMPDJFSP",85,0)
 . K DOMAINS S DOMAINS(1)="patient"
"RTN","HMPDJFSP",86,0)
 . M HMPFDOM=DOMAINS
"RTN","HMPDJFSP",87,0)
 . D QUINIT(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPDJFSP",88,0)
 . I $G(HMPSVERS) S I="" F  S I=$O(HMPDSAVE(I)) Q:'I  D  ;DE3331 create empty metastamp entries for remaining domains
"RTN","HMPDJFSP",89,0)
 ..  I HMPDSAVE(I)'="patient" D SETMARK("Meta",HMPFDFN,HMPDSAVE(I))
"RTN","HMPDJFSP",90,0)
 ;===JD END===
"RTN","HMPDJFSP",91,0)
 Q "/hmp/subscription/"_HMPSRV_"/patient/"_$$PID^HMPDJFS(HMPFDFN)
"RTN","HMPDJFSP",92,0)
 ;
"RTN","HMPDJFSP",93,0)
QUINIT(HMPBATCH,HMPFDFN,HMPFDOM) ; Queue the initial extracts for a patient
"RTN","HMPDJFSP",94,0)
 ; HMPBATCH="HMPFX~hmpsrvid~dfn"  example: HMPFX~hmpXYZ~229
"RTN","HMPDJFSP",95,0)
 ; HMPFDOM(n)="domainName"
"RTN","HMPDJFSP",96,0)
 ; 
"RTN","HMPDJFSP",97,0)
 ; ^XTMP("HMPFX~hmpsrvid~dfn",0)=expires^created^HMP Patient Extract
"RTN","HMPDJFSP",98,0)
 ;                           ,0,"status",domain)=0:waiting;1:ready
"RTN","HMPDJFSP",99,0)
 ;                           ,0,"task",taskIen)=""
"RTN","HMPDJFSP",100,0)
 ;                           ,taskIen,domain,... (extract data)
"RTN","HMPDJFSP",101,0)
 ;
"RTN","HMPDJFSP",102,0)
 ; set up the domains to be done by this task
"RTN","HMPDJFSP",103,0)
 N I S I=0 F  S I=$O(HMPFDOM(I)) Q:'I  D SETDOM("status",HMPFDOM(I),0)
"RTN","HMPDJFSP",104,0)
 ;
"RTN","HMPDJFSP",105,0)
 ; create task for this set of domains within the batch
"RTN","HMPDJFSP",106,0)
 N ZTRTN,ZTDESC,ZTDTH,ZTIO,ZTSAVE,ZTSK
"RTN","HMPDJFSP",107,0)
 S ZTRTN="DQINIT^HMPDJFSP",ZTIO="HMP EXTRACT RESOURCE",ZTDTH=$H
"RTN","HMPDJFSP",108,0)
 S ZTSAVE("HMPBATCH")="",ZTSAVE("HMPFDFN")="",ZTSAVE("HMPFDOM(")=""
"RTN","HMPDJFSP",109,0)
 S ZTSAVE("HMPENVIR(")=""  ; environment information
"RTN","HMPDJFSP",110,0)
 S ZTSAVE("HMPSTMP")="" ; Operational data stamptime US6734
"RTN","HMPDJFSP",111,0)
 S ZTSAVE("HMPSVERS")="" ;sync version US11019
"RTN","HMPDJFSP",112,0)
 S ZTDESC="Build HMP domains for a patient"
"RTN","HMPDJFSP",113,0)
 D ^%ZTLOAD
"RTN","HMPDJFSP",114,0)
 I $G(ZTSK) S ^XTMP(HMPBATCH,0,"task",ZTSK)="" Q
"RTN","HMPDJFSP",115,0)
 D SETERR^HMPDJFS("Task not created")
"RTN","HMPDJFSP",116,0)
 Q
"RTN","HMPDJFSP",117,0)
SETDOM(ATTRIB,DOMAIN,VALUE,HMPMETA) ; Set value for a domain ; cpc TA41760
"RTN","HMPDJFSP",118,0)
 ; ATTRIB: "status" or "count" attribute
"RTN","HMPDJFSP",119,0)
 ; for status, VALUE: 0=waiting, 1=ready
"RTN","HMPDJFSP",120,0)
 ; for count,  VALUE: count of items
"RTN","HMPDJFSP",121,0)
 ;don't update to finished value if just tracking metastamp
"RTN","HMPDJFSP",122,0)
 I $G(HMPMETA)'="" S ^XTMP(HMPBATCH,0,ATTRIB,DOMAIN,$S(HMPMETA=1:"MetaStamp",HMPMETA=2:"Combined",1:"Staging"),$S(VALUE:"Stop",1:"Start"))=$H Q:(HMPMETA=1&VALUE)  ;cpc TA41760 10/7/2015 add time logging
"RTN","HMPDJFSP",123,0)
 S ^XTMP(HMPBATCH,0,ATTRIB,DOMAIN)=VALUE
"RTN","HMPDJFSP",124,0)
 Q
"RTN","HMPDJFSP",125,0)
SETMARK(TYPE,HMPFDFN,HMPBATCH) ; Post markers for begin and end of initial synch
"RTN","HMPDJFSP",126,0)
 ; ^XTMP("HMPFP","tidy",hmpServer,fmDate,sequence)=batch
"RTN","HMPDJFSP",127,0)
 Q:$G(HMPENVIR("converting"))  ; don't set markers during conversion
"RTN","HMPDJFSP",128,0)
 N HMPSRV,NODES,X
"RTN","HMPDJFSP",129,0)
 S HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",130,0)
 D POST^HMPDJFS(HMPFDFN,"sync"_TYPE,HMPBATCH,"",HMPSRV,.NODES)
"RTN","HMPDJFSP",131,0)
 Q:TYPE="Start"!(TYPE="Meta")  ; US11019
"RTN","HMPDJFSP",132,0)
 D SETTIDY("<done>",.NODES)
"RTN","HMPDJFSP",133,0)
 Q
"RTN","HMPDJFSP",134,0)
 ;
"RTN","HMPDJFSP",135,0)
DQINIT ; Dequeue initial extracts
"RTN","HMPDJFSP",136,0)
 ; expects:  HMPBATCH, HMPFDFN, HMPFDOM, ZTSK
"RTN","HMPDJFSP",137,0)
 N COUNT,HMPFDOMI,HMPFSYS,HMPFZTSK
"RTN","HMPDJFSP",138,0)
 F COUNT=1:1:10 Q:$D(^XTMP(HMPBATCH,0,"task",ZTSK))  H .5 ;cpc 9/18/2015 In case job running too quickly
"RTN","HMPDJFSP",139,0)
 I '$D(^XTMP(HMPBATCH,0,"task",ZTSK)) Q  ; extract was superceded
"RTN","HMPDJFSP",140,0)
 K ^TMP("HMPERR",$J)
"RTN","HMPDJFSP",141,0)
 S HMPFSYS=$$GET^XPAR("SYS","HMP SYSTEM NAME")
"RTN","HMPDJFSP",142,0)
 S HMPFZTSK=ZTSK ; just in case the unexpected happens to ZTSK
"RTN","HMPDJFSP",143,0)
 S ^XTMP(HMPBATCH,0,"task",ZTSK,"job")=$J
"RTN","HMPDJFSP",144,0)
 S ^XTMP(HMPBATCH,0,"task",ZTSK,"wait")=$$HDIFF^XLFDT($H,$G(^XTMP(HMPBATCH,0,"time")),2)
"RTN","HMPDJFSP",145,0)
 ;
"RTN","HMPDJFSP",146,0)
 ;  S68 check space
"RTN","HMPDJFSP",147,0)
 D CHKSP^HMPUTILS($P(HMPBATCH,"~",2)) ; US8228
"RTN","HMPDJFSP",148,0)
 N HMPMETA ; US6734
"RTN","HMPDJFSP",149,0)
 F HMPMETA=$S(HMPSVERS:2,1:1):-1:0 D  Q:HMPMETA=2  ;
"RTN","HMPDJFSP",150,0)
 . I HMPMETA=0,+HMPFDFN D SETMARK("Start",HMPFDFN,HMPBATCH) ; US6734
"RTN","HMPDJFSP",151,0)
 . S HMPFDOMI=""
"RTN","HMPDJFSP",152,0)
 . F  S HMPFDOMI=$O(HMPFDOM(HMPFDOMI)) Q:'HMPFDOMI  D
"RTN","HMPDJFSP",153,0)
 ..  D SETDOM("status",HMPFDOM(HMPFDOMI),0,HMPMETA) ; cpc TA41760
"RTN","HMPDJFSP",154,0)
 ..  I HMPFDFN="OPD" D
"RTN","HMPDJFSP",155,0)
 ...   D DOMOPD(HMPFDOM(HMPFDOMI))
"RTN","HMPDJFSP",156,0)
 ...   I HMPMETA=2 D UPD^HMPMETA(HMPFDOM(HMPFDOMI)) ; US6734 - mark OPD domain as complete in metastamp
"RTN","HMPDJFSP",157,0)
 ..  I +HMPFDFN D DOMPT(HMPFDOM(HMPFDOMI))
"RTN","HMPDJFSP",158,0)
 ..  I HMPMETA=1 D:'$O(HMPFDOM(HMPFDOMI)) MERGE^HMPMETA(HMPBATCH) D:HMPFDFN="OPD" UPD^HMPMETA(HMPFDOM(HMPFDOMI)) Q
"RTN","HMPDJFSP",159,0)
 ..  I HMPMETA=2 D
"RTN","HMPDJFSP",160,0)
 ...   D MERGE1^HMPMETA(HMPBATCH,HMPFDOM(HMPFDOMI)) ;US11019 - merge data into metastamp
"RTN","HMPDJFSP",161,0)
 ...   I +HMPFDFN D SETMARK("Meta",HMPFDFN,HMPFDOM(HMPFDOMI)) ;US11019 - new freshness entry replacing syncStart
"RTN","HMPDJFSP",162,0)
 ...   I HMPFDFN="OPD" D:'$O(HMPFDOM(HMPFDOMI)) MERGE^HMPMETA(HMPBATCH) ; US6734 - merge data into metastamp
"RTN","HMPDJFSP",163,0)
 ..  D SETDOM("status",HMPFDOM(HMPFDOMI),1,HMPMETA) ; ready ; cpc TA41760
"RTN","HMPDJFSP",164,0)
 ..  ; if superceded, stop processing domains
"RTN","HMPDJFSP",165,0)
 ..  I '$D(^XTMP(HMPBATCH,0,"task",HMPFZTSK)) S HMPFDOMI=999 Q
"RTN","HMPDJFSP",166,0)
 ..  ; -- if more domains, check ^XTMP size before continuing; may have to HANG if too big  *BEGIN*S68-JCH*
"RTN","HMPDJFSP",167,0)
 ..  I +HMPFDFN,HMPFDOMI'=+$O(HMPFDOM(""),-1) D CHKXTMP(HMPBATCH,HMPFZTSK) ;; US 5074 - removed
"RTN","HMPDJFSP",168,0)
 ; if superceded, remove extracts produced by this task
"RTN","HMPDJFSP",169,0)
 I '$D(^XTMP(HMPBATCH,0,"task",HMPFZTSK)) K ^XTMP(HMPBATCH,HMPFZTSK) Q
"RTN","HMPDJFSP",170,0)
 ; don't assume initialized, since we may split domains to other tasks
"RTN","HMPDJFSP",171,0)
 I $$INITDONE(HMPBATCH) D  ; if all domains extracted
"RTN","HMPDJFSP",172,0)
 . S COUNT=$O(^TMP("HMPERR",$J,"")) I COUNT>0 D POSTERR(COUNT,HMPFDFN)
"RTN","HMPDJFSP",173,0)
 . D SETMARK("Done",HMPFDFN,HMPBATCH) ; - add updated syncStatus
"RTN","HMPDJFSP",174,0)
 . D MVFRUPD(HMPBATCH,HMPFDFN)        ; - move freshness updates over
"RTN","HMPDJFSP",175,0)
 ;
"RTN","HMPDJFSP",176,0)
 K ^XTMP(HMPBATCH,0,"task",HMPFZTSK)  ; this task is done
"RTN","HMPDJFSP",177,0)
 Q
"RTN","HMPDJFSP",178,0)
 ;
"RTN","HMPDJFSP",179,0)
DOMPT(HMPFADOM) ; Load a patient domain
"RTN","HMPDJFSP",180,0)
 N FILTER,RSLT,HMPFEST,HMPCHNK  ; *S68-JCH*
"RTN","HMPDJFSP",181,0)
 S FILTER("noHead")=1
"RTN","HMPDJFSP",182,0)
 S FILTER("domain")=HMPFADOM
"RTN","HMPDJFSP",183,0)
 S FILTER("patientId")=HMPFDFN
"RTN","HMPDJFSP",184,0)
 ; -- domain var used for chunking patient objects using <domain>#<number> construct  *BEGIN*S68-JCH*
"RTN","HMPDJFSP",185,0)
 S HMPCHNK=HMPFADOM
"RTN","HMPDJFSP",186,0)
 S HMPCHNK("trigger count")=$$CHNKCNT(HMPFADOM)  ; *END*S68-JCH*
"RTN","HMPDJFSP",187,0)
 D GET^HMPDJ(.RSLT,.FILTER) ;US11019 I $G(HMPMETA) D SETDOM("status",HMPFADOM,1,1) Q  ;US11019/US6734 - do not update stream if compiling metastamp ; CPC TA41760
"RTN","HMPDJFSP",188,0)
 I $G(HMPMETA)=1 D SETDOM("status",HMPFADOM,1,1) Q  ;US11019/US6734 - do not update stream if compiling metastamp ; CPC TA41760
"RTN","HMPDJFSP",189,0)
 ; add to HMPFS queue if total>0 OR this is the first chunck (#0) section  *S68-JCH*
"RTN","HMPDJFSP",190,0)
 I ($G(@RSLT@("total"),0)>0)!($P(HMPCHNK,"#",2)=0) D CHNKFIN  ; *S68-JCH*
"RTN","HMPDJFSP",191,0)
 Q
"RTN","HMPDJFSP",192,0)
 ;
"RTN","HMPDJFSP",193,0)
DOMOPD(HMPFADOM) ; Load an operational domain in smaller batches
"RTN","HMPDJFSP",194,0)
 ; expects HMPBATCH,HMPFZTSK
"RTN","HMPDJFSP",195,0)
 N FILTER,RSLT,NEXTID,DONE,HMPFEST,HMPFSEC,HMPFSIZE,HMPFLDON ; cpc
"RTN","HMPDJFSP",196,0)
 S HMPFSIZE=1000               ; section size (adjust to taste)
"RTN","HMPDJFSP",197,0)
 S HMPFEST=$$TOTAL(HMPFADOM)   ; set estimated domain total
"RTN","HMPDJFSP",198,0)
 S NEXTID=0,HMPFSEC=0,DONE=0,HMPFLDON=0 ;cpc
"RTN","HMPDJFSP",199,0)
 S HMPFADOM=HMPFADOM_"#"_HMPFSEC
"RTN","HMPDJFSP",200,0)
 F  D  Q:DONE
"RTN","HMPDJFSP",201,0)
 . N FILTER,RSLT
"RTN","HMPDJFSP",202,0)
 . S FILTER("noHead")=1
"RTN","HMPDJFSP",203,0)
 . S FILTER("domain")=HMPFADOM ; include section for ^XTMP location
"RTN","HMPDJFSP",204,0)
 . S FILTER("start")=NEXTID
"RTN","HMPDJFSP",205,0)
 . S FILTER("limit")=HMPFSIZE
"RTN","HMPDJFSP",206,0)
 . D GET^HMPEF(.RSLT,.FILTER)
"RTN","HMPDJFSP",207,0)
 . I $G(HMPMETA)=1 S DONE=1 Q  ;US6734 - do not update stream if compiling metastamp
"RTN","HMPDJFSP",208,0)
 . I '$D(^XTMP(HMPBATCH,0,"task",HMPFZTSK)) S DONE=1 QUIT  ; superceded
"RTN","HMPDJFSP",209,0)
 . I $G(^XTMP(HMPBATCH,HMPFZTSK,HMPFADOM,"total"),0)=0,(HMPFSEC>0) S DONE=1 QUIT
"RTN","HMPDJFSP",210,0)
 . I $G(^XTMP(HMPBATCH,HMPFZTSK,HMPFADOM,"finished")) S DONE=1
"RTN","HMPDJFSP",211,0)
 . D MOD4STRM(HMPFADOM)
"RTN","HMPDJFSP",212,0)
 . I DONE S HMPFEST=^XTMP(HMPBATCH,0,"count",$P(HMPFADOM,"#")) S:'HMPFEST HMPFEST=1
"RTN","HMPDJFSP",213,0)
 . D POSTSEC(HMPFADOM,HMPFEST,HMPFSIZE)
"RTN","HMPDJFSP",214,0)
 . Q:DONE
"RTN","HMPDJFSP",215,0)
 . S NEXTID=$G(^XTMP(HMPBATCH,HMPFZTSK,HMPFADOM,"last"),0)
"RTN","HMPDJFSP",216,0)
 . S HMPFSEC=HMPFSEC+1
"RTN","HMPDJFSP",217,0)
 . S $P(HMPFADOM,"#",2)=HMPFSEC
"RTN","HMPDJFSP",218,0)
 Q
"RTN","HMPDJFSP",219,0)
 ;
"RTN","HMPDJFSP",220,0)
CHNKCNT(DOMAIN) ; -- get patient object chunk count trigger                        *BEGIN*S68-JCH*
"RTN","HMPDJFSP",221,0)
 ; input: DOMAIN := current domain name being processed
"RTN","HMPDJFSP",222,0)
 Q $S(+$$GET^XPAR("PKG","HMP DOMAIN SIZES",$P($G(DOMAIN),"#"),"Q")>3000:500,1:1000)  ; *END*S68-JCH*
"RTN","HMPDJFSP",223,0)
 ;
"RTN","HMPDJFSP",224,0)
CHNKINIT(HMP,HMPI) ; -- init chunk section callback  *BEGIN*S68-JCH*
"RTN","HMPDJFSP",225,0)
 ; input by ref:  HMP := $NA of location for chunk of objects
"RTN","HMPDJFSP",226,0)
 ;               HMPI := number of objects in @HMP
"RTN","HMPDJFSP",227,0)
 ; -- quit if not in chunking mode
"RTN","HMPDJFSP",228,0)
 Q:'$D(HMPCHNK)
"RTN","HMPDJFSP",229,0)
 ;
"RTN","HMPDJFSP",230,0)
 S $P(HMPCHNK,"#",2)=$S(HMPCHNK["#":$P(HMPCHNK,"#",2)+1,1:0)
"RTN","HMPDJFSP",231,0)
 S HMP=$NA(^XTMP(HMPBATCH,HMPFZTSK,HMPCHNK))
"RTN","HMPDJFSP",232,0)
 K @HMP
"RTN","HMPDJFSP",233,0)
 S HMPI=0
"RTN","HMPDJFSP",234,0)
 Q  ; *END*S68-JCH*
"RTN","HMPDJFSP",235,0)
 ;
"RTN","HMPDJFSP",236,0)
CHNKCHK(HMP,HMPI) ; -- check if chunk should be queued callback *BEGIN*S68-JCH*
"RTN","HMPDJFSP",237,0)
 ; (called by ADD^HMPDJ & HMP1^HMPDJ02)
"RTN","HMPDJFSP",238,0)
 ; input by ref:  HMP := $NA of location for chunk of objects
"RTN","HMPDJFSP",239,0)
 ;               HMPI := number of objects in @HMP
"RTN","HMPDJFSP",240,0)
 ; quit if not in chunking mode
"RTN","HMPDJFSP",241,0)
 Q:'$D(HMPCHNK)
"RTN","HMPDJFSP",242,0)
 ;
"RTN","HMPDJFSP",243,0)
 ; execute 'whether to chunk' criteria
"RTN","HMPDJFSP",244,0)
 Q:HMPI<HMPCHNK("trigger count")
"RTN","HMPDJFSP",245,0)
 ; -- add tail to json to section
"RTN","HMPDJFSP",246,0)
 D GTQ^HMPDJ
"RTN","HMPDJFSP",247,0)
 ; -- finish section and put on HMPFS~ queue
"RTN","HMPDJFSP",248,0)
 D CHNKFIN
"RTN","HMPDJFSP",249,0)
 ; -- check ^XTMP size before continuing; may have to HANG if too big
"RTN","HMPDJFSP",250,0)
 D CHKXTMP(HMPBATCH,HMPFZTSK)  ; US5074 disable loopback
"RTN","HMPDJFSP",251,0)
 ; -- initialize for next section
"RTN","HMPDJFSP",252,0)
 D CHNKINIT(.HMP,.HMPI)
"RTN","HMPDJFSP",253,0)
 Q  ; *END*S68-JCH*
"RTN","HMPDJFSP",254,0)
 ;
"RTN","HMPDJFSP",255,0)
CHNKFIN ; -- finish chunk section callback *BEGIN*S68-JCH*
"RTN","HMPDJFSP",256,0)
 ; -- quit if not in chunking mode
"RTN","HMPDJFSP",257,0)
 Q:'$D(HMPCHNK)
"RTN","HMPDJFSP",258,0)
 ;
"RTN","HMPDJFSP",259,0)
 D MOD4STRM(HMPCHNK)
"RTN","HMPDJFSP",260,0)
 ; -- domain#number, <no estimated do> , chunk trigger count for domain
"RTN","HMPDJFSP",261,0)
 D POSTSEC(HMPCHNK,,HMPCHNK("trigger count"))
"RTN","HMPDJFSP",262,0)
 Q  ; *END*S68-JCH*
"RTN","HMPDJFSP",263,0)
 ;
"RTN","HMPDJFSP",264,0)
MOD4STRM(DOMAIN) ; modify extract to be ready for stream
"RTN","HMPDJFSP",265,0)
 ; expects: HMPBATCH, HMPFSYS, HMPFZTSK
"RTN","HMPDJFSP",266,0)
 ; results are in ^XTMP("HMPFX~hmpsrv~dfn",DFN,DOMAIN,...)
"RTN","HMPDJFSP",267,0)
 ; syncError: {uid,collection,error}  uid=urn:va:syncError:sysId:dfn:extract
"RTN","HMPDJFSP",268,0)
 N DFN,HMPSRV,COUNT,DOMONLY
"RTN","HMPDJFSP",269,0)
 S DOMONLY=$P(DOMAIN,"#")
"RTN","HMPDJFSP",270,0)
 S DFN=$P(HMPBATCH,"~",3),HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",271,0)
 S COUNT=+$G(^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"total"),0)
"RTN","HMPDJFSP",272,0)
 I COUNT=0 S ^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,1,1)="null"
"RTN","HMPDJFSP",273,0)
 ;
"RTN","HMPDJFSP",274,0)
 S ^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"total")=COUNT  ; include errors and/or empty
"RTN","HMPDJFSP",275,0)
 D SETDOM("count",DOMONLY,$G(^XTMP(HMPBATCH,0,"count",DOMONLY),0)+COUNT)
"RTN","HMPDJFSP",276,0)
 Q
"RTN","HMPDJFSP",277,0)
 ;
"RTN","HMPDJFSP",278,0)
POSTSEC(DOMAIN,ETOTAL,SECSIZE) ; post domain section to stream and set tidy nodes
"RTN","HMPDJFSP",279,0)
 N DFN,HMPSRV,COUNT,X,NODES
"RTN","HMPDJFSP",280,0)
 S COUNT=^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"total")
"RTN","HMPDJFSP",281,0)
 S ETOTAL=$G(ETOTAL,COUNT)
"RTN","HMPDJFSP",282,0)
 s SECSIZE=$G(SECSIZE,0)
"RTN","HMPDJFSP",283,0)
 S DFN=$P(HMPBATCH,"~",3)
"RTN","HMPDJFSP",284,0)
 S HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",285,0)
 D POST^HMPDJFS(DFN,"syncDomain",DOMAIN_":"_HMPFZTSK_":"_COUNT_":"_ETOTAL_":"_SECSIZE,"",HMPSRV,.NODES)
"RTN","HMPDJFSP",286,0)
 D SETTIDY(DOMAIN,.NODES)
"RTN","HMPDJFSP",287,0)
 Q
"RTN","HMPDJFSP",288,0)
 ;
"RTN","HMPDJFSP",289,0)
SETTIDY(DOMAIN,NODES) ; Set tidy nodes for clean-up of the extracts in ^XTMP
"RTN","HMPDJFSP",290,0)
 ; expects HMPBATCH,HMPFZTSK
"RTN","HMPDJFSP",291,0)
 N X,STREAM,SEQ
"RTN","HMPDJFSP",292,0)
 S X="" F  S X=$O(NODES(X)) Q:X=""  D      ; iterate hmp servers
"RTN","HMPDJFSP",293,0)
 . S STREAM="HMPFS~"_X_"~"_$P(NODES(X),U)  ; HMPFS~hmpSrv~fmDate
"RTN","HMPDJFSP",294,0)
 . S SEQ=$P(NODES(X),U,2)
"RTN","HMPDJFSP",295,0)
 . S ^XTMP(STREAM,"tidy",SEQ,"batch")=HMPBATCH
"RTN","HMPDJFSP",296,0)
 . S ^XTMP(STREAM,"tidy",SEQ,"domain")=DOMAIN
"RTN","HMPDJFSP",297,0)
 . S ^XTMP(STREAM,"tidy",SEQ,"task")=HMPFZTSK
"RTN","HMPDJFSP",298,0)
 Q
"RTN","HMPDJFSP",299,0)
 ;
"RTN","HMPDJFSP",300,0)
MVFRUPD(HMPBATCH,HMPFDFN) ; Move freshness updates over active stream
"RTN","HMPDJFSP",301,0)
 N I,X,FROM,HMPSRV,DFN,TYPE,ID,ACT
"RTN","HMPDJFSP",302,0)
 S HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",303,0)
 D UPDSTS(HMPFDFN,HMPSRV,2)              ; now initialized 
"RTN","HMPDJFSP",304,0)
 S FROM="HMPFH~"_HMPSRV_"~"_HMPFDFN
"RTN","HMPDJFSP",305,0)
 S I=0 F  S I=$O(^XTMP(FROM,I)) Q:'I  D  ; move over held updates
"RTN","HMPDJFSP",306,0)
 . S X=^XTMP(FROM,I)
"RTN","HMPDJFSP",307,0)
 . S DFN=$P(X,U),TYPE=$P(X,U,2),ID=$P(X,U,3),ACT=$P(X,U,4)
"RTN","HMPDJFSP",308,0)
 . D POST^HMPDJFS(DFN,TYPE,ID,ACT,HMPSRV)
"RTN","HMPDJFSP",309,0)
 K ^XTMP(FROM)
"RTN","HMPDJFSP",310,0)
 Q
"RTN","HMPDJFSP",311,0)
 ;
"RTN","HMPDJFSP",312,0)
BLDSERR(DFN,DOMAIN,ERRJSON) ; Create syncError object in ERRJSON
"RTN","HMPDJFSP",313,0)
 ; expects: HMPBATCH, HMPFSYS, HMPFZTSK
"RTN","HMPDJFSP",314,0)
 N COUNT,ERRVAL,ERROBJ,ERR,ERRMSG,SYNCERR
"RTN","HMPDJFSP",315,0)
 M ERRVAL=^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"error")
"RTN","HMPDJFSP",316,0)
 I $G(ERRVAL)="" Q
"RTN","HMPDJFSP",317,0)
 S ERRVAL="{"_ERRVAL_"}"
"RTN","HMPDJFSP",318,0)
 D DECODE^HMPJSON("ERRVAL","ERROBJ","ERR")
"RTN","HMPDJFSP",319,0)
 I $D(ERR) S $EC=",UJSON decode error,"
"RTN","HMPDJFSP",320,0)
 K ^XTMP(HMPBATCH,HMPFZTSK,DOMAIN,"error")
"RTN","HMPDJFSP",321,0)
 S ERRMSG=ERROBJ("error","message")
"RTN","HMPDJFSP",322,0)
 Q:'$L(ERRMSG)
"RTN","HMPDJFSP",323,0)
 S SYNCERR("uid")="urn:va:syncError:"_HMPFSYS_":"_DFN_":"_DOMAIN
"RTN","HMPDJFSP",324,0)
 S SYNCERR("collection")=DOMAIN
"RTN","HMPDJFSP",325,0)
 S SYNCERR("error")=ERRMSG
"RTN","HMPDJFSP",326,0)
 D ENCODE^HMPJSON("SYNCERR","ERRJSON","ERR") I $D(ERR) S $EC=",UJSON encode error," Q
"RTN","HMPDJFSP",327,0)
 S COUNT=$O(^TMP("HMPERR",$J,""),-1)+1
"RTN","HMPDJFSP",328,0)
 M ^TMP("HMPERR",$J,COUNT)=ERRJSON
"RTN","HMPDJFSP",329,0)
 Q
"RTN","HMPDJFSP",330,0)
 ;
"RTN","HMPDJFSP",331,0)
POSTERR(COUNT,DFN) ; put error into ^XTMP(batch)
"RTN","HMPDJFSP",332,0)
 N CNT,NODE,HMPSRV
"RTN","HMPDJFSP",333,0)
 S HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPDJFSP",334,0)
 S CNT=0 F  S CNT=$O(^TMP("HMPERR",$J,CNT)) Q:CNT'>0  D
"RTN","HMPDJFSP",335,0)
 .S NODE=$G(^TMP("HMPERR",$J,CNT,1))
"RTN","HMPDJFSP",336,0)
 .S ^XTMP(HMPBATCH,HMPFZTSK,"error",CNT,1)=NODE
"RTN","HMPDJFSP",337,0)
 .I CNT>1 S ^XTMP(HMPBATCH,HMPFZTSK,"error",CNT,.3)=","
"RTN","HMPDJFSP",338,0)
 D POST^HMPDJFS(DFN,"syncError","error:"_HMPFZTSK_":"_COUNT_":"_COUNT,"",HMPSRV)
"RTN","HMPDJFSP",339,0)
 Q
"RTN","HMPDJFSP",340,0)
 ;
"RTN","HMPDJFSP",341,0)
INITDONE(HMPBATCH) ; Return 1 if all domains are done
"RTN","HMPDJFSP",342,0)
 N X,DONE
"RTN","HMPDJFSP",343,0)
 S X="",DONE=1
"RTN","HMPDJFSP",344,0)
 F  S X=$O(^XTMP(HMPBATCH,0,"status",X)) Q:'$L(X)  I '^(X) S DONE=0
"RTN","HMPDJFSP",345,0)
 Q DONE
"RTN","HMPDJFSP",346,0)
 ;
"RTN","HMPDJFSP",347,0)
SETPAT(DFN,SRV,NEWSUB) ; Add patient to 800000 if not there
"RTN","HMPDJFSP",348,0)
 N ERR,FDA,IEN,IENROOT
"RTN","HMPDJFSP",349,0)
 S IEN=$O(^HMP(800000,"B",SRV,0))
"RTN","HMPDJFSP",350,0)
 I 'IEN D SETERR^HMPDJFS("Unable to find server: "_SRV) QUIT
"RTN","HMPDJFSP",351,0)
 ; for operational, only start sync if not yet subscribed
"RTN","HMPDJFSP",352,0)
 I DFN="OPD" D  QUIT
"RTN","HMPDJFSP",353,0)
 . L +^HMP(800000,IEN):5 E  D SETERR^HMPDJFS("Unable to lock server: "_SRV) Q
"RTN","HMPDJFSP",354,0)
 . ; status is empty string (not 0) when unsubscribed
"RTN","HMPDJFSP",355,0)
 . S NEWSUB='$L($P($G(^HMP(800000,IEN,0)),U,3))
"RTN","HMPDJFSP",356,0)
 . I NEWSUB D UPDOPD(IEN,1) ; set to subscribed
"RTN","HMPDJFSP",357,0)
 . L -^HMP(800000,IEN)
"RTN","HMPDJFSP",358,0)
 ;
"RTN","HMPDJFSP",359,0)
 ; for patient, check subscribed and get the PID
"RTN","HMPDJFSP",360,0)
 L +^HMP(800000,IEN,1,DFN):5 E  D SETERR^HMPDJFS("Unable to lock patient: "_DFN) Q
"RTN","HMPDJFSP",361,0)
 S NEWSUB='$D(^HMP(800000,IEN,1,DFN))
"RTN","HMPDJFSP",362,0)
 I NEWSUB D ADDPAT(DFN,IEN)
"RTN","HMPDJFSP",363,0)
 L -^HMP(800000,IEN,1,DFN)
"RTN","HMPDJFSP",364,0)
 Q
"RTN","HMPDJFSP",365,0)
 ;
"RTN","HMPDJFSP",366,0)
UPDOPD(SRV,STS) ; Update status of operational synch
"RTN","HMPDJFSP",367,0)
 N FDA,ERR,DIERR
"RTN","HMPDJFSP",368,0)
 S FDA(800000,SRV_",",.03)=STS
"RTN","HMPDJFSP",369,0)
 D FILE^DIE("","FDA","ERR")
"RTN","HMPDJFSP",370,0)
 I $D(ERR) D SETERR^HMPDJFS("Error changing operational status")
"RTN","HMPDJFSP",371,0)
 D CLEAN^DILF
"RTN","HMPDJFSP",372,0)
 Q
"RTN","HMPDJFSP",373,0)
ADDPAT(DFN,SRV) ; Add a patient as subscribed for server
"RTN","HMPDJFSP",374,0)
 N FDA,FDAIEN,DIERR,ERR,IENS
"RTN","HMPDJFSP",375,0)
 S IENS="?+"_DFN_","_SRV_","
"RTN","HMPDJFSP",376,0)
 S FDAIEN(DFN)=DFN  ; help DINUM to work
"RTN","HMPDJFSP",377,0)
 S FDA(800000.01,IENS,.01)=DFN
"RTN","HMPDJFSP",378,0)
 S FDA(800000.01,IENS,2)=0
"RTN","HMPDJFSP",379,0)
 S FDA(800000.01,IENS,3)=$$NOW^XLFDT
"RTN","HMPDJFSP",380,0)
 D UPDATE^DIE("","FDA","FDAIEN","ERR")
"RTN","HMPDJFSP",381,0)
 I $D(ERR) D SETERR^HMPDJFS("Error adding patient subscription")
"RTN","HMPDJFSP",382,0)
 D CLEAN^DILF
"RTN","HMPDJFSP",383,0)
 Q
"RTN","HMPDJFSP",384,0)
 ;
"RTN","HMPDJFSP",385,0)
UPDSTS(DFN,SRVNM,STS) ; Update the sync status
"RTN","HMPDJFSP",386,0)
 N SRV,ERR ;US11019
"RTN","HMPDJFSP",387,0)
 S SRV=$O(^HMP(800000,"B",SRVNM,0)) I 'SRV D SETERR^HMPDJFS("Missing Server") Q
"RTN","HMPDJFSP",388,0)
 I DFN="OPD" D UPDOPD(SRV,STS) QUIT
"RTN","HMPDJFSP",389,0)
 ;
"RTN","HMPDJFSP",390,0)
 S FDA(800000.01,DFN_","_SRV_",",2)=STS
"RTN","HMPDJFSP",391,0)
 S FDA(800000.01,DFN_","_SRV_",",3)=$$NOW^XLFDT
"RTN","HMPDJFSP",392,0)
 D FILE^DIE("","FDA","ERR")
"RTN","HMPDJFSP",393,0)
 I $D(ERR) D SETERR^HMPDJFS("Error updating patient sync status")
"RTN","HMPDJFSP",394,0)
 D CLEAN^DILF
"RTN","HMPDJFSP",395,0)
 Q
"RTN","HMPDJFSP",396,0)
 ;
"RTN","HMPDJFSP",397,0)
UPDPAT(DFN,SRV,STS) ; DEPRECATED?
"RTN","HMPDJFSP",398,0)
 N ERR,FDA,IEN
"RTN","HMPDJFSP",399,0)
 S IEN=$O(^HMP(800000,"B",SRV,"")) I +IEN'>0 Q
"RTN","HMPDJFSP",400,0)
 I DFN="OPD" D
"RTN","HMPDJFSP",401,0)
 . S FDA(800000,"?"_IEN_",",.01)=SRV
"RTN","HMPDJFSP",402,0)
 . S FDA(800000,"?"_IEN_",",.03)=STS
"RTN","HMPDJFSP",403,0)
 I +DFN>0 D
"RTN","HMPDJFSP",404,0)
 .S FDA(800000.01,"?"_DFN_","_IEN_",",.01)=DFN
"RTN","HMPDJFSP",405,0)
 .S FDA(800000.01,"?"_DFN_","_IEN_",",2)=STS
"RTN","HMPDJFSP",406,0)
 D UPDATE^DIE("","FDA","","ERR")
"RTN","HMPDJFSP",407,0)
 Q
"RTN","HMPDJFSP",408,0)
 ;
"RTN","HMPDJFSP",409,0)
TOTAL(DOMAIN) ; return size total
"RTN","HMPDJFSP",410,0)
 N I,X,SIZE,ROOT
"RTN","HMPDJFSP",411,0)
 S SIZE=0
"RTN","HMPDJFSP",412,0)
 F I=1:1 S X=$T(OPDOMS+I^HMPDJFSD) Q:$P(X,";",3)="zzzzz"  D  Q:SIZE
"RTN","HMPDJFSP",413,0)
 . I $P(X,";",3)'=DOMAIN Q
"RTN","HMPDJFSP",414,0)
 . S ROOT=$P(X,";",4)
"RTN","HMPDJFSP",415,0)
 . I ROOT="^HMP(800000.11)" S SIZE=$G(^HMP(800000.11,"ACNT",DOMAIN)) Q
"RTN","HMPDJFSP",416,0)
 . I $L(ROOT) S SIZE=$P($G(@ROOT@(0)),U,4)
"RTN","HMPDJFSP",417,0)
 Q $S(SIZE:SIZE,1:9999)
"RTN","HMPDJFSP",418,0)
 ;
"RTN","HMPDJFSP",419,0)
 ;
"RTN","HMPDJFSP",420,0)
OKTORUN(HMPTTYPE) ;execute 'ok to run' strategy
"RTN","HMPDJFSP",421,0)
 ; input: HMPTTYPE := type of task [ 'redoer' | 'extractor' | 'hangLoop']
"RTN","HMPDJFSP",422,0)
 ;          - currently not used but may become useful for strategy algorithms
"RTN","HMPDJFSP",423,0)
 ; returns: 1 - ok to run task | 0 - do not run task
"RTN","HMPDJFSP",424,0)
 Q $$CHKSIZE
"RTN","HMPDJFSP",425,0)
 ;
"RTN","HMPDJFSP",426,0)
CHKSIZE() ; aggregate extract ^XTMP size strategy
"RTN","HMPDJFSP",427,0)
 ; returns: 1 - ^XTMP extract size within limit  | 0 - ^XTMP size over limit
"RTN","HMPDJFSP",428,0)
 ; Note: logic used regardless of HMP server
"RTN","HMPDJFSP",429,0)
 Q $$GETMAX>+$$GETSIZE^HMPUTILS()
"RTN","HMPDJFSP",430,0)
 ;
"RTN","HMPDJFSP",431,0)
CHKXTMP(HMPBATCH,HMPFZTSK) ; -- ^XTMP check at end each domain loop iteration ; if too big HANG
"RTN","HMPDJFSP",432,0)
 N HMPOK
"RTN","HMPDJFSP",433,0)
 S HMPOK=0
"RTN","HMPDJFSP",434,0)
 F  D  Q:HMPOK
"RTN","HMPDJFSP",435,0)
 . ; -- if ok to run, continue
"RTN","HMPDJFSP",436,0)
 . I $$OKTORUN("hangLoop") K ^XTMP(HMPBATCH,0,"task",HMPFZTSK,"hanging") S HMPOK=1 Q
"RTN","HMPDJFSP",437,0)
 . S ^("hanging")=$G(^XTMP(HMPBATCH,0,"task",HMPFZTSK,"hanging"))+1
"RTN","HMPDJFSP",438,0)
 . H $$GETSECS
"RTN","HMPDJFSP",439,0)
 Q
"RTN","HMPDJFSP",440,0)
 ;
"RTN","HMPDJFSP",441,0)
GETMAX() ; return the max allowable aggregate extract size
"RTN","HMPDJFSP",442,0)
 N HMPLIM
"RTN","HMPDJFSP",443,0)
 S HMPLIM=$$GET^XPAR("SYS","HMP EXTRACT DISK SIZE LIMIT")*1000000
"RTN","HMPDJFSP",444,0)
 Q $S(HMPLIM:HMPLIM,1:20000000)  ; if not set, 20mb characters
"RTN","HMPDJFSP",445,0)
 ;
"RTN","HMPDJFSP",446,0)
GETSECS() ; return default # of seconds to requeue in future or hang when processing domains
"RTN","HMPDJFSP",447,0)
 N SECS
"RTN","HMPDJFSP",448,0)
 S SECS=+$$GET^XPAR("SYS","HMP EXTRACT TASK REQUEUE SECS")
"RTN","HMPDJFSP",449,0)
 Q $S(SECS:SECS,1:10)   ; not set, wait 10 seconds
"RTN","HMPDJFSP",450,0)
 ;
"RTN","HMPEF")
0^55^B86180151^B86254671
"RTN","HMPEF",1,0)
HMPEF ;SLC/MKB,ASMR/RRB,JD,SRG - Serve VistA operational data as JSON via RPC;May 15, 2016 14:15
"RTN","HMPEF",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPEF",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPEF",4,0)
 ;
"RTN","HMPEF",5,0)
 ; DE2818 - SQA findings. Newed L42 and L44 in LOC+1.  RRB - 10/30/2015
"RTN","HMPEF",6,0)
 ;
"RTN","HMPEF",7,0)
 ; ^SC references - IA 10040, HOSPITAL LOCATION file (#44)
"RTN","HMPEF",8,0)
 ; ^DIC(42) references - IA #10039, WARD LOCATION file
"RTN","HMPEF",9,0)
 Q
"RTN","HMPEF",10,0)
 ;
"RTN","HMPEF",11,0)
 ; The following variables can not be newed or killed because they are used
"RTN","HMPEF",12,0)
 ; from upstream by scope (NOT as input parameters):
"RTN","HMPEF",13,0)
 ;      HMPBATCH, HMPFADOM, HMPFLDON, HMPFZTSK, HMPMETA, HMPSTMP, LEX("LIST", and ZTQUEUED.
"RTN","HMPEF",14,0)
GET(HMP,FILTER) ; -- Return search results as JSON in @HMP@(n)
"RTN","HMPEF",15,0)
 ; RPC = HMP GET OPERATIONAL DATA
"RTN","HMPEF",16,0)
 ; where FILTER("domain")  = name of desired data type (see $$TAG)
"RTN","HMPEF",17,0)
 ;       FILTER("limit")   = maximum number of items to return [opt]
"RTN","HMPEF",18,0)
 ;       FILTER("start")   = ien to start search from          [opt]
"RTN","HMPEF",19,0)
 ;       FILTER("id")      = single item id to return          [opt]
"RTN","HMPEF",20,0)
 ;
"RTN","HMPEF",21,0)
 ; HMPLAST - last record processed
"RTN","HMPEF",22,0)
 N HMPSYS,TYPE,HMPMAX,HMPI,HMPID,HMPERR,HMPTN,HMPLAST,HMPCNT,HMPFINI
"RTN","HMPEF",23,0)
 S HMP=$NA(^TMP("HMP",$J)),HMPI=0 K @HMP
"RTN","HMPEF",24,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPEF",25,0)
 ;
"RTN","HMPEF",26,0)
 ; parse & validate input parameters
"RTN","HMPEF",27,0)
 S TYPE=$P($G(FILTER("domain")),"#") ;,TYPE=$$LOW^XLFSTR(TYPE)
"RTN","HMPEF",28,0)
 S HMPMAX=+$G(FILTER("limit")),HMPCNT=0
"RTN","HMPEF",29,0)
 S HMPLAST=+$G(FILTER("start"))
"RTN","HMPEF",30,0)
 S HMPID=$G(FILTER("id"))
"RTN","HMPEF",31,0)
 ;
"RTN","HMPEF",32,0)
 K ^TMP($J,"HMP ERROR")
"RTN","HMPEF",33,0)
 ;
"RTN","HMPEF",34,0)
 ; extract data
"RTN","HMPEF",35,0)
 I TYPE="" S HMPERR="Missing or invalid reference type" G GTQ
"RTN","HMPEF",36,0)
 ; *** convert code below to use $$HANDLE^XUSRB4 for zero node in ^XTMP, IA 4770***
"RTN","HMPEF",37,0)
 I $D(ZTQUEUED) S HMP=$NA(^XTMP(HMPBATCH,HMPFZTSK,FILTER("domain"))) K @HMP
"RTN","HMPEF",38,0)
 I TYPE="new",$L($T(EN^HMPEFX)) D EN^HMPEFX(HMPID,HMPMAX) Q
"RTN","HMPEF",39,0)
 S HMPTN=$$TAG(TYPE) Q:'$L(HMPTN)  ;D ERR(2) Q
"RTN","HMPEF",40,0)
 D @HMPTN
"RTN","HMPEF",41,0)
 ;
"RTN","HMPEF",42,0)
GTQ ; add item count and terminating characters
"RTN","HMPEF",43,0)
 N ERROR I $D(^TMP($J,"HMP ERROR"))>0 D BUILDERR(.ERROR) S ERROR(1)=ERROR(1)_"}"
"RTN","HMPEF",44,0)
 I +$G(FILTER("noHead"))=1 D  Q
"RTN","HMPEF",45,0)
 .S @HMP@("total")=+$G(HMPI)
"RTN","HMPEF",46,0)
 .S @HMP@("last")=HMPLAST
"RTN","HMPEF",47,0)
 .S @HMP@("finished")=+$G(HMPFINI)
"RTN","HMPEF",48,0)
 .I $L($G(ERROR(1)))>1 S @HMP@("error")=ERROR(1)
"RTN","HMPEF",49,0)
 I '$D(@HMP)!'$G(HMPI) D  Q
"RTN","HMPEF",50,0)
 .I '$D(^TMP($J,"HMP ERROR")) S @HMP@(1)="""data"":{""totalItems"":0,""items"":[]}}" Q
"RTN","HMPEF",51,0)
 .S @HMP@(1)="""data"":{""totalItems"":0,""items"":[]},"
"RTN","HMPEF",52,0)
 .M @HMP@(2)=ERROR
"RTN","HMPEF",53,0)
 ;
"RTN","HMPEF",54,0)
 I $D(@HMP),$G(HMPI) D
"RTN","HMPEF",55,0)
 . S @HMP@(.5)="{""apiVersion"":""1.01"",""data"":{""updated"":"""_$$HL7NOW_""",""currentItemCount"":"_HMPI
"RTN","HMPEF",56,0)
 . S:$G(HMPCNT) @HMP@(.5)=@HMP@(.5)_",""totalItems"":"_HMPCNT
"RTN","HMPEF",57,0)
 . S:$G(HMPLAST) @HMP@(.5)=@HMP@(.5)_",""last"":"_HMPLAST
"RTN","HMPEF",58,0)
 . S @HMP@(.5)=@HMP@(.5)_",""items"":["
"RTN","HMPEF",59,0)
 . S HMPI=HMPI+1,@HMP@(HMPI)=$S($D(^TMP($J,"HMP ERROR"))>0:"]}",1:"]}}")
"RTN","HMPEF",60,0)
 I $D(^TMP($J,"HMP ERROR"))>0 S HMPI=HMPI+1,@HMP@(HMPI,.3)="," M @HMP@(HMPI)=ERROR ;S HMPI=HMPI+1,@HMP@(HMPI)="}"
"RTN","HMPEF",61,0)
 K ^TMP($J,"HMP ERROR")
"RTN","HMPEF",62,0)
 Q
"RTN","HMPEF",63,0)
 ;
"RTN","HMPEF",64,0)
BUILDERR(RESULT) ;  error array
"RTN","HMPEF",65,0)
 N CNT,COUNT,DOM,DOMCNT,ERRMSG,ERROR,FIELD,MESSAGE,MSG,MSGCNT,T,TEMP
"RTN","HMPEF",66,0)
 S COUNT=$G(^TMP($J,"HMP ERROR","# of Errors"))
"RTN","HMPEF",67,0)
 S MESSAGE="A mumps error occurred when extracting data. A total of "_COUNT_" occurred.\n\r"
"RTN","HMPEF",68,0)
 S CNT=1,ERROR("error","message","\",CNT)="A mumps error occurred when extracting patient data. A total of "_COUNT_" occurred.\n\r"
"RTN","HMPEF",69,0)
 S MSGCNT=0 F  S MSGCNT=$O(^TMP($J,"HMP ERROR","ERROR MESSAGE",MSGCNT)) Q:MSGCNT'>0  D
"RTN","HMPEF",70,0)
 . S CNT=CNT+1,MESSAGE=MESSAGE_$G(^TMP($J,"HMP ERROR","ERROR MESSAGE",MSGCNT))_"\n\r"
"RTN","HMPEF",71,0)
 S RESULT(1)="""error"":{""message"":"_""""_MESSAGE_""""_"}"
"RTN","HMPEF",72,0)
 Q
"RTN","HMPEF",73,0)
 ;
"RTN","HMPEF",74,0)
TAG(X) ; -- linetag for reference domain X
"RTN","HMPEF",75,0)
 N Y S Y="HMP",X=$G(X)
"RTN","HMPEF",76,0)
 ; default = HMP Object (various types)
"RTN","HMPEF",77,0)
 I X="location"      S Y="LOC"
"RTN","HMPEF",78,0)
 I X="pt-select"     S Y="PAT"
"RTN","HMPEF",79,0)
 I X="person"        S Y="NP"
"RTN","HMPEF",80,0)
 I X="user"          S Y="NP"
"RTN","HMPEF",81,0)
 I X="labgroup"      S Y="LABGRP"
"RTN","HMPEF",82,0)
 I X="labpanel"      S Y="LABPNL"
"RTN","HMPEF",83,0)
 I X["orderable"     S Y="OI"
"RTN","HMPEF",84,0)
 I X["schedule"      S Y="SCHEDULE"
"RTN","HMPEF",85,0)
 I X["route"         S Y="ROUTE"
"RTN","HMPEF",86,0)
 I X["quick"         S Y="QO"
"RTN","HMPEF",87,0)
 I X="displayGroup"  S Y="ODG"
"RTN","HMPEF",88,0)
 I X["asu-"          S Y="ASU"
"RTN","HMPEF",89,0)
 I X["doc-"          S Y="ASU"
"RTN","HMPEF",90,0)
 I X="immunization"    S Y="IMMTYPE"
"RTN","HMPEF",91,0)
 I X="allergy-list"         S Y="ALLTYPE"
"RTN","HMPEF",92,0)
 ;I X="problem-list"        S Y="PROB"
"RTN","HMPEF",93,0)
 I X="sign-symptom"   S Y="SIGNS"
"RTN","HMPEF",94,0)
 I X="vital-type"      S Y="VTYPE"
"RTN","HMPEF",95,0)
 I X="vital-qualifier"  S Y="VQUAL"
"RTN","HMPEF",96,0)
 I X="vital-category"   S Y="VCAT"
"RTN","HMPEF",97,0)
 I X["clioterm"      S Y="MDTERMS"
"RTN","HMPEF",98,0)
 Q Y
"RTN","HMPEF",99,0)
 ;
"RTN","HMPEF",100,0)
ERR(X,VAL) ;  return error message
"RTN","HMPEF",101,0)
 N MSG  S MSG="Error"
"RTN","HMPEF",102,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPEF",103,0)
 I X=3  S MSG="UID '"_$G(VAL)_"' not found"
"RTN","HMPEF",104,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPEF",105,0)
 Q MSG
"RTN","HMPEF",106,0)
 ;
"RTN","HMPEF",107,0)
ERRMSG(X,VAL) ; -- return error message
"RTN","HMPEF",108,0)
 N Y S Y="A MUMPS error occurred while extracting "_X_" data"
"RTN","HMPEF",109,0)
 S:$G(VAL) Y=Y_", ien "_VAL
"RTN","HMPEF",110,0)
 Q Y
"RTN","HMPEF",111,0)
 ;
"RTN","HMPEF",112,0)
ERRQ ; -- Quit on error
"RTN","HMPEF",113,0)
 Q
"RTN","HMPEF",114,0)
 ;
"RTN","HMPEF",115,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPEF",116,0)
 Q $P($$FMTHL7^XLFDT($$NOW^XLFDT),"-")
"RTN","HMPEF",117,0)
 ;
"RTN","HMPEF",118,0)
ALL() ;
"RTN","HMPEF",119,0)
 Q "location;patient;person;orderable;schedule;route;quick;displayGroup;asu-class;asu-rule;asu-role;doc-action;doc-status;clioterm;immunization;allergy-list;sign-symptom;vital-type;vital-qualifier;vital-category"
"RTN","HMPEF",120,0)
 ;
"RTN","HMPEF",121,0)
ADD(ITEM) ; -- add ITEM to @HMP@(HMPI)
"RTN","HMPEF",122,0)
 N HMPY,HMPERR
"RTN","HMPEF",123,0)
 I $G(HMPSTMP)]"" S @ITEM@("stampTime")=HMPSTMP ; US6734
"RTN","HMPEF",124,0)
 E  S @ITEM@("stampTime")=$$EN^HMPSTMP("NOW") ; DE2616 - must add stampTime to receive OPD freshness update from ADHOC^HMPUTIL1
"RTN","HMPEF",125,0)
 D ENCODE^HMPJSON(ITEM,"HMPY","HMPERR")
"RTN","HMPEF",126,0)
 I $D(HMPERR) D  ;return ERRor instead of ITEM
"RTN","HMPEF",127,0)
 . N HMPTMP,HMPTXT,HMPITM
"RTN","HMPEF",128,0)
 . M HMPITM=@ITEM K HMPY
"RTN","HMPEF",129,0)
 . S HMPTXT(1)="Problem encoding json output."
"RTN","HMPEF",130,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.HMPITM)
"RTN","HMPEF",131,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","HMPY","HMPERR")
"RTN","HMPEF",132,0)
 I $D(HMPY) D
"RTN","HMPEF",133,0)
 . Q:'$D(@ITEM@("uid"))
"RTN","HMPEF",134,0)
 . I $G(HMPMETA) D ADD^HMPMETA($P(HMPFADOM,"#"),@ITEM@("uid"),HMPSTMP) Q:HMPMETA=1  ;US6734,US11019
"RTN","HMPEF",135,0)
 . I HMPI D COMMA(HMPI)
"RTN","HMPEF",136,0)
 . ;I HMPI,'$G(FILTER("noHead")) D COMMA(HMPI)
"RTN","HMPEF",137,0)
 . S HMPI=HMPI+1 M @HMP@(HMPI)=HMPY
"RTN","HMPEF",138,0)
 Q
"RTN","HMPEF",139,0)
 ;
"RTN","HMPEF",140,0)
COMMA(I) ; -- add comma between items
"RTN","HMPEF",141,0)
 I $D(ZTQUEUED) Q
"RTN","HMPEF",142,0)
 N J S J=+$O(@HMP@(I,"A"),-1) ;last sub-node for item I
"RTN","HMPEF",143,0)
 S J=J+1,@HMP@(I,J)=","
"RTN","HMPEF",144,0)
 Q
"RTN","HMPEF",145,0)
 ;
"RTN","HMPEF",146,0)
TOTAL(ROOT) ; -- Return total #items in @ROOT@(n)
"RTN","HMPEF",147,0)
 Q $P($G(@ROOT@(0)),U,4)
"RTN","HMPEF",148,0)
 ;
"RTN","HMPEF",149,0)
TEST(TYPE,ID,IN) ; -- test GET, write results to screen
"RTN","HMPEF",150,0)
 N OUT,IDX
"RTN","HMPEF",151,0)
 S U="^"
"RTN","HMPEF",152,0)
 S IN("domain")=$G(TYPE)
"RTN","HMPEF",153,0)
 S:$D(ID) IN("id")=ID
"RTN","HMPEF",154,0)
 D GET(.OUT,.IN)
"RTN","HMPEF",155,0)
 ;
"RTN","HMPEF",156,0)
 S IDX=OUT
"RTN","HMPEF",157,0)
 F  S IDX=$Q(@IDX) Q:IDX'?1"^TMP(""HMP"","1.N.E  Q:+$P(IDX,",",2)'=$J  W !,@IDX
"RTN","HMPEF",158,0)
 Q
"RTN","HMPEF",159,0)
 ;
"RTN","HMPEF",160,0)
 ; ** Reference file searches, using FILTER("parameter")
"RTN","HMPEF",161,0)
 ;
"RTN","HMPEF",162,0)
PAT ;Patients
"RTN","HMPEF",163,0)
 N DFN,PAT,HMPPOPD
"RTN","HMPEF",164,0)
 S HMPPOPD=1
"RTN","HMPEF",165,0)
 S HMPCNT=$$TOTAL("^DPT")
"RTN","HMPEF",166,0)
 I $G(HMPID) S DFN=+HMPID D LKUP^HMPDJ00 Q
"RTN","HMPEF",167,0)
 N ERRMSG S ERRMSG="A mumps error occurred while extracting patients."
"RTN","HMPEF",168,0)
 S DFN=+$G(HMPLAST) F  S DFN=$O(^DPT(DFN)) Q:DFN<1  D  I HMPMAX>0,HMPI'<HMPMAX Q
"RTN","HMPEF",169,0)
 . N $ES,$ET
"RTN","HMPEF",170,0)
 . S $ET="D ERRHDLR^HMPDERRH"
"RTN","HMPEF",171,0)
 . I $P($G(^DPT(DFN,0)),U)="" Q
"RTN","HMPEF",172,0)
 . S ERRMSG=$$ERRMSG("Patient",DFN)
"RTN","HMPEF",173,0)
 . K PAT D LKUP^HMPDJ00
"RTN","HMPEF",174,0)
 . S HMPLAST=DFN
"RTN","HMPEF",175,0)
 I DFN<1 S HMPFINI=1
"RTN","HMPEF",176,0)
 Q
"RTN","HMPEF",177,0)
LOC ; Hospital Location (#44) and Ward Location (#42)  /DE2818
"RTN","HMPEF",178,0)
 D LOC^HMPEF1(.HMPFINI,.HMPFLDON,$G(HMPMETA))
"RTN","HMPEF",179,0)
 Q
"RTN","HMPEF",180,0)
 ;
"RTN","HMPEF",181,0)
ACTWRD(IEN) ;Boolean TRUE if active WARD LOCATION
"RTN","HMPEF",182,0)
 ; IEN - IEN in file 42
"RTN","HMPEF",183,0)
 S D0=IEN D WIN^DGPMDDCF Q 'X  ; SRG: need DBIA
"RTN","HMPEF",184,0)
 ;
"RTN","HMPEF",185,0)
ACTLOC(LOC) ;Boolean TRUE if active hospital location
"RTN","HMPEF",186,0)
 ; ^SC - IA 10040
"RTN","HMPEF",187,0)
 N D0,X I +$G(^SC(LOC,"OOS")) Q 0                ; screen out OOS entry
"RTN","HMPEF",188,0)
 S D0=+$G(^SC(LOC,42)) I D0 D WIN^DGPMDDCF Q 'X  ; chk out of svc wards
"RTN","HMPEF",189,0)
 S X=$G(^SC(LOC,"I")) I +X=0 Q 1                 ; no inactivate date
"RTN","HMPEF",190,0)
 I DT>$P(X,U)&($P(X,U,2)=""!(DT<$P(X,U,2))) Q 0  ; chk reactivate date
"RTN","HMPEF",191,0)
 Q 1                                             ; must still be active
"RTN","HMPEF",192,0)
 ;
"RTN","HMPEF",193,0)
NP ;New Persons
"RTN","HMPEF",194,0)
 D NP^HMPEF1
"RTN","HMPEF",195,0)
 Q
"RTN","HMPEF",196,0)
 ;
"RTN","HMPEF",197,0)
KEYS(IEN) ;user's keys
"RTN","HMPEF",198,0)
 N HMPKEY,IENS,X,CNT
"RTN","HMPEF",199,0)
 D GETS^DIQ(200,IEN_",","51*","IE","HMPKEY") S CNT=0
"RTN","HMPEF",200,0)
 S IENS="" F  S IENS=$O(HMPKEY(200.051,IENS)) Q:IENS=""  D
"RTN","HMPEF",201,0)
 . S X=$G(HMPKEY(200.051,IENS,.01,"E")),CNT=CNT+1
"RTN","HMPEF",202,0)
 . S USER("vistaKeys",CNT,"name")=X
"RTN","HMPEF",203,0)
 . S X=$G(HMPKEY(200.051,IENS,3,"I"))
"RTN","HMPEF",204,0)
 . S:X USER("vistaKeys",CNT,"reviewDate")=$$JSONDT^HMPUTILS(X)
"RTN","HMPEF",205,0)
 Q
"RTN","HMPEF",206,0)
 ;
"RTN","HMPEF",207,0)
ODG ;
"RTN","HMPEF",208,0)
 D ADDODG^HMPCORD4
"RTN","HMPEF",209,0)
 Q
"RTN","HMPEF",210,0)
 ;
"RTN","HMPEF",211,0)
OI ;
"RTN","HMPEF",212,0)
 D OI^HMPCORD4("PS^RAP^LRT")
"RTN","HMPEF",213,0)
 Q
"RTN","HMPEF",214,0)
 ;
"RTN","HMPEF",215,0)
PROB ;get problem list OPD store
"RTN","HMPEF",216,0)
 D PROB^HMPEF1(.HMPFINI,LEX)
"RTN","HMPEF",217,0)
 Q
"RTN","HMPEF",218,0)
 ;
"RTN","HMPEF",219,0)
QO ;
"RTN","HMPEF",220,0)
 D QO^HMPCORD4
"RTN","HMPEF",221,0)
 Q
"RTN","HMPEF",222,0)
 ;
"RTN","HMPEF",223,0)
SCHEDULE ;
"RTN","HMPEF",224,0)
 N RESULT
"RTN","HMPEF",225,0)
 D ADDSCH^HMPCORD4
"RTN","HMPEF",226,0)
 Q
"RTN","HMPEF",227,0)
 ;
"RTN","HMPEF",228,0)
ROUTE ;
"RTN","HMPEF",229,0)
 N RESULT
"RTN","HMPEF",230,0)
 D ADDROUTE^HMPCORD4
"RTN","HMPEF",231,0)
 Q
"RTN","HMPEF",232,0)
 ;
"RTN","HMPEF",233,0)
HMP ; HMP Objects
"RTN","HMPEF",234,0)
 N IEN
"RTN","HMPEF",235,0)
 S HMPCNT=$$TOTAL("^HMP(800000.11)")
"RTN","HMPEF",236,0)
 I $L(HMPID) D  Q
"RTN","HMPEF",237,0)
 . I HMPID=+HMPID S IEN=HMPID
"RTN","HMPEF",238,0)
 . E  S IEN=+$O(^HMP(800000.11,"B",HMPID,0))
"RTN","HMPEF",239,0)
 . S ERRMSG=$$ERRMSG("HMP Object",IEN)
"RTN","HMPEF",240,0)
 . D:IEN HMP1^HMPDJ02(800000.11,IEN)
"RTN","HMPEF",241,0)
 S IEN=+$G(HMPLAST) F  S IEN=$O(^HMP(800000.11,"C",TYPE,IEN)) Q:IEN<1  D  I HMPMAX>0,HMPI'<HMPMAX Q
"RTN","HMPEF",242,0)
 . S ERRMSG=$$ERRMSG("HMP Object",IEN)
"RTN","HMPEF",243,0)
 . D HMP1^HMPDJ02(800000.11,IEN) S HMPLAST=IEN
"RTN","HMPEF",244,0)
 I IEN<1 S HMPFINI=1
"RTN","HMPEF",245,0)
 Q
"RTN","HMPEF",246,0)
 ;
"RTN","HMPEF",247,0)
SOURCE(SRC) ;
"RTN","HMPEF",248,0)
 N X S X=""
"RTN","HMPEF",249,0)
 I SRC["SC("        S X="clinic"
"RTN","HMPEF",250,0)
 I SRC["DPT("       S X="patient"
"RTN","HMPEF",251,0)
 I SRC["DIC(42"     S X="ward"
"RTN","HMPEF",252,0)
 I SRC["SCTM"       S X="pcmm"
"RTN","HMPEF",253,0)
 I SRC["OR(100.21"  S X="cprs"
"RTN","HMPEF",254,0)
 I SRC["DIC(45.7"   S X="specialty"
"RTN","HMPEF",255,0)
 I SRC["VA(200"     S X="provider"
"RTN","HMPEF",256,0)
 I SRC["PXRM(810.4" S X="pxrm"
"RTN","HMPEF",257,0)
 Q X
"RTN","HMPEF",258,0)
 ;
"RTN","HMPEF",259,0)
ASU ; ASU files
"RTN","HMPEF",260,0)
 N X,RTN S X=$P($G(TYPE),"-",2)
"RTN","HMPEF",261,0)
 S RTN=$$UP^XLFSTR(X)_"^HMPEASU"
"RTN","HMPEF",262,0)
 I X'="",$L($T(@RTN)) D @RTN
"RTN","HMPEF",263,0)
 Q
"RTN","HMPEF",264,0)
 ;
"RTN","HMPEF",265,0)
MDTERMS ; CP Terminology
"RTN","HMPEF",266,0)
 D:$L($T(TERM^HMPMDUTL)) TERM^HMPMDUTL
"RTN","HMPEF",267,0)
 Q
"RTN","HMPEF",268,0)
LABGRP ;
"RTN","HMPEF",269,0)
 D SHWCUMR2^HMPELAB
"RTN","HMPEF",270,0)
 Q
"RTN","HMPEF",271,0)
LABPNL ;
"RTN","HMPEF",272,0)
 D SHWORPNL^HMPELAB
"RTN","HMPEF",273,0)
 Q
"RTN","HMPEF",274,0)
 ;
"RTN","HMPEF",275,0)
 ;DE2818, changed reference to ^VA(201) to a FileMan call
"RTN","HMPEF",276,0)
ISPROXY(IEN) ; Boolean function, is NEW PERSON entry an APPLICATION PROXY?
"RTN","HMPEF",277,0)
 N APP,HMPMSG,HMPUCLS,T,V
"RTN","HMPEF",278,0)
 ; APP - returned value
"RTN","HMPEF",279,0)
 ; HMPUCLS - user class array
"RTN","HMPEF",280,0)
 ; HMPMSG - FileMan message array
"RTN","HMPEF",281,0)
 ;
"RTN","HMPEF",282,0)
 D GETS^DIQ(200,IEN_",","9.5*","E","HMPUCLS","HMPMSG")  ; get external format
"RTN","HMPEF",283,0)
 S APP=0,T="APPLICATION PROXY",V="HMPUCLS"
"RTN","HMPEF",284,0)
 ; search returned array for value equal to T
"RTN","HMPEF",285,0)
 F  S V=$Q(@V) Q:V=""!APP  S:@V=T APP=1
"RTN","HMPEF",286,0)
 Q APP
"RTN","HMPEF",287,0)
 ;
"RTN","HMPEF",288,0)
IMMTYPE ;immunization types
"RTN","HMPEF",289,0)
 D IMMTYPE^HMPCORD5
"RTN","HMPEF",290,0)
 Q
"RTN","HMPEF",291,0)
 ;
"RTN","HMPEF",292,0)
SIGNS ;SIGNS/SYMPTONS file
"RTN","HMPEF",293,0)
 D SIGNS^HMPCORD5
"RTN","HMPEF",294,0)
 Q
"RTN","HMPEF",295,0)
 ;
"RTN","HMPEF",296,0)
ALLTYPE ;allergy-list types
"RTN","HMPEF",297,0)
 ;BL;REMOVE FROM ODS
"RTN","HMPEF",298,0)
 ;D ALLTYPE^HMPCORD5
"RTN","HMPEF",299,0)
 Q
"RTN","HMPEF",300,0)
 ;
"RTN","HMPEF",301,0)
VTYPE ;vital types
"RTN","HMPEF",302,0)
 D VTYPE^HMPCORD5
"RTN","HMPEF",303,0)
 Q
"RTN","HMPEF",304,0)
 ;
"RTN","HMPEF",305,0)
VQUAL ;vital qualifiers
"RTN","HMPEF",306,0)
 D VQUAL^HMPCORD5
"RTN","HMPEF",307,0)
 Q
"RTN","HMPEF",308,0)
 ;
"RTN","HMPEF",309,0)
VCAT ;vital categories
"RTN","HMPEF",310,0)
 D VCAT^HMPCORD5
"RTN","HMPEF",311,0)
 Q
"RTN","HMPEF",312,0)
 ;
"RTN","HMPEF",313,0)
FILENAME ; text of filenames for search treeview
"RTN","HMPEF",314,0)
 ;;VA Allergies File
"RTN","HMPEF",315,0)
 ;;VA Allergies File (Synonyms)  SPACER ONLY - NOT DISPLAYED
"RTN","HMPEF",316,0)
 ;;National Drug File - Generic Drug Name
"RTN","HMPEF",317,0)
 ;;National Drug file - Trade Name
"RTN","HMPEF",318,0)
 ;;Local Drug File
"RTN","HMPEF",319,0)
 ;;Local Drug File (Synonyms)  SPACER ONLY - NOT DISPLAYED
"RTN","HMPEF",320,0)
 ;;Drug Ingredients File
"RTN","HMPEF",321,0)
 ;;VA Drug Class File
"RTN","HMPEF",322,0)
 ;;
"RTN","HMPEHL7")
0^90^B6545280^B3570530
"RTN","HMPEHL7",1,0)
HMPEHL7 ;SLC/MJK,ASMR/RRB,BL - HMP HL7 ADT Message Processor;May 15, 2016 14:15
"RTN","HMPEHL7",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPEHL7",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPEHL7",4,0)
 ;
"RTN","HMPEHL7",5,0)
 ; DE2818 SQA Findings.  Changed ADT entry to accept parameters ASMR/RRB
"RTN","HMPEHL7",6,0)
 ; DE4781 HL7 Delimiters. Add guards to check for delimiter values
"RTN","HMPEHL7",7,0)
 Q
"RTN","HMPEHL7",8,0)
 ;
"RTN","HMPEHL7",9,0)
ADT(HLFS,HLNEXT,HLNODE,HLQUIT) ; -- main entry point for the following HMP ADT client/router protocols:
"RTN","HMPEHL7",10,0)
 ;          - HMP ADT-A04 CLIENT protocol
"RTN","HMPEHL7",11,0)
 ;             o  subscribes to VAFC ADT-A04 SERVER 
"RTN","HMPEHL7",12,0)
 ;          - HMP ADT-A08 CLIENT protocol
"RTN","HMPEHL7",13,0)
 ;             o  subscribes to VAFC ADT-A08 SERVER 
"RTN","HMPEHL7",14,0)
 ;
"RTN","HMPEHL7",15,0)
 ; Note: These variables are provided by the VistA HL7 system when a
"RTN","HMPEHL7",16,0)
 ;       subscriber protocol's ROUTING LOGIC is called:
"RTN","HMPEHL7",17,0)
 ;            - HLNEXT
"RTN","HMPEHL7",18,0)
 ;            - HLQUIT
"RTN","HMPEHL7",19,0)
 ;            - HLNODE
"RTN","HMPEHL7",20,0)
 ;            - HL("FS")
"RTN","HMPEHL7",21,0)
 ;            - HL("ECH")
"RTN","HMPEHL7",22,0)
 ;
"RTN","HMPEHL7",23,0)
 ; -- Filters ADT/A04(registration) & A08 (patient security level change) events
"RTN","HMPEHL7",24,0)
 ;    Scans for PID segment and uses embedded DFN
"RTN","HMPEHL7",25,0)
 ;    Sets ^XTMP("HMPFS~... freshness queue
"RTN","HMPEHL7",26,0)
 ;
"RTN","HMPEHL7",27,0)
 NEW DONE,HMPSEG,HMPEVT
"RTN","HMPEHL7",28,0)
 SET DONE=0
"RTN","HMPEHL7",29,0)
 FOR  XECUTE HLNEXT QUIT:HLQUIT'>0  DO  QUIT:DONE
"RTN","HMPEHL7",30,0)
 . SET HMPSEG=$EXTRACT(HLNODE,1,3)
"RTN","HMPEHL7",31,0)
 . ;
"RTN","HMPEHL7",32,0)
 . IF HMPSEG="EVN" DO  QUIT
"RTN","HMPEHL7",33,0)
 . . SET HMPEVT=$PIECE(HLNODE,HLFS,2)
"RTN","HMPEHL7",34,0)
 . . IF HMPEVT="A04" QUIT
"RTN","HMPEHL7",35,0)
 . . ; -- 97 reason = sensitive patient change occurred
"RTN","HMPEHL7",36,0)
 . . IF HMPEVT="A08",$PIECE(HLNODE,HLFS,5)=97 QUIT
"RTN","HMPEHL7",37,0)
 . . ; -- not an event HMP is interested in so done with message
"RTN","HMPEHL7",38,0)
 . . SET DONE=1
"RTN","HMPEHL7",39,0)
 . ; -- PID segment always comes after EVN segment
"RTN","HMPEHL7",40,0)
 . IF HMPSEG'="PID" QUIT
"RTN","HMPEHL7",41,0)
 . SET DONE=1
"RTN","HMPEHL7",42,0)
 . ; -- HMPEVT should always be defined at this point
"RTN","HMPEHL7",43,0)
 . IF $G(HMPEVT)="" QUIT
"RTN","HMPEHL7",44,0)
 . ;DE4781;BL;The HL("FS") and HL("ECH") may not be set. Ensure there are values or quit.
"RTN","HMPEHL7",45,0)
 . ;Both of these values are specific to the HL(771 file
"RTN","HMPEHL7",46,0)
 . ;they are primary and secondary delimiters
"RTN","HMPEHL7",47,0)
 . I $G(HL("FS"))="" S HL("FS")=$G(HLFS)  ;if not set, set to the HLFS parameter
"RTN","HMPEHL7",48,0)
 . I $G(HL("ECH"))="" S HL("ECH")=$G(HLREC("ECH"))  ;if secondary delimiter not set
"RTN","HMPEHL7",49,0)
 . Q:$G(HL("FS"))=""!($G(HL("ECH"))="")  ;if delimiters not set quit
"RTN","HMPEHL7",50,0)
 . ;end DE4781
"RTN","HMPEHL7",51,0)
 . NEW DFN
"RTN","HMPEHL7",52,0)
 . SET DFN=+$PIECE($PIECE(HLNODE,HL("FS"),4),$EXTRACT(HL("ECH")))
"RTN","HMPEHL7",53,0)
 . IF 'DFN QUIT
"RTN","HMPEHL7",54,0)
 . DO POSTX^HMPEVNT("pt-select",DFN_"&"_HMPEVT)  ;Ref File event
"RTN","HMPEHL7",55,0)
 . IF $DATA(^HMP(800000,"AITEM",DFN)) DO POST^HMPEVNT(DFN,"patient",DFN)
"RTN","HMPEHL7",56,0)
 QUIT
"RTN","HMPEHL7",57,0)
 ;
"RTN","HMPEVNT")
0^64^B135046428^B129413290
"RTN","HMPEVNT",1,0)
HMPEVNT ;SLC/MKB,ASMR/JD,RRB,CPC -- VistA event listeners;May 15, 2016 14:15
"RTN","HMPEVNT",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPEVNT",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPEVNT",4,0)
 ;
"RTN","HMPEVNT",5,0)
 ; DE2818 - SQA findings.
"RTN","HMPEVNT",6,0)
 ;          1) Correct unkilled variables by modifying line tags to accept variables as
"RTN","HMPEVNT",7,0)
 ;          parameters and modifying associated protocol routine calls to pass variables
"RTN","HMPEVNT",8,0)
 ;          as parameters. RRB - 10/28/2015
"RTN","HMPEVNT",9,0)
 ;
"RTN","HMPEVNT",10,0)
 ; External References          DBIA#
"RTN","HMPEVNT",11,0)
 ; -------------------          -----
"RTN","HMPEVNT",12,0)
 ; DG FIELD MONITOR              3344
"RTN","HMPEVNT",13,0)
 ; DGPM MOVEMENT EVENTS          1181
"RTN","HMPEVNT",14,0)
 ; GMRA ENTERED IN ERROR         1467
"RTN","HMPEVNT",15,0)
 ; GMRA SIGN-OFF ON DATA         1469
"RTN","HMPEVNT",16,0)
 ; GMRC EVSEND OR                3140
"RTN","HMPEVNT",17,0)
 ; LR70 CH EVSEND OR             6087
"RTN","HMPEVNT",18,0)
 ; MDC OBSERVATION UPDATE        6084
"RTN","HMPEVNT",19,0)
 ; PS EVSEND OR                  2415
"RTN","HMPEVNT",20,0)
 ; PSB EVSEND HMP                6085
"RTN","HMPEVNT",21,0)
 ; PXK VISIT DATA EVENT          1298
"RTN","HMPEVNT",22,0)
 ; RA EVSEND OR                  6086
"RTN","HMPEVNT",23,0)
 ; SDAM APPOINTMENT EVENTS       1320
"RTN","HMPEVNT",24,0)
 ; ^AUPNVSIT                     2028
"RTN","HMPEVNT",25,0)
 ; ^DPT                         10035
"RTN","HMPEVNT",26,0)
 ; ^OR(100                       5771
"RTN","HMPEVNT",27,0)
 ; DIQ                           2056
"RTN","HMPEVNT",28,0)
 ; GMVUTL                        5046
"RTN","HMPEVNT",29,0)
 ; TIUSRVLO                      2834
"RTN","HMPEVNT",30,0)
 ; VADPT                        10061
"RTN","HMPEVNT",31,0)
 ; VASITE                       10112
"RTN","HMPEVNT",32,0)
 ; XLFDT                        10103
"RTN","HMPEVNT",33,0)
 ; XTHC10                        5515
"RTN","HMPEVNT",34,0)
 Q
"RTN","HMPEVNT",35,0)
 ;
"RTN","HMPEVNT",36,0)
DG(DGDA,DGFIELD,DGFILE) ; -- DG FIELD MONITOR protocol listener  /DE2818 
"RTN","HMPEVNT",37,0)
 Q:$G(DGFILE)'=2         ;Patient file only
"RTN","HMPEVNT",38,0)
 N DFN S DFN=+$G(DGDA)
"RTN","HMPEVNT",39,0)
 ; operational pt-select - *s68 BEGIN
"RTN","HMPEVNT",40,0)
 I "^.01^.02^.03^.09^.101^.351^.361^"[(U_+$G(DGFIELD)_U) D
"RTN","HMPEVNT",41,0)
 . ; -- if patient entry has been deleted, delete pt-select object
"RTN","HMPEVNT",42,0)
 . I $G(DGFIELD)=".01",'$D(^DPT(DFN)) D POSTX("pt-select",DFN,"@") Q  ; *s68 - END
"RTN","HMPEVNT",43,0)
 . D POSTX("pt-select",DFN_"&"_$G(DGFIELD))
"RTN","HMPEVNT",44,0)
 ; subscribed patient
"RTN","HMPEVNT",45,0)
 I $D(^HMP(800000,"AITEM",DFN)),$$FLD(+$G(DGFIELD)) D POST(DFN,"patient",DFN)
"RTN","HMPEVNT",46,0)
 Q
"RTN","HMPEVNT",47,0)
 ;
"RTN","HMPEVNT",48,0)
FLD(X) ; --Return 1 or 0, if X is a field tracked by HMP
"RTN","HMPEVNT",49,0)
 S X=U_+$G(X)_U
"RTN","HMPEVNT",50,0)
 I "^.01^.02^.03^.05^.08^.09^.351^.361^.364^"[X Q 1         ;demographic
"RTN","HMPEVNT",51,0)
 I "^.111^.1112^.112^.113^.114^.115^.131^.132^.134^"[X Q 1  ;addr/phone
"RTN","HMPEVNT",52,0)
 I "^.211^.212^.213^.214^.216^.217^.218^.219^"[X Q 1        ;NOK
"RTN","HMPEVNT",53,0)
 I "^.301^.302^1901^.32102^.32103^.32201^.5295^"[X Q 1      ;serv conn
"RTN","HMPEVNT",54,0)
 ;New fields.  JD - 9/24/15
"RTN","HMPEVNT",55,0)
 I "^.133^"[X Q 1                                           ;email address
"RTN","HMPEVNT",56,0)
 I "^.1211^.1212^.1213^.1214^.1215^.1216^"[X Q 1            ;temporary address
"RTN","HMPEVNT",57,0)
 I "^.331^.332^.333^.334^.335^.336^.337^.338^.339^.33011^"[X Q 1  ;emergency contact addr/phone
"RTN","HMPEVNT",58,0)
 I "^.215^.21011^"[X Q 1                                    ;NOK addr line 3 and work phone
"RTN","HMPEVNT",59,0)
 I "^.3731^"[X Q 1                                          ;service connected conditions
"RTN","HMPEVNT",60,0)
 I "^.18^3^8^16^"[X Q 1                                     ;insurance  
"RTN","HMPEVNT",61,0)
 Q 0
"RTN","HMPEVNT",62,0)
 ;
"RTN","HMPEVNT",63,0)
DGPM(DGPMA,DGPMDA,DGPMP,DGPMT) ; -- DGPM MOVEMENT EVENTS protocol listener  /DE2818
"RTN","HMPEVNT",64,0)
 ;    [expects DFN,DGPM* variables]
"RTN","HMPEVNT",65,0)
 N ADM,ACT S ADM=DGPMDA
"RTN","HMPEVNT",66,0)
 I DGPMT'=1 S ADM=$S(DGPMA:$P(DGPMA,U,14),1:$P(DGPMP,U,14)) Q:ADM<1
"RTN","HMPEVNT",67,0)
 S ACT=$S(DGPMA:"",1:"@")
"RTN","HMPEVNT",68,0)
 I $D(^HMP(800000,"AITEM",DFN)) D POST(DFN,"visit","H"_ADM,ACT)
"RTN","HMPEVNT",69,0)
 ; update roster(s) if current movement
"RTN","HMPEVNT",70,0)
 N ADMX,MVTX,PREV,NEW,OLD,WARD
"RTN","HMPEVNT",71,0)
 S ADMX=$Q(^DGPM("ATID1",DFN)) Q:$QS(ADMX,4)'=ADM
"RTN","HMPEVNT",72,0)
 S MVTX=$Q(^DGPM("APMV",DFN,ADM)) Q:$QS(MVTX,5)'=DGPMDA
"RTN","HMPEVNT",73,0)
 S PREV=$G(DGPMP) I 'PREV,DGPMT'=1 D  ;previous or edited mvt
"RTN","HMPEVNT",74,0)
 . S MVTX=$Q(@MVTX) Q:DFN'=$QS(MVTX,2)  Q:ADM'=$QS(MVTX,3)
"RTN","HMPEVNT",75,0)
 . S PREV=$G(^DGPM(+$QS(MVTX,5),0))
"RTN","HMPEVNT",76,0)
 S NEW=$P(DGPMA,U,6),OLD=$P(PREV,U,6)
"RTN","HMPEVNT",77,0)
 I NEW'=OLD F WARD=NEW,OLD I WARD D
"RTN","HMPEVNT",78,0)
 . S I=0 F  S I=$O(^HMPROSTR("AD",WARD_";DIC(42,",I)) Q:I<1  D POSTX("roster",I)
"RTN","HMPEVNT",79,0)
 Q
"RTN","HMPEVNT",80,0)
 ;-find visit# for corresponding admission [not used]
"RTN","HMPEVNT",81,0)
 N ADM,PTF,IDT,ID,ACT
"RTN","HMPEVNT",82,0)
 I DGPMA S ADM=+DGPMA,PTF=+$P(DGPMA,U,16)
"RTN","HMPEVNT",83,0)
 E  S ADM=+DGPMP,PTF=+$P(DGPMP,U,16)
"RTN","HMPEVNT",84,0)
 I DGPMT'=1 D  Q:ADM<1
"RTN","HMPEVNT",85,0)
 . N VAIP S VAIP("E")=DGPMDA
"RTN","HMPEVNT",86,0)
 . D IN5^VADPT S ADM=+VAIP(13,1),PTF=+VAIP(12)
"RTN","HMPEVNT",87,0)
 S IDT=9999999-$P(ADM,".") S:ADM["." IDT=IDT_"."_$P(ADM,".",2)
"RTN","HMPEVNT",88,0)
 S ID=+$O(^AUPNVSIT("AAH",DFN,IDT,0)) Q:'ID
"RTN","HMPEVNT",89,0)
 S ACT=$S(DGPMA:"",1:"@")
"RTN","HMPEVNT",90,0)
 D POST(DFN,"visit",ID,ACT)
"RTN","HMPEVNT",91,0)
 ; POST(DFN,"ptf",PTF,ACT):DGPMT=3
"RTN","HMPEVNT",92,0)
 Q
"RTN","HMPEVNT",93,0)
 ;
"RTN","HMPEVNT",94,0)
NEWINPT() ; -- is DFN newly admitted?
"RTN","HMPEVNT",95,0)
 N Y S Y=0
"RTN","HMPEVNT",96,0)
 I DGPMT=1,DGPMA,'DGPMP,+$G(^DPT(DFN,.105))=DGPMDA S Y=1 ;new admission
"RTN","HMPEVNT",97,0)
 Q Y
"RTN","HMPEVNT",98,0)
 ;
"RTN","HMPEVNT",99,0)
PCMMT(SCPTTMAF,SCPTTMB4) ; -- SCMC PATIENT TEAM CHANGES protocol listener /DE2818
"RTN","HMPEVNT",100,0)
 I '$P($G(SCPTTMB4),U,8),'$P($G(SCPTTMAF),U,8) Q  ;not pc change
"RTN","HMPEVNT",101,0)
 N DFN S DFN=$S($G(SCPTTMAF):+SCPTTMAF,1:+$G(SCPTTMB4)) Q:'DFN
"RTN","HMPEVNT",102,0)
 D POST(DFN,"patient",DFN)
"RTN","HMPEVNT",103,0)
 Q
"RTN","HMPEVNT",104,0)
 ;
"RTN","HMPEVNT",105,0)
PCMMTP(SCPTTPAF,SCPTTPB4) ; -- SCMC PATIENT TEAM POSITION CHANGES protocol listener /DE2818
"RTN","HMPEVNT",106,0)
 I '$P($G(SCPTTPB4),U,5),'$P($G(SCPTTPAF),U,5) Q  ;not pc change
"RTN","HMPEVNT",107,0)
 N TM,DFN
"RTN","HMPEVNT",108,0)
 S TM=$S($G(SCPTTPAF):+SCPTTPAF,1:+$G(SCPTTPB4)) Q:'TM
"RTN","HMPEVNT",109,0)
 ;DE2818
"RTN","HMPEVNT",110,0)
 S DFN=$$GET1^DIQ(404.42,+TM_",",.01,"I")  ;ICR 1922
"RTN","HMPEVNT",111,0)
 D POST(DFN,"patient",DFN)
"RTN","HMPEVNT",112,0)
 Q
"RTN","HMPEVNT",113,0)
 ;
"RTN","HMPEVNT",114,0)
SDAM(SDATA) ; -- SDAM APPOINTMENT EVENTS protocol listener /DE2818
"RTN","HMPEVNT",115,0)
 I $G(SDATA) D  Q  ;appointments
"RTN","HMPEVNT",116,0)
 . N DFN,DATE,HLOC,STS,REASON,PROV
"RTN","HMPEVNT",117,0)
 . S DFN=+$P(SDATA,U,2) Q:DFN<1
"RTN","HMPEVNT",118,0)
 . Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",119,0)
 . S DATE=+$P(SDATA,U,3),HLOC=+$P(SDATA,U,4),(PROV,REASON)=""
"RTN","HMPEVNT",120,0)
 . ;I SDAMEVT=1 K DIR S DIR(0)="F^3:20",DIR("A")="Enter Reason for Appointment: ",DIR("?")="Answer must be 2-20 characters" D ^DIR S REASON=Y
"RTN","HMPEVNT",121,0)
 . ;I SDAMEVT=1 K DIC S DIC="^VA(200,",DIC("A")="Select Patient's Provider: ",DIC(0)="AEQ",D="AK.PROVIDER" D IX^DIC S PROV=$P(Y,"^",1,2)
"RTN","HMPEVNT",122,0)
 . D POST(DFN,"appointment","A;"_DATE_";"_HLOC_";"_REASON_";"_$TR($P(PROV,U,1,2),"^",";"))
"RTN","HMPEVNT",123,0)
 Q
"RTN","HMPEVNT",124,0)
 ;
"RTN","HMPEVNT",125,0)
PCE ; -- PXK VISIT DATA EVENT protocol listener
"RTN","HMPEVNT",126,0)
 N IEN,PX0A,PX0B,DFN,DA,ACT,HMPPXK,ZTRTN,ZTDESC,ZTDTH,ZTIO,ZTSAVE,ZTSK ;DE4195
"RTN","HMPEVNT",127,0)
 S IEN=+$O(^TMP("PXKCO",$J,0)) Q:IEN<1
"RTN","HMPEVNT",128,0)
 S PX0A=$G(^TMP("PXKCO",$J,IEN,"VST",IEN,0,"AFTER")),PX0B=$G(^("BEFORE"))
"RTN","HMPEVNT",129,0)
 S DFN=$S($L(PX0A):+$P(PX0A,U,5),1:+$P(PX0B,U,5))
"RTN","HMPEVNT",130,0)
 Q:DFN<1  Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",131,0)
 S ACT=$S(PX0A="":"@",1:"")
"RTN","HMPEVNT",132,0)
 ;DE4195 - put subsequent processing into taskman
"RTN","HMPEVNT",133,0)
 M HMPPXK=^TMP("PXKCO",$J)
"RTN","HMPEVNT",134,0)
 S ZTRTN="PCE2^HMPEVNT",ZTDTH=$H
"RTN","HMPEVNT",135,0)
 S ZTSAVE("HMPPXK(")="",ZTSAVE("DFN")="",ZTSAVE("IEN")="",ZTSAVE("ACT")=""
"RTN","HMPEVNT",136,0)
 S ZTDESC="HMP PXK VISIT EVENT HANDLER"
"RTN","HMPEVNT",137,0)
 D ^%ZTLOAD
"RTN","HMPEVNT",138,0)
 Q
"RTN","HMPEVNT",139,0)
PCE2 ; DE4195 - run in taskman
"RTN","HMPEVNT",140,0)
 N DA,SUB
"RTN","HMPEVNT",141,0)
 D POST(DFN,"visit",IEN,ACT)
"RTN","HMPEVNT",142,0)
 ; check V-files
"RTN","HMPEVNT",143,0)
 F SUB="HF","IMM","XAM","CPT","PED","POV","SK" D
"RTN","HMPEVNT",144,0)
 . S DA=0 F  S DA=$O(HMPPXK(IEN,SUB,DA)) Q:DA<1  D
"RTN","HMPEVNT",145,0)
 .. S ACT=$S($G(HMPPXK(IEN,SUB,DA,0,"AFTER"))="":"@",1:"")
"RTN","HMPEVNT",146,0)
 .. D POST(DFN,$$NAME(SUB),DA,ACT)
"RTN","HMPEVNT",147,0)
 Q
"RTN","HMPEVNT",148,0)
 ;
"RTN","HMPEVNT",149,0)
NAME(X) ; -- return object name for V-files
"RTN","HMPEVNT",150,0)
 N Y S Y=""
"RTN","HMPEVNT",151,0)
 I X="HF"  S Y="factor"
"RTN","HMPEVNT",152,0)
 I X="IMM" S Y="immunization"
"RTN","HMPEVNT",153,0)
 I X="XAM" S Y="exam"
"RTN","HMPEVNT",154,0)
 I X="CPT" S Y="cpt"
"RTN","HMPEVNT",155,0)
 I X="PED" S Y="education"
"RTN","HMPEVNT",156,0)
 I X="POV" S Y="pov"
"RTN","HMPEVNT",157,0)
 I X="SK"  S Y="skin"
"RTN","HMPEVNT",158,0)
 Q Y
"RTN","HMPEVNT",159,0)
 ;
"RTN","HMPEVNT",160,0)
ZPCE ; -- old PXK VISIT DATA EVENT protocol listener [not in use]
"RTN","HMPEVNT",161,0)
 N IEN,PX0,PX150,DFN,DA
"RTN","HMPEVNT",162,0)
 S IEN=+$O(^TMP("PXKCO",$J,0)) Q:IEN<1
"RTN","HMPEVNT",163,0)
 S PX0=$G(^TMP("PXKCO",$J,IEN,"VST",IEN,0,"AFTER")) Q:$P(PX0,U,7)="E"
"RTN","HMPEVNT",164,0)
 I PX0="" D POST(DFN,"visit",IEN,"@") Q  ;deleted
"RTN","HMPEVNT",165,0)
 S PX150=$G(^TMP("PXKCO",$J,IEN,"VST",IEN,150,"AFTER")) Q:$P(PX150,U,3)'="P"
"RTN","HMPEVNT",166,0)
 S DFN=+$P(PX0,U,5) Q:DFN<1  Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",167,0)
 D POST(DFN,"visit",IEN)
"RTN","HMPEVNT",168,0)
 S DA=0 F  S DA=$O(^TMP("PXKCO",$J,IEN,"IMM",DA)) Q:DA<1  D POST(DFN,"immunization",DA)
"RTN","HMPEVNT",169,0)
 S DA=0 F  S DA=$O(^TMP("PXKCO",$J,IEN,"HF",DA)) Q:DA<1  D POST(DFN,"factor",DA)
"RTN","HMPEVNT",170,0)
 Q
"RTN","HMPEVNT",171,0)
 ;
"RTN","HMPEVNT",172,0)
XQOR(MSG) ; -- messaging listener (update meds, labs, xrays, consults)
"RTN","HMPEVNT",173,0)
 N HMPMSG,HMPPKG,MSH,ORC,DFN
"RTN","HMPEVNT",174,0)
 S HMPMSG=$S($L($G(MSG)):MSG,1:"MSG") Q:'$O(@HMPMSG@(0))
"RTN","HMPEVNT",175,0)
 S MSH=0 F  S MSH=$O(@HMPMSG@(MSH)) Q:MSH'>0  Q:$E(@HMPMSG@(MSH),1,3)="MSH"
"RTN","HMPEVNT",176,0)
 Q:'MSH  Q:'$L($G(@HMPMSG@(MSH)))
"RTN","HMPEVNT",177,0)
 S HMPPKG=$$TYPE($P(@HMPMSG@(MSH),"|",3))  Q:'$L(HMPPKG)
"RTN","HMPEVNT",178,0)
 S DFN=$$PID Q:DFN<1  Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",179,0)
 S ORC=MSH F  S ORC=$O(@HMPMSG@(+ORC)) Q:ORC'>0  I $E(@HMPMSG@(ORC),1,3)="ORC" D
"RTN","HMPEVNT",180,0)
 . N ORDCNTRL,PKGIFN,ORIFN
"RTN","HMPEVNT",181,0)
 . S ORC=ORC_U_@HMPMSG@(ORC),ORDCNTRL=$TR($P(ORC,"|",2),"@","P")
"RTN","HMPEVNT",182,0)
 . ; QUIT if action failed, conversion, purge, or backdoor verify/new
"RTN","HMPEVNT",183,0)
 . I ORDCNTRL["U"!("DE^ZC^ZP^ZR^ZV^SN"[ORDCNTRL) Q
"RTN","HMPEVNT",184,0)
 . S ORIFN=+$P($P(ORC,"|",3),U),PKGIFN=$P($P(ORC,"|",4),U)
"RTN","HMPEVNT",185,0)
 . ; if order has a parent, use parent# and update entire order
"RTN","HMPEVNT",186,0)
 . S ORIFN=$S($P($G(^OR(100,ORIFN,3)),U,9):$P(^(3),U,9),1:ORIFN)
"RTN","HMPEVNT",187,0)
 . I $$RESULT D  ;update ancillary domains
"RTN","HMPEVNT",188,0)
 .. D POST(DFN,HMPPKG,PKGIFN)
"RTN","HMPEVNT",189,0)
 .. D:HMPPKG="image" POST(DFN,"document",PKGIFN)
"RTN","HMPEVNT",190,0)
 .. I HMPPKG="lab",PKGIFN'["CH",'$$LRTIU(DFN,PKGIFN) D POST(DFN,"document",$P(PKGIFN,";",4,5))
"RTN","HMPEVNT",191,0)
 . I ORIFN,ORDCNTRL'="ZD" D  ;update order(s)
"RTN","HMPEVNT",192,0)
 .. D POST(DFN,"order",ORIFN)
"RTN","HMPEVNT",193,0)
 .. N ORIG S ORIG=+$P($G(^OR(100,ORIFN,3)),U,5)
"RTN","HMPEVNT",194,0)
 .. I ORIG D POST(DFN,"order",ORIG) ;need fwd ptrs, sig flds
"RTN","HMPEVNT",195,0)
 Q
"RTN","HMPEVNT",196,0)
 ;
"RTN","HMPEVNT",197,0)
RESULT() ; -- Return 1 or 0, if message broadcasts a result
"RTN","HMPEVNT",198,0)
 ;           [may modify PKGIFN for use in POST]
"RTN","HMPEVNT",199,0)
 N Y S Y=0
"RTN","HMPEVNT",200,0)
 I HMPPKG="consult" S Y=1,PKGIFN=+PKGIFN G RQ
"RTN","HMPEVNT",201,0)
 I HMPPKG="med"     S Y=1,PKGIFN=ORIFN G RQ
"RTN","HMPEVNT",202,0)
 I HMPPKG="lab"     S:ORDCNTRL="RE"&($L(PKGIFN,";")>3) Y=1 G RQ
"RTN","HMPEVNT",203,0)
 I HMPPKG="image"   S:PKGIFN["~" Y=1,PKGIFN=$TR($P(PKGIFN,"~",2,3),"~","-") G RQ
"RTN","HMPEVNT",204,0)
RQ Q Y
"RTN","HMPEVNT",205,0)
 ;
"RTN","HMPEVNT",206,0)
LRTIU(DFN,ORPK) ; -- Return 1 or 0, if LR report is in TIU
"RTN","HMPEVNT",207,0)
 I $G(DFN)<1!'$L($G(ORPK)) Q 0
"RTN","HMPEVNT",208,0)
 I ORPK["CH"!(ORPK["MI") Q 0
"RTN","HMPEVNT",209,0)
 N SUB,IDT,LRDFN
"RTN","HMPEVNT",210,0)
 S SUB=$P(ORPK,";",4),IDT=+$P(ORPK,";",5),LRDFN=+$G(^DPT(+DFN,"LR"))
"RTN","HMPEVNT",211,0)
 I $O(^LR(LRDFN,SUB,IDT,.05,0)) Q 1
"RTN","HMPEVNT",212,0)
 Q 0
"RTN","HMPEVNT",213,0)
 ;
"RTN","HMPEVNT",214,0)
NA(MSG) ; -- messaging listener (new backdoor orders)
"RTN","HMPEVNT",215,0)
 N HMPMSG,HMPPKG,MSH,ORC,DFN
"RTN","HMPEVNT",216,0)
 S HMPMSG=$S($L($G(MSG)):MSG,1:"MSG") Q:'$O(@HMPMSG@(0))
"RTN","HMPEVNT",217,0)
 S MSH=0 F  S MSH=$O(@HMPMSG@(MSH)) Q:MSH'>0  Q:$E(@HMPMSG@(MSH),1,3)="MSH"
"RTN","HMPEVNT",218,0)
 Q:'MSH  Q:'$L($G(@HMPMSG@(MSH)))
"RTN","HMPEVNT",219,0)
 S HMPPKG=$$TYPE($P(@HMPMSG@(MSH),"|",5))  Q:'$L(HMPPKG)
"RTN","HMPEVNT",220,0)
 S DFN=$$PID Q:DFN<1  Q:'$D(^HMP(800000,"AITEM",DFN))
"RTN","HMPEVNT",221,0)
 S ORC=MSH F  S ORC=$O(@HMPMSG@(+ORC)) Q:ORC'>0  I $E(@HMPMSG@(ORC),1,3)="ORC" D
"RTN","HMPEVNT",222,0)
 . N ORDCNTRL,ORIFN
"RTN","HMPEVNT",223,0)
 . S ORC=ORC_U_@HMPMSG@(ORC),ORDCNTRL=$TR($P(ORC,"|",2),"@","P")
"RTN","HMPEVNT",224,0)
 . Q:ORDCNTRL'="NA"
"RTN","HMPEVNT",225,0)
 . S ORIFN=+$P($P(ORC,"|",3),U) D POST(DFN,"order",ORIFN)
"RTN","HMPEVNT",226,0)
 . I HMPPKG="med" D POST(DFN,HMPPKG,ORIFN)
"RTN","HMPEVNT",227,0)
 Q
"RTN","HMPEVNT",228,0)
 ;
"RTN","HMPEVNT",229,0)
TYPE(NAME) ; -- Returns type name for XML
"RTN","HMPEVNT",230,0)
 I NAME="LABORATORY"  Q "lab"
"RTN","HMPEVNT",231,0)
 I NAME="PHARMACY"    Q "med"
"RTN","HMPEVNT",232,0)
 I NAME="CONSULTS"    Q "consult"
"RTN","HMPEVNT",233,0)
 I NAME="PROCEDURES"  Q "consult"
"RTN","HMPEVNT",234,0)
 I NAME="RADIOLOGY"   Q "image"
"RTN","HMPEVNT",235,0)
 I NAME="IMAGING"     Q "image"
"RTN","HMPEVNT",236,0)
 I NAME="ORDER ENTRY" Q "order"
"RTN","HMPEVNT",237,0)
 I NAME="DIETETICS"   Q "diet"
"RTN","HMPEVNT",238,0)
 Q ""
"RTN","HMPEVNT",239,0)
 ;
"RTN","HMPEVNT",240,0)
PID() ; -- Returns patient from PID segment in current msg
"RTN","HMPEVNT",241,0)
 N I,SEG,Y S I=MSH
"RTN","HMPEVNT",242,0)
 F  S I=$O(@HMPMSG@(I)) Q:I'>0  S SEG=$E(@HMPMSG@(I),1,3) Q:SEG="ORC"  I SEG="PID" D  Q
"RTN","HMPEVNT",243,0)
 . S Y=+$P(@HMPMSG@(I),"|",4)
"RTN","HMPEVNT",244,0)
 .;I '$D(^DPT(Y,0)) S:$L($P(@HMPMSG@(I),"|",5)) Y=+$P(@HMPMSG@(I),"|",5) ;alt ID for Lab
"RTN","HMPEVNT",245,0)
 Q Y
"RTN","HMPEVNT",246,0)
 ;
"RTN","HMPEVNT",247,0)
PV1() ; -- Returns patient class from PV1 segment in current msg
"RTN","HMPEVNT",248,0)
 N I,SEG,Y S I=MSH,Y=""
"RTN","HMPEVNT",249,0)
 F  S I=$O(@HMPMSG@(I)) Q:I'>0  S SEG=$E(@HMPMSG@(I),1,3) Q:SEG="ORC"  I SEG="PV1" D  Q
"RTN","HMPEVNT",250,0)
 . S Y=$P(@HMPMSG@(I),"|",3)
"RTN","HMPEVNT",251,0)
 I Y="",$G(ORIFN) S Y=$$GET1^DIQ(100,+ORIFN_",",10,"I")
"RTN","HMPEVNT",252,0)
 Q Y
"RTN","HMPEVNT",253,0)
 ;
"RTN","HMPEVNT",254,0)
GMRA(ACT) ; -- GMRA SIGN-OFF ON DATA protocol listener
"RTN","HMPEVNT",255,0)
 ;   also GMRA ENTERED IN ERROR [ACT=@]
"RTN","HMPEVNT",256,0)
 N DFN,IEN
"RTN","HMPEVNT",257,0)
 S DFN=+$G(GMRAPA(0)),IEN=+$G(GMRAPA)
"RTN","HMPEVNT",258,0)
 D POST(DFN,"allergy",IEN,$G(ACT))
"RTN","HMPEVNT",259,0)
 Q
"RTN","HMPEVNT",260,0)
 ;
"RTN","HMPEVNT",261,0)
GMPL(DFN,IEN) ; -- GMPL EVENT protocol listener
"RTN","HMPEVNT",262,0)
 S DFN=+$G(DFN),IEN=+$G(IEN)
"RTN","HMPEVNT",263,0)
 ;N ACT S ACT=$S($P($G(^AUPNPROB(IEN,1)),U,2)="H":"@",1:"")
"RTN","HMPEVNT",264,0)
 D POST(DFN,"problem",IEN) ;,ACT)
"RTN","HMPEVNT",265,0)
 Q
"RTN","HMPEVNT",266,0)
 ;
"RTN","HMPEVNT",267,0)
GMRV(DFN,IEN,ERR) ; -- Vital Measurement file #120.5 AHMP index
"RTN","HMPEVNT",268,0)
 S DFN=+$G(DFN),IEN=+$G(IEN)
"RTN","HMPEVNT",269,0)
 N ACT S ACT=$S($G(ERR):"@",1:"")
"RTN","HMPEVNT",270,0)
 D POST(DFN,"vital",IEN,ACT)
"RTN","HMPEVNT",271,0)
 Q
"RTN","HMPEVNT",272,0)
 ;
"RTN","HMPEVNT",273,0)
MDC(OBS) ; -- MDC OBSERVATION UPDATE protocol listener
"RTN","HMPEVNT",274,0)
 N DFN,ID,ACT
"RTN","HMPEVNT",275,0)
 S DFN=+$G(OBS("PATIENT_ID","I")) Q:DFN<1
"RTN","HMPEVNT",276,0)
 S ID=$G(OBS("OBS_ID","I")) Q:'$L(ID)
"RTN","HMPEVNT",277,0)
 S ACT=$S('$G(OBS("STATUS","I")):"@",1:"")
"RTN","HMPEVNT",278,0)
 D POST(DFN,"obs",ID,ACT)
"RTN","HMPEVNT",279,0)
 I $G(OBS("DOMAIN","VITALS")) D POST(DFN,"vital",ID,ACT)
"RTN","HMPEVNT",280,0)
 Q
"RTN","HMPEVNT",281,0)
 ;
"RTN","HMPEVNT",282,0)
CP(DFN,ID,ACT) ; -- CP Transaction file #702 AHMP index
"RTN","HMPEVNT",283,0)
 S DFN=+$G(DFN),ID=$G(ID)
"RTN","HMPEVNT",284,0)
 D POST(DFN,"procedure",ID,$G(ACT))
"RTN","HMPEVNT",285,0)
 Q
"RTN","HMPEVNT",286,0)
 ;
"RTN","HMPEVNT",287,0)
SR(DFN,IEN,ACT) ; -- Surgery [SROERR] update
"RTN","HMPEVNT",288,0)
 S DFN=+$G(DFN),IEN=+$G(IEN)
"RTN","HMPEVNT",289,0)
 D POST(DFN,"surgery",IEN,$G(ACT))
"RTN","HMPEVNT",290,0)
 Q
"RTN","HMPEVNT",291,0)
 ;*s68 - BEGINS
"RTN","HMPEVNT",292,0)
TIU(DFN,IEN) ; -- TIU Document file #8925 AHMP index
"RTN","HMPEVNT",293,0)
 N ACT,STS,DAD
"RTN","HMPEVNT",294,0)
 S DFN=+$G(DFN),IEN=+$G(IEN),ACT=""
"RTN","HMPEVNT",295,0)
 S STS=$G(X(2)),DAD=$G(X(3)) ;X = FM data array for index
"RTN","HMPEVNT",296,0)
 S:DAD IEN=DAD I 'DAD D      ;if addendum, repull entire note
"RTN","HMPEVNT",297,0)
 . I STS=15 S ACT="@"        ;retracted
"RTN","HMPEVNT",298,0)
 . I $G(X2(1))="" S ACT="@"  ;deleted (new title = null)
"RTN","HMPEVNT",299,0)
 D POST(DFN,"document",IEN,ACT)
"RTN","HMPEVNT",300,0)
 Q
"RTN","HMPEVNT",301,0)
 ; Deprecated calls
"RTN","HMPEVNT",302,0)
DOCDEF ;
"RTN","HMPEVNT",303,0)
DOCITEM ;
"RTN","HMPEVNT",304,0)
USR ;
"RTN","HMPEVNT",305,0)
 Q
"RTN","HMPEVNT",306,0)
 ; *s68 - END
"RTN","HMPEVNT",307,0)
PSB(PSBIEN) ; -- HMP PSB EVENTS protocol listener (BCMA) /DE2818
"RTN","HMPEVNT",308,0)
 N IEN,DFN,ORPK,TYPE,ORIFN
"RTN","HMPEVNT",309,0)
 S IEN=$S($P($G(PSBIEN),",",2)'="":+$P(PSBIEN,",",2),$G(PSBIEN)="+1":+$G(PSBIEN(1)),1:+$G(PSBIEN))
"RTN","HMPEVNT",310,0)
 S DFN=+$G(^PSB(53.79,IEN,0)),ORPK=$P($G(^(.1)),U)
"RTN","HMPEVNT",311,0)
 Q:DFN<1  Q:ORPK<1  S TYPE=$S(ORPK["V":"IV",ORPK["U":5,1:"") Q:TYPE=""
"RTN","HMPEVNT",312,0)
 S ORIFN=+$P($G(^PS(55,DFN,TYPE,+ORPK,0)),U,21)
"RTN","HMPEVNT",313,0)
 D:ORIFN POST(DFN,"med",ORIFN)
"RTN","HMPEVNT",314,0)
 Q
"RTN","HMPEVNT",315,0)
 ;
"RTN","HMPEVNT",316,0)
XU(IEN,ACT) ; -- XU USER ADD/CHANGE/TERMINATE option listener
"RTN","HMPEVNT",317,0)
 S IEN=+$G(IEN) Q:IEN<1
"RTN","HMPEVNT",318,0)
 D POSTX("user",IEN,$G(ACT))
"RTN","HMPEVNT",319,0)
 Q
"RTN","HMPEVNT",320,0)
 ;
"RTN","HMPEVNT",321,0)
POST(DFN,TYPE,ID,ACT) ; -- track updated patient data
"RTN","HMPEVNT",322,0)
 S DFN=+$G(DFN),TYPE=$G(TYPE),ID=$G(ID)
"RTN","HMPEVNT",323,0)
 Q:DFN<1  Q:TYPE=""  Q:ID=""   ;incomplete request
"RTN","HMPEVNT",324,0)
 Q:$G(^XTMP("HMP-off",TYPE))   ;domain turned 'off'
"RTN","HMPEVNT",325,0)
 Q:'$D(^HMP(800000,"AITEM",DFN))  ;patient not subscribed to
"RTN","HMPEVNT",326,0)
 N HMPDT S HMPDT="HMP-"_DT
"RTN","HMPEVNT",327,0)
 ;S ^XTMP(HMPDT,$$NEXT)=DFN_U_TYPE_U_ID_U_$G(ACT)
"RTN","HMPEVNT",328,0)
 N NODES
"RTN","HMPEVNT",329,0)
 D POST^HMPDJFS(DFN,TYPE,ID,$G(ACT),"",.NODES)
"RTN","HMPEVNT",330,0)
 Q
"RTN","HMPEVNT",331,0)
 ;
"RTN","HMPEVNT",332,0)
POSTX(TYPE,ID,ACT) ; -- track updated reference items
"RTN","HMPEVNT",333,0)
 S TYPE=$G(TYPE),ID=$G(ID)
"RTN","HMPEVNT",334,0)
 Q:TYPE=""  Q:ID=""            ;incomplete request
"RTN","HMPEVNT",335,0)
 Q:$G(^XTMP("HMP-off",TYPE))   ;domain turned 'off'
"RTN","HMPEVNT",336,0)
 N HMPDT S HMPDT="HMP-"_DT ;"HMPEF-"_DT
"RTN","HMPEVNT",337,0)
 ;S ^XTMP(HMPDT,$$NEXT)=U_TYPE_U_ID_U_$G(ACT)
"RTN","HMPEVNT",338,0)
 N NODES
"RTN","HMPEVNT",339,0)
 D POST^HMPDJFS("OPD",TYPE,ID,$G(ACT),"",.NODES)
"RTN","HMPEVNT",340,0)
 Q
"RTN","HMPEVNT",341,0)
 ;
"RTN","HMPEVNT",342,0)
NEXT() ; -- Return next sequential number in ^XTMP(HMPDT,n)
"RTN","HMPEVNT",343,0)
 L +^XTMP(HMPDT):5 ;I'$T ??
"RTN","HMPEVNT",344,0)
 N Y S Y=+$O(^XTMP(HMPDT,"A"),-1)+1
"RTN","HMPEVNT",345,0)
 I '$D(^XTMP(HMPDT,0)) S ^(0)=$$FMADD^XLFDT(DT,3)_U_DT_"^HMP Updates"
"RTN","HMPEVNT",346,0)
 L -^XTMP(HMPDT)
"RTN","HMPEVNT",347,0)
 Q Y
"RTN","HMPEVNT",348,0)
 ;
"RTN","HMPEVNT",349,0)
HTTP(URL,DFN,TYPE,ID) ; -- send message that TYPE/ID has been updated [not in use]
"RTN","HMPEVNT",350,0)
 N DIV,X,HMPX
"RTN","HMPEVNT",351,0)
 S DFN=+$G(DFN) Q:DFN<1  ;patient req'd
"RTN","HMPEVNT",352,0)
 S DIV=$P($$SITE^VASITE,U,3) ;station number
"RTN","HMPEVNT",353,0)
 S URL=$G(URL)_"?division="_DIV_"&dfn="_+$G(DFN)
"RTN","HMPEVNT",354,0)
 I $L($G(TYPE)) S URL=URL_"&type="_TYPE
"RTN","HMPEVNT",355,0)
 I $L($G(ID))   S URL=URL_"&id="_ID
"RTN","HMPEVNT",356,0)
 S ^XTMP("HMP",DFN,"HTTP")=$H
"RTN","HMPEVNT",357,0)
 S X=$$GETURL^XTHC10(URL,,"HMPX")
"RTN","HMPEVNT",358,0)
 ; I X>200 = ERROR
"RTN","HMPEVNT",359,0)
 Q
"RTN","HMPHTTP")
0^66^B14150503^B14631122
"RTN","HMPHTTP",1,0)
HMPHTTP ;SLC/MKB,ASMR/RRB,CK - HTTP interface;May 15, 2016 14:15
"RTN","HMPHTTP",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPHTTP",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPHTTP",4,0)
 ;
"RTN","HMPHTTP",5,0)
 ; External References          DBIA#
"RTN","HMPHTTP",6,0)
 ; -------------------          -----
"RTN","HMPHTTP",7,0)
 ; %ZTLOAD                      10063
"RTN","HMPHTTP",8,0)
 ; DIR                          10026
"RTN","HMPHTTP",9,0)
 ; VASITE                       10112
"RTN","HMPHTTP",10,0)
 ; XLFCRC                        3156
"RTN","HMPHTTP",11,0)
 ; XLFUTL                        2622
"RTN","HMPHTTP",12,0)
 ; XPAR                          2263
"RTN","HMPHTTP",13,0)
 ; XTHC10                        5515
"RTN","HMPHTTP",14,0)
 ; XUPARAM                       2541
"RTN","HMPHTTP",15,0)
 Q
"RTN","HMPHTTP",16,0)
 ;
"RTN","HMPHTTP",17,0)
EN ; -- manage the background job
"RTN","HMPHTTP",18,0)
 N ZTSK,STS
"RTN","HMPHTTP",19,0)
 S ZTSK=+$G(^XTMP("HMP","ZTSK")),STS=$$STS
"RTN","HMPHTTP",20,0)
 W !,?24,"--- HMP Patient Data Monitor ---"
"RTN","HMPHTTP",21,0)
 W !!,"Task"_$S(ZTSK:" #"_ZTSK,1:"")_" is "_$P(STS,U,2)_".",!
"RTN","HMPHTTP",22,0)
 ;
"RTN","HMPHTTP",23,0)
 I ZTSK,+STS=1!(+STS=2) D:$$STOP  Q
"RTN","HMPHTTP",24,0)
 . N X S X=$$ASKSTOP^%ZTLOAD(ZTSK)
"RTN","HMPHTTP",25,0)
 . W !,$P(X,U,2),!
"RTN","HMPHTTP",26,0)
 ;
"RTN","HMPHTTP",27,0)
 I $$START D
"RTN","HMPHTTP",28,0)
 . W !!,"Starting HMP Patient Data Monitor ... " D QUE
"RTN","HMPHTTP",29,0)
 . I $G(ZTSK) W "task #"_ZTSK_" started.",!
"RTN","HMPHTTP",30,0)
 . E  W !,"ERROR: task NOT created.  Try again later.",!
"RTN","HMPHTTP",31,0)
 . S ^XTMP("HMP","ZTSK")=$G(ZTSK)
"RTN","HMPHTTP",32,0)
 Q
"RTN","HMPHTTP",33,0)
 ;
"RTN","HMPHTTP",34,0)
STS() ; -- get the status of ZTSK
"RTN","HMPHTTP",35,0)
 D STAT^%ZTLOAD
"RTN","HMPHTTP",36,0)
 N Y S Y=+$G(ZTSK(1))_U_$G(ZTSK(2))
"RTN","HMPHTTP",37,0)
 Q Y
"RTN","HMPHTTP",38,0)
 ;
"RTN","HMPHTTP",39,0)
STOP() ; -- stop the task?
"RTN","HMPHTTP",40,0)
 N X,Y,DIR
"RTN","HMPHTTP",41,0)
 S DIR("A")="Do you want to stop the data monitor? ",DIR(0)="YA",DIR("B")="NO"
"RTN","HMPHTTP",42,0)
 S DIR("?",1)="Enter YES to stop or cancel the data monitor; please restart ASAP!"
"RTN","HMPHTTP",43,0)
 S DIR("?",3)="This job must be running in the background for AViVA to be notified"
"RTN","HMPHTTP",44,0)
 S DIR("?")="when new patient data is available.",DIR("?",2)="  "
"RTN","HMPHTTP",45,0)
 D ^DIR S:Y<1 Y=0
"RTN","HMPHTTP",46,0)
 Q Y
"RTN","HMPHTTP",47,0)
 ;
"RTN","HMPHTTP",48,0)
START() ; -- [re]start the task?
"RTN","HMPHTTP",49,0)
 N X,Y,DIR
"RTN","HMPHTTP",50,0)
 S DIR(0)="YA",DIR("B")="YES"
"RTN","HMPHTTP",51,0)
 S DIR("A")="Do you want to "_$S(STS:"re",1:"")_"start the data monitor? "
"RTN","HMPHTTP",52,0)
 S DIR("?",1)="Enter YES to "_$S(STS:"re",1:"")_"start the HMP Patient Data Monitor."
"RTN","HMPHTTP",53,0)
 S DIR("?",3)="This job must be running in the background for AViVA to be notified"
"RTN","HMPHTTP",54,0)
 S DIR("?")="when new patient data is available.",DIR("?",2)="  "
"RTN","HMPHTTP",55,0)
 D ^DIR S:Y<1 Y=0
"RTN","HMPHTTP",56,0)
 Q Y
"RTN","HMPHTTP",57,0)
 ;
"RTN","HMPHTTP",58,0)
QUE ; -- create the background task: returns ZTSK
"RTN","HMPHTTP",59,0)
 N IO,IOP,ZTRTN,ZTDESC,ZTDTH,ZTIO,ZTUCI,ZTCPU,ZTPRI,ZTKIL,ZTSYNC,ZTSAVE,%ZIS
"RTN","HMPHTTP",60,0)
 S %ZIS="0H",IOP="NULL" D ^%ZIS I POP W !,"Null Device Not Found" Q
"RTN","HMPHTTP",61,0)
 S ZTDESC="HMP new data monitor for AViVA",ZTDTH=$H,ZTIO=""
"RTN","HMPHTTP",62,0)
 S ZTRTN="POKE^HMPHTTP" K ZTSK
"RTN","HMPHTTP",63,0)
 D ^%ZTLOAD
"RTN","HMPHTTP",64,0)
 Q
"RTN","HMPHTTP",65,0)
 ;
"RTN","HMPHTTP",66,0)
POKE ; -- background job to poke the client when new data is available
"RTN","HMPHTTP",67,0)
 ; ^XTMP("HMP",DFN,TYPE,ID) = new data since last update
"RTN","HMPHTTP",68,0)
 N DIV,ID,DFN,DATA,IOP,X,DA,TOKEN,NEW K ZTSTOP,ZTREQ
"RTN","HMPHTTP",69,0)
 S IOP="NULL" D ^%ZIS
"RTN","HMPHTTP",70,0)
 S ID=(+$H)+$P($H,",",2)
"RTN","HMPHTTP",71,0)
 S DFN=0 F  S DFN=$O(^XTMP("HMP",DFN)) Q:DFN<1  I $D(^(DFN))>9 D
"RTN","HMPHTTP",72,0)
 . L +^XTMP("HMP",DFN):5 Q:'$T  ;try again next cycle
"RTN","HMPHTTP",73,0)
 . K DATA M DATA=^XTMP("HMP",DFN)
"RTN","HMPHTTP",74,0)
 . S X=$G(^XTMP("HMP",DFN)) K ^(DFN) S ^(DFN)=X ;clear list, keep subscription
"RTN","HMPHTTP",75,0)
 . L -^XTMP("HMP",DFN)
"RTN","HMPHTTP",76,0)
 . ; add to list for URL
"RTN","HMPHTTP",77,0)
 . S DA=0 F  S DA=$O(^HMP(800000,"ADFN",DFN,DA)) Q:DA<1  D
"RTN","HMPHTTP",78,0)
 .. S TOKEN=DA_"~"_ID,NEW(TOKEN)=""
"RTN","HMPHTTP",79,0)
 .. M ^XTMP("HMPX",TOKEN,DFN)=DATA
"RTN","HMPHTTP",80,0)
 D SEND(.NEW)
"RTN","HMPHTTP",81,0)
 I $$S^%ZTLOAD S ZTSTOP=1,ZTREQ="@" Q
"RTN","HMPHTTP",82,0)
 D HANG S ZTREQ="" ;re-queue
"RTN","HMPHTTP",83,0)
 Q
"RTN","HMPHTTP",84,0)
 ;
"RTN","HMPHTTP",85,0)
SEND(LIST) ; send each list ID to its URL
"RTN","HMPHTTP",86,0)
 N SYS,ID,DA,URL,X
"RTN","HMPHTTP",87,0)
 S SYS=$$SYS^HMPUTILS
"RTN","HMPHTTP",88,0)
 ; DIV=$P($$SITE^VASITE,U,3) ;station#
"RTN","HMPHTTP",89,0)
 S ID="" F  S ID=$O(LIST(ID)) Q:ID=""  D
"RTN","HMPHTTP",90,0)
 . S DA=+ID,URL=$G(^HMP(800000,DA,.1)) Q:URL=""
"RTN","HMPHTTP",91,0)
 . S URL=URL_"?vistaId="_SYS_"&id="_ID
"RTN","HMPHTTP",92,0)
 . S X=$$GETURL^XTHC10(URL,,"HMPX") ;I X>200 = ERROR
"RTN","HMPHTTP",93,0)
 Q
"RTN","HMPHTTP",94,0)
 ;
"RTN","HMPHTTP",95,0)
HANG ; -- wait #seconds
"RTN","HMPHTTP",96,0)
 N X S X=$$GET^XPAR("ALL","HMP TASK WAIT TIME") S:'X X=99
"RTN","HMPHTTP",97,0)
 H X
"RTN","HMPHTTP",98,0)
 Q
"RTN","HMPHTTP",99,0)
 ;
"RTN","HMPHTTP",100,0)
KILL ; -- kill/reset ^HMP(800000) for testing
"RTN","HMPHTTP",101,0)
 K ^HMP(800000)
"RTN","HMPHTTP",102,0)
 S ^HMP(800000,0)="HMP SUBSCRIPTION^800000^^"
"RTN","HMPHTTP",103,0)
 Q
"RTN","HMPMETA")
0^73^B127426606^B122279349
"RTN","HMPMETA",1,0)
HMPMETA ;SLC/PJH,ASMR/RRB - Utility to collect Domains, UID's and stamptimes for a patient;May 15, 2016 14:15
"RTN","HMPMETA",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPMETA",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPMETA",4,0)
 ;
"RTN","HMPMETA",5,0)
 Q
"RTN","HMPMETA",6,0)
 ; New routine for US6734
"RTN","HMPMETA",7,0)
 ;
"RTN","HMPMETA",8,0)
ADD(HMPDMNM,HMPUID,HMPSTMP) ; Build array for metastamp - called from HMPDJ0* routines
"RTN","HMPMETA",9,0)
 I ($G(HMPUID)="")!($G(HMPDMNM)="") Q
"RTN","HMPMETA",10,0)
 ;For quick orders the JDS domain is 'qo'
"RTN","HMPMETA",11,0)
 S:HMPDMNM="quick" HMPDMNM="qo"
"RTN","HMPMETA",12,0)
 S ^TMP("HMPMETA",$J,HMPDMNM,HMPUID)=HMPSTMP
"RTN","HMPMETA",13,0)
 ;unit tests use following nodes
"RTN","HMPMETA",14,0)
 S ^TMP("HMPMETA",$J,HMPDMNM)=$G(^TMP("HMPMETA",$J,HMPDMNM))+1
"RTN","HMPMETA",15,0)
 S ^TMP("HMPMETA",$J,"PATIENT")=$G(^TMP("HMPMETA",$J,"PATIENT"))+1
"RTN","HMPMETA",16,0)
 Q
"RTN","HMPMETA",17,0)
 ;
"RTN","HMPMETA",18,0)
DONE(HMPFDFN,HMPBATCH) ; Check if metastamp compile is complete
"RTN","HMPMETA",19,0)
 ;For patients this will always be true since all patient domains compiled by one task
"RTN","HMPMETA",20,0)
 Q:+$G(HMPFDFN) 1
"RTN","HMPMETA",21,0)
 ;For OPD requires to check that all domain compiles are completed
"RTN","HMPMETA",22,0)
 N HMPDOM,HMPCOMP
"RTN","HMPMETA",23,0)
 S HMPDOM="",HMPCOMP=1 F  S HMPDOM=$O(^XTMP(HMPBATCH,0,"MSTA",HMPDOM)) Q:HMPDOM=""  D  Q:'HMPCOMP
"RTN","HMPMETA",24,0)
 .S:$G(^XTMP(HMPBATCH,0,"MSTA",HMPDOM))=0 HMPCOMP=0
"RTN","HMPMETA",25,0)
 Q HMPCOMP
"RTN","HMPMETA",26,0)
 ;
"RTN","HMPMETA",27,0)
OPD(HMPFHMP) ;Check if OPD metastamp is ready to collect
"RTN","HMPMETA",28,0)
 Q $S($$DONE("OPD","HMPFX~"_HMPFHMP_"~OPD"):1,1:0)
"RTN","HMPMETA",29,0)
 ; 
"RTN","HMPMETA",30,0)
INIT(HMPBATCH,HMPFDFN,ARGS) ; Set metastamp status as in progress
"RTN","HMPMETA",31,0)
 N DOMAINS
"RTN","HMPMETA",32,0)
 ; set up domains to extract
"RTN","HMPMETA",33,0)
 D @($S(HMPFDFN="OPD":"OPDOMS",1:"PTDOMS")_"^HMPDJFSD(.DOMAINS)")
"RTN","HMPMETA",34,0)
 I $G(ARGS("domains"))'="" D
"RTN","HMPMETA",35,0)
 . S I=""
"RTN","HMPMETA",36,0)
 . F I=1:1 Q:'$D(DOMAINS(I))  D
"RTN","HMPMETA",37,0)
 .. I ARGS("domains")'[DOMAINS(I) K DOMAINS(I)
"RTN","HMPMETA",38,0)
 N HMPDOM,I
"RTN","HMPMETA",39,0)
 F I=1:1 S HMPDOM=$G(DOMAINS(I)) Q:HMPDOM=""  S ^XTMP(HMPBATCH,0,"MSTA",HMPDOM)=0
"RTN","HMPMETA",40,0)
 Q
"RTN","HMPMETA",41,0)
 ;
"RTN","HMPMETA",42,0)
UPD(HMPDOM) ; Update metastamp domain as complete
"RTN","HMPMETA",43,0)
 S ^XTMP(HMPBATCH,0,"MSTA",HMPDOM)=1
"RTN","HMPMETA",44,0)
 Q
"RTN","HMPMETA",45,0)
 ;
"RTN","HMPMETA",46,0)
MERGE1(HMPBATCH,HMPDOM) ; US11019 Merge a single domain
"RTN","HMPMETA",47,0)
 M ^XTMP(HMPBATCH,0,"META",HMPDOM)=^TMP("HMPMETA",$J,HMPDOM)
"RTN","HMPMETA",48,0)
 K ^TMP("HMPMETA",$J,HMPDOM)
"RTN","HMPMETA",49,0)
 Q
"RTN","HMPMETA",50,0)
 ;
"RTN","HMPMETA",51,0)
MERGE(HMPBATCH) ; Merge metastamp data into XTMP and mark domain complete in metastamp
"RTN","HMPMETA",52,0)
 ;Formatting of metastamp into JSON format by HMPMETA goes here when ready
"RTN","HMPMETA",53,0)
 N HMPDOM
"RTN","HMPMETA",54,0)
 S HMPDOM="PATIENT"
"RTN","HMPMETA",55,0)
 F  S HMPDOM=$O(^TMP("HMPMETA",$J,HMPDOM)) Q:HMPDOM=""  D
"RTN","HMPMETA",56,0)
 .M ^XTMP(HMPBATCH,0,"META",HMPDOM)=^TMP("HMPMETA",$J,HMPDOM)
"RTN","HMPMETA",57,0)
 K ^TMP("HMPMETA",$J)
"RTN","HMPMETA",58,0)
 Q
"RTN","HMPMETA",59,0)
 ;
"RTN","HMPMETA",60,0)
METAPT(A,HMPCDOM) ; MetaStamp for patient data (within its own syncStart chunk).;US11019 added second parameter
"RTN","HMPMETA",61,0)
 ; --Input parameter
"RTN","HMPMETA",62,0)
 ; A = "^^HMPFX~hmp-development-box~"<DFN> (e.g. ^^HMPFX~hmp-development-box~3)
"RTN","HMPMETA",63,0)
 ; HMPCDOM = Single domain US11019
"RTN","HMPMETA",64,0)
 ;
"RTN","HMPMETA",65,0)
 ; --Expects
"RTN","HMPMETA",66,0)
 ; DOMSIZE,OFFSET,HMPFCNT ;US11019 comment added not variables
"RTN","HMPMETA",67,0)
 ;
"RTN","HMPMETA",68,0)
 ; --Local variables
"RTN","HMPMETA",69,0)
 ; HMPA = "HMPFX~hmp-development-box~"<DFN>
"RTN","HMPMETA",70,0)
 ; HMPB = ZTASK# --> ^XTMP(HMPA,<ZTASK#>
"RTN","HMPMETA",71,0)
 ; HMPC = Domain (e.g. "allergy") --> ^XTMP(HMPA,HMPB,<Domain>
"RTN","HMPMETA",72,0)
 ; HMPD = Counter (sequential number) --> ^XTMP(HMPA,HMPB,HMPC,<Counter>
"RTN","HMPMETA",73,0)
 ; HMPN = Subscript --> ^XTMP(HMPA,HMPB,HMPC,HMPD,<Subscript>
"RTN","HMPMETA",74,0)
 ; HMPE = ^XTMP(HMPA,HMPB,HMPC,HMPD,HMPN)
"RTN","HMPMETA",75,0)
 ; HMPF = Domain id (e.g. the "C877:3:751" part of "urn:va:allergy:C877:3:751"
"RTN","HMPMETA",76,0)
 ; HMPID = pid --> <site-hash>;DFN (e.g. C877;3)
"RTN","HMPMETA",77,0)
 ; HMPZ1 = DFN
"RTN","HMPMETA",78,0)
 ; HMPP = $$PIDS^HMPDJFS(HMPZ1)  --> JSON construct containing pid, systemId, localId, icn
"RTN","HMPMETA",79,0)
 ; HMPQ = " (double quote literal)
"RTN","HMPMETA",80,0)
 ; HMPT = The "total" node from ^XTMP --> ^XTMP(HMPA,HMPB,HMPC,"total")
"RTN","HMPMETA",81,0)
 ; HMPX = JSON construct for the entire metaStamp
"RTN","HMPMETA",82,0)
 ; HMPW = Event timeStamp
"RTN","HMPMETA",83,0)
 ; HMPY = $$EN^HMPSTMP("NOW")
"RTN","HMPMETA",84,0)
 ; HMPZ = Counter for breaking up the large nodes into sub-nodes in ^TMP
"RTN","HMPMETA",85,0)
 ; 
"RTN","HMPMETA",86,0)
 I '$D(U) S U="^"
"RTN","HMPMETA",87,0)
 N HMPA,HMPB,HMPC,HMPC1,HMPD,HMPE,HMPF,HMPID,HMPM,HMPN
"RTN","HMPMETA",88,0)
 N HMPP,HMPQ,HMPT,HMPW,HMPX,HMPY,HMPZ,HMPZ1
"RTN","HMPMETA",89,0)
 S HMPA=$P(A,U,3),HMPB=$O(^XTMP(HMPA,0)),HMPZ1=$P(HMPA,"~",3)
"RTN","HMPMETA",90,0)
 S HMPE="",HMPQ="""",HMPZ=0 ;US11019
"RTN","HMPMETA",91,0)
 S HMPC=$G(HMPCDOM) ;US11019
"RTN","HMPMETA",92,0)
 S HMPP=$$PIDS^HMPDJFS(HMPZ1)
"RTN","HMPMETA",93,0)
 S HMPY=$$EN^HMPSTMP("NOW")
"RTN","HMPMETA",94,0)
 S HMPX=",""metaStamp"":"_"{""icn"":"""_$$GETICN^MPIF001(HMPZ1)_""""_","
"RTN","HMPMETA",95,0)
 S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_",""sourceMetaStamp"":"_"{"
"RTN","HMPMETA",96,0)
 S HMPID=$TR($P($P(HMPP,"pid",2),","),""":")
"RTN","HMPMETA",97,0)
 S HMPX=HMPX_""""_$P(HMPID,";")_""""_":{"
"RTN","HMPMETA",98,0)
 S HMPX=HMPX_"""pid"":"""_HMPID_""""_","
"RTN","HMPMETA",99,0)
 S HMPX=HMPX_"""localId"":"""_$P(HMPID,";",2)_""""_","
"RTN","HMPMETA",100,0)
 S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_","
"RTN","HMPMETA",101,0)
 S HMPX=HMPX_"""domainMetaStamp"""_":"_"{"
"RTN","HMPMETA",102,0)
 ;Scan Domains
"RTN","HMPMETA",103,0)
 D:HMPC'=""  I HMPC="" F  S HMPC=$O(^XTMP(HMPA,0,"META",HMPC)) Q:HMPC']""  D  ;US11019 allow process by single domain
"RTN","HMPMETA",104,0)
 .S HMPX=HMPX_""""_HMPC_""""_":{"
"RTN","HMPMETA",105,0)
 .S HMPX=HMPX_"""domain"":"""_HMPC_""""_","
"RTN","HMPMETA",106,0)
 .S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_","
"RTN","HMPMETA",107,0)
 .S HMPD=0
"RTN","HMPMETA",108,0)
 .S HMPX=HMPX_"""eventMetaStamp"""_":"_"{" ; Patient data
"RTN","HMPMETA",109,0)
 .N HMPU,HMPS S HMPU=""
"RTN","HMPMETA",110,0)
 .I $O(^XTMP(HMPA,0,"META",HMPC,HMPU))="" S HMPX=HMPX_"}" ;US11019 - cater for zero entries
"RTN","HMPMETA",111,0)
 .F  S HMPU=$O(^XTMP(HMPA,0,"META",HMPC,HMPU)) Q:HMPU']""  D
"RTN","HMPMETA",112,0)
 ..N VAR0,VAR1
"RTN","HMPMETA",113,0)
 ..S HMPS=$G(^XTMP(HMPA,0,"META",HMPC,HMPU)),VAR0=$P(HMPU,":",3),VAR1=$P(HMPU,":",4,99)
"RTN","HMPMETA",114,0)
 ..I $L(HMPX)>20000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX,HMPX=""
"RTN","HMPMETA",115,0)
 ..S HMPX=HMPX_"""urn:va:"_VAR0_":"_VAR1_""""_":{"
"RTN","HMPMETA",116,0)
 ..S HMPX=HMPX_"""stampTime"":"""_HMPS_""""_"}"
"RTN","HMPMETA",117,0)
 ..S HMPX=HMPX_$S($O(^XTMP(HMPA,0,"META",HMPC,HMPU))="":"}",1:",")
"RTN","HMPMETA",118,0)
 .S HMPX=HMPX_"},"
"RTN","HMPMETA",119,0)
 .I $L(HMPX)>20000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX,HMPX=""
"RTN","HMPMETA",120,0)
 I HMPZ!($L(HMPX)>0) D  ;DE3759 avoid multiple edge case
"RTN","HMPMETA",121,0)
 .I $L(HMPX)=0 S HMPX=^TMP("HMPF",$J,HMPFCNT,.3,HMPZ),^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=$E(HMPX,1,$L(HMPX)-1),HMPX="" ;DE3759
"RTN","HMPMETA",122,0)
 .S HMPZ=HMPZ+1
"RTN","HMPMETA",123,0)
 .S HMPX=$E(HMPX,1,$L(HMPX)-1)_"}}}}" D
"RTN","HMPMETA",124,0)
 ..I $E(HMPX,$L(HMPX))="{" S HMPX=HMPX_"""seq"":"_OFFSET_",""total"":"_DOMSIZE
"RTN","HMPMETA",125,0)
 ..E  S HMPX=HMPX_",""seq"":"_OFFSET_",""total"":"_DOMSIZE
"RTN","HMPMETA",126,0)
 .S HMPX=HMPX_",""object"":"
"RTN","HMPMETA",127,0)
 .S ^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX
"RTN","HMPMETA",128,0)
 Q
"RTN","HMPMETA",129,0)
 ;
"RTN","HMPMETA",130,0)
METAOP(A) ; MetaStamp for operational data (within its own syncStart chunk)
"RTN","HMPMETA",131,0)
 ; A = HMPFX~hmp-development-box~OPD
"RTN","HMPMETA",132,0)
 ; --Local variables
"RTN","HMPMETA",133,0)
 ; HMPA = "HMPFX~hmp-development-box~"<DFN>
"RTN","HMPMETA",134,0)
 ; HMPB = ZTASK# --> ^XTMP(HMPA,<ZTASK#>
"RTN","HMPMETA",135,0)
 ; HMPC = Domain (e.g. "allergy") --> ^XTMP(HMPA,HMPB,<Domain>
"RTN","HMPMETA",136,0)
 ; HMPD = Counter (sequential number) --> ^XTMP(HMPA,HMPB,HMPC,<Counter>
"RTN","HMPMETA",137,0)
 ; HMPN = Subscript --> ^XTMP(HMPA,HMPB,HMPC,HMPD,<Subscript>
"RTN","HMPMETA",138,0)
 ; HMPE = ^XTMP(HMPA,HMPB,HMPC,HMPD,HMPN)
"RTN","HMPMETA",139,0)
 ; HMPF = Domain id (e.g. the "C877:3:751" part of "urn:va:allergy:C877:3:751"
"RTN","HMPMETA",140,0)
 ; HMPID = pid --> <site-hash>;DFN (e.g. C877;3)
"RTN","HMPMETA",141,0)
 ; HMPZ1 = DFN
"RTN","HMPMETA",142,0)
 ; HMPP = $$PIDS^HMPDJFS(HMPZ1)  --> JSON construct containing pid, systemId, localId, icn
"RTN","HMPMETA",143,0)
 ; HMPQ = " (double quote literal)
"RTN","HMPMETA",144,0)
 ; HMPT = The "total" node from ^XTMP --> ^XTMP(HMPA,HMPB,HMPC,"total")
"RTN","HMPMETA",145,0)
 ; HMPX = JSON construct for the entire metaStamp
"RTN","HMPMETA",146,0)
 ; HMPW = Event timeStamp
"RTN","HMPMETA",147,0)
 ; HMPY = $$EN^HMPSTMP("NOW")
"RTN","HMPMETA",148,0)
 ; HMPZ = Counter for breaking up the large nodes into sub-nodes in ^TMP
"RTN","HMPMETA",149,0)
 ; 
"RTN","HMPMETA",150,0)
 ;
"RTN","HMPMETA",151,0)
 I '$D(U) S U="^"
"RTN","HMPMETA",152,0)
 N HMPA,HMPJ,HMPQ,HMPSEP,HMPZ,HMPDAT,HMPDAT1,HMPDOM,HMPDOM1,HMPEVT,HMPX,HMPTOT,HMPTSK,HMPMOR,HMPLAS,HMPMOR,HMPLAS
"RTN","HMPMETA",153,0)
 S HMPA=$P(A,U,3),HMPQ="""",HMPZ=0,HMPSEP=","""
"RTN","HMPMETA",154,0)
 S HMPCNT=$G(HMPCNT)+1,HMPJ=$P(HMPA,"~",1,2)_"~OPD"
"RTN","HMPMETA",155,0)
 S HMPSEP=HMPQ
"RTN","HMPMETA",156,0)
 S HMPTSK=$O(^XTMP(A,0)),HMPY=$$EN^HMPSTMP("NOW"),HMPID=$$SYS^HMPUTILS
"RTN","HMPMETA",157,0)
 S HMPX="{""collection"":"""_"OPDsyncStart"_""""_","
"RTN","HMPMETA",158,0)
 S HMPX=HMPX_"""metaStamp"":"_"{"
"RTN","HMPMETA",159,0)
 S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_",""sourceMetaStamp"":"_"{"
"RTN","HMPMETA",160,0)
 S HMPX=HMPX_""""_$P(HMPID,";")_""""_":{"
"RTN","HMPMETA",161,0)
 S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_","
"RTN","HMPMETA",162,0)
 S HMPX=HMPX_"""domainMetaStamp"""_":"_"{"
"RTN","HMPMETA",163,0)
 ;Scan Domains
"RTN","HMPMETA",164,0)
 S HMPC=""
"RTN","HMPMETA",165,0)
 F  S HMPC=$O(^XTMP(HMPA,0,"META",HMPC)) Q:HMPC']""  D
"RTN","HMPMETA",166,0)
 .S HMPX=HMPX_""""_HMPC_""""_":{"
"RTN","HMPMETA",167,0)
 .S HMPX=HMPX_"""domain"":"""_HMPC_""""_","
"RTN","HMPMETA",168,0)
 .S HMPX=HMPX_"""stampTime"":"""_HMPY_""""_","
"RTN","HMPMETA",169,0)
 .S HMPD=0
"RTN","HMPMETA",170,0)
 .S HMPX=HMPX_"""itemMetaStamp"""_":"_"{" ; Patient data
"RTN","HMPMETA",171,0)
 .N HMPU,HMPS S HMPU=""
"RTN","HMPMETA",172,0)
 .F  S HMPU=$O(^XTMP(HMPA,0,"META",HMPC,HMPU)) Q:HMPU']""  D
"RTN","HMPMETA",173,0)
 ..N VAR0,VAR1
"RTN","HMPMETA",174,0)
 ..S HMPS=$G(^XTMP(HMPA,0,"META",HMPC,HMPU)),VAR0=$P(HMPU,":",3),VAR1=$P(HMPU,":",4,99)
"RTN","HMPMETA",175,0)
 ..I $L(HMPX)>20000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX,HMPX=""
"RTN","HMPMETA",176,0)
 ..S HMPX=HMPX_"""urn:va:"_VAR0_":"_VAR1_""""_":{"
"RTN","HMPMETA",177,0)
 ..S HMPX=HMPX_"""stampTime"":"""_HMPS_""""_"}"
"RTN","HMPMETA",178,0)
 ..S HMPX=HMPX_$S($O(^XTMP(HMPA,0,"META",HMPC,HMPU))="":"}",1:",")
"RTN","HMPMETA",179,0)
 .S HMPX=HMPX_"},"
"RTN","HMPMETA",180,0)
 .I $L(HMPX)>20000 S HMPZ=HMPZ+1,^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX,HMPX=""
"RTN","HMPMETA",181,0)
 I HMPZ!($L(HMPX)>0) D  ;DE3759 avoid multiple edge case
"RTN","HMPMETA",182,0)
 .I $L(HMPX)=0 S HMPX=^TMP("HMPF",$J,HMPFCNT,.3,HMPZ),^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=$E(HMPX,1,$L(HMPX)-1),HMPX="" ;DE3759
"RTN","HMPMETA",183,0)
 .S HMPZ=HMPZ+1
"RTN","HMPMETA",184,0)
 .S HMPX=$E(HMPX,1,$L(HMPX)-1)_"}}}}},{"
"RTN","HMPMETA",185,0)
 .S ^TMP("HMPF",$J,HMPFCNT,.3,HMPZ)=HMPX
"RTN","HMPMETA",186,0)
 Q
"RTN","HMPMETA",187,0)
 ;
"RTN","HMPMETA",188,0)
STATUS(STOP,HMPFHMP) ; Set HMP GLOBAL USAGE MONITOR status
"RTN","HMPMETA",189,0)
 Q:$G(STOP)=""  Q:$G(HMPFHMP)=""
"RTN","HMPMETA",190,0)
 N HMPFLG,HMPSTMP,HMPSRV
"RTN","HMPMETA",191,0)
 S HMPSRV=$O(^HMP(800000,"B",HMPFHMP,"")) Q:'HMPSRV
"RTN","HMPMETA",192,0)
 S HMPFLG=$P($G(^HMP(800000,HMPSRV,0)),U,5),HMPSTMP=$P($G(^HMP(800000,HMPSRV,0)),U,6)
"RTN","HMPMETA",193,0)
 ;If stopped and already flagged as stopped do nothing
"RTN","HMPMETA",194,0)
 I STOP,HMPFLG Q
"RTN","HMPMETA",195,0)
 ;If stopped but not flagged as stopped set flag and timestamp
"RTN","HMPMETA",196,0)
 I STOP,'HMPFLG D SET(STOP,HMPSRV) Q
"RTN","HMPMETA",197,0)
 ;If running and flagged as stopped flag as running
"RTN","HMPMETA",198,0)
 I 'STOP,HMPFLG D SET(STOP,HMPSRV) Q
"RTN","HMPMETA",199,0)
 ;No action needed if running and not flagged as stop
"RTN","HMPMETA",200,0)
 Q
"RTN","HMPMETA",201,0)
 ;
"RTN","HMPMETA",202,0)
SET(STOP,HMPSRV) ; Flag set/reset, Stamptime set
"RTN","HMPMETA",203,0)
 Q:'$G(HMPSRV)
"RTN","HMPMETA",204,0)
 L +^HMP(800000,HMPSRV,0):5 E  Q
"RTN","HMPMETA",205,0)
 S $P(^HMP(800000,HMPSRV,0),U,5,6)=STOP_U_$$NOW^XLFDT
"RTN","HMPMETA",206,0)
 L -^HMP(800000,HMPSRV,0)
"RTN","HMPMETA",207,0)
 Q
"RTN","HMPMETA",208,0)
 ;
"RTN","HMPMETA",209,0)
CHECK(HMPFHMP) ; Check status and send HMP GLOBAL USAGE MONITOR message if appropriate
"RTN","HMPMETA",210,0)
 ; Input HMPFHMP - server name
"RTN","HMPMETA",211,0)
 Q:$G(HMPFHMP)=""
"RTN","HMPMETA",212,0)
 N HMPFLG,HMPSTMP,HMPDIFF,HMPSRV
"RTN","HMPMETA",213,0)
 S HMPSRV=$O(^HMP(800000,"B",HMPFHMP,"")) Q:'HMPSRV
"RTN","HMPMETA",214,0)
 S HMPFLG=$P($G(^HMP(800000,HMPSRV,0)),U,5)
"RTN","HMPMETA",215,0)
 ;No action required if status is not set
"RTN","HMPMETA",216,0)
 I HMPFLG="" Q
"RTN","HMPMETA",217,0)
 ;Get stamptime
"RTN","HMPMETA",218,0)
 S HMPSTMP=$P($G(^HMP(800000,HMPSRV,0)),U,6) Q:HMPSTMP=""
"RTN","HMPMETA",219,0)
 ;If stamptime < five minutes ago no action
"RTN","HMPMETA",220,0)
 I $$FMDIFF^XLFDT($$NOW^XLFDT,HMPSTMP,2)<300 Q
"RTN","HMPMETA",221,0)
 ;Otherwise send message
"RTN","HMPMETA",222,0)
 D:HMPFLG MESNOK
"RTN","HMPMETA",223,0)
 D:'HMPFLG MESOK
"RTN","HMPMETA",224,0)
 ;Clear DISK USAGE STATUS and DISK USAGE STATUS TIME in subscription file
"RTN","HMPMETA",225,0)
 L +^HMP(800000,HMPSRV,0):5 E  Q
"RTN","HMPMETA",226,0)
 S $P(^HMP(800000,HMPSRV,0),U,5,6)=""
"RTN","HMPMETA",227,0)
 L -^HMP(800000,HMPSRV,0):5
"RTN","HMPMETA",228,0)
 Q
"RTN","HMPMETA",229,0)
 ;
"RTN","HMPMETA",230,0)
MESNOK ; Mail Message if space limit on XTMP is breached
"RTN","HMPMETA",231,0)
 ;
"RTN","HMPMETA",232,0)
 N MAX,RCT,SIZE,XMSUBJ,XMBODY,XMDUZ,XMTO,XMZ
"RTN","HMPMETA",233,0)
 ;Determine estimated usage of XTMP
"RTN","HMPMETA",234,0)
 S SIZE=$J($P($$GETSIZE^HMPUTILS(),",")/1000000,2,2)
"RTN","HMPMETA",235,0)
 S MAX=$J($$GETMAX^HMPDJFSP()/1000000,2,2)
"RTN","HMPMETA",236,0)
 ;Construct Mail Message
"RTN","HMPMETA",237,0)
 S RCT(1)="Alert: eHMP usage of global ^XTMP has exceeded "_MAX_" Mb for more than 5 minutes."
"RTN","HMPMETA",238,0)
 S RCT(2)=" "
"RTN","HMPMETA",239,0)
 S RCT(3)="       eHMP subscribing is paused."
"RTN","HMPMETA",240,0)
 S RCT(4)=" "
"RTN","HMPMETA",241,0)
 S RCT(5)="       eHMP usage of global ^XTMP is "_SIZE_" Mb."
"RTN","HMPMETA",242,0)
 S RCT(6)=" "
"RTN","HMPMETA",243,0)
 S RCT(7)="       Disk space check at "_$$FMTE^XLFDT($$NOW^XLFDT)
"RTN","HMPMETA",244,0)
 S RCT(8)=" " ;Send warning to IRM VistA mail group
"RTN","HMPMETA",245,0)
 S XMSUBJ="HMP GLOBAL USAGE MONITOR",XMBODY="RCT",XMDUZ="",XMTO("HMP IRM GROUP")=""
"RTN","HMPMETA",246,0)
 S XMDUZ=.5,XMDUZ(0)="@"
"RTN","HMPMETA",247,0)
 D SENDMSG^XMXAPI(XMDUZ,XMSUBJ,XMBODY,.XMTO,,.XMZ)
"RTN","HMPMETA",248,0)
 Q
"RTN","HMPMETA",249,0)
 ;
"RTN","HMPMETA",250,0)
MESOK ; Mail Message if space limit on XTMP returns to normal
"RTN","HMPMETA",251,0)
 ;
"RTN","HMPMETA",252,0)
 N MAX,RCT,XMSUBJ,XMBODY,XMDUZ,XMTO,XMZ
"RTN","HMPMETA",253,0)
 S MAX=$J($$GETMAX^HMPDJFSP()/1000000,2,2)
"RTN","HMPMETA",254,0)
 ;Construct Mail Message
"RTN","HMPMETA",255,0)
 S RCT(1)="Alert: eHMP usage of global ^XTMP has been below "_MAX_" Mb. for more than 5 minutes."
"RTN","HMPMETA",256,0)
 S RCT(2)=" "
"RTN","HMPMETA",257,0)
 S RCT(3)="       eHMP subscribing is restarted."
"RTN","HMPMETA",258,0)
 S RCT(4)=" "
"RTN","HMPMETA",259,0)
 S RCT(5)="       Disk space check at "_$$FMTE^XLFDT($$NOW^XLFDT)
"RTN","HMPMETA",260,0)
 S RCT(6)=" "
"RTN","HMPMETA",261,0)
 ;Send message to IRM VistA mail group
"RTN","HMPMETA",262,0)
 S XMSUBJ="HMP GLOBAL USAGE MONITOR",XMBODY="RCT",XMDUZ="",XMTO("IRM GROUP")=""
"RTN","HMPMETA",263,0)
 S XMDUZ=.5,XMDUZ(0)="@"
"RTN","HMPMETA",264,0)
 D SENDMSG^XMXAPI(XMDUZ,XMSUBJ,XMBODY,.XMTO,,.XMZ)
"RTN","HMPMETA",265,0)
 Q
"RTN","HMPMETA",266,0)
 ;
"RTN","HMPMETA",267,0)
 ;Following tags used by VPRJTT0 unit test routines
"RTN","HMPMETA",268,0)
 ;-------------------------------------------------
"RTN","HMPMETA",269,0)
EN(HMPFDFN) ;Build XTMP for patient
"RTN","HMPMETA",270,0)
 I $G(HMPFDFN)="" D MES^XPDUTL("No patient specified, call as D EN^HMPMETA(DFN)") Q
"RTN","HMPMETA",271,0)
 N ARGS,DOMAINS,HMPSRV,NEWSUB,HMPFERR,HMPBATCH,HMPSTMP,SEQNODE,ZTSK,ZTQUEUED
"RTN","HMPMETA",272,0)
 ;Select domains to compile
"RTN","HMPMETA",273,0)
 ;OPD domains
"RTN","HMPMETA",274,0)
 ;asu-class#asu-rule#category#charttab#displaygroup#doc-def#labgroup#labpanel#location#orderable#page#pt-select#
"RTN","HMPMETA",275,0)
 ;personphoto#pointofcare#quick#roster#route#schedule#team#teamposition#user#usertabprefs#viewdefdef#
"RTN","HMPMETA",276,0)
 ;viewdefdefcoldefconfigtemplate#immunization-list#allergy-list#signssymptoms-list#vitaltypes-list#
"RTN","HMPMETA",277,0)
 ;vitalqualifier-list#vitalcategory-list
"RTN","HMPMETA",278,0)
 ;Patient domains
"RTN","HMPMETA",279,0)
 ;allergy#vital#problem#order#treatment#patient#consult#procedure#obs#visit#appointment#ptf#med#lab#
"RTN","HMPMETA",280,0)
 ;image#surgery#document#mh#
"RTN","HMPMETA",281,0)
 ;Patient PCE domains
"RTN","HMPMETA",282,0)
 ;auxiliary#diagnosis#factor#immunization#task#vital#exam#cpt#education#pov#skin
"RTN","HMPMETA",283,0)
 ;S ARGS("domains")="allergy#asu-class"
"RTN","HMPMETA",284,0)
 ;
"RTN","HMPMETA",285,0)
 ;Modify SEQNODE to extract required patient
"RTN","HMPMETA",286,0)
 S SEQNODE=HMPFDFN_"^syncStart^HMPFX~hmp-development-box~"_HMPFDFN_"^^64671"
"RTN","HMPMETA",287,0)
 S HMPBATCH=$P(SEQNODE,U,3),HMPSRV=$P(HMPBATCH,"~",2)
"RTN","HMPMETA",288,0)
 S HMPSRV("ien")=$O(^HMP(800000,"B",HMPSRV,0)) Q:'HMPSRV("ien")
"RTN","HMPMETA",289,0)
 ;Unsubscribe patient and clear cache
"RTN","HMPMETA",290,0)
 D UNSUB(HMPFDFN,HMPSRV("ien")) K ^XTMP(HMPBATCH)
"RTN","HMPMETA",291,0)
 ;Clear metastamp array
"RTN","HMPMETA",292,0)
 K ^TMP("HMPMETA",$J)
"RTN","HMPMETA",293,0)
 ; set up domains to extract
"RTN","HMPMETA",294,0)
 D @($S(HMPFDFN="OPD":"OPDOMS",1:"PTDOMS")_"^HMPDJFSD(.DOMAINS)")
"RTN","HMPMETA",295,0)
 ;Clear unwanted domains
"RTN","HMPMETA",296,0)
 I $G(ARGS("domains"))'="" N I F I=1:1 Q:'$D(DOMAINS(I))  K:ARGS("domains")'[DOMAINS(I) DOMAINS(I)
"RTN","HMPMETA",297,0)
 ;
"RTN","HMPMETA",298,0)
 ; see if this is new subscription and task extract if new
"RTN","HMPMETA",299,0)
 D SETPAT^HMPDJFSP(HMPFDFN,HMPSRV,.NEWSUB) Q:$G(HMPFERR) ""
"RTN","HMPMETA",300,0)
 ;For operational data set stamptime as time subscription placed
"RTN","HMPMETA",301,0)
 S:HMPFDFN="OPD" HMPSTMP=$$JSONDT^HMPUTILS($$NOW^XLFDT)
"RTN","HMPMETA",302,0)
 I NEWSUB D  Q:$G(HMPFERR) ""
"RTN","HMPMETA",303,0)
 . I HMPFDFN="OPD" D  ; queue each operational domain
"RTN","HMPMETA",304,0)
 . . S I="" F  S I=$O(DOMAINS(I)) Q:'I  D
"RTN","HMPMETA",305,0)
 . . . N HMPFDOM
"RTN","HMPMETA",306,0)
 . . . S HMPFDOM(1)=DOMAINS(I)
"RTN","HMPMETA",307,0)
 . . . D QUINIT(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPMETA",308,0)
 . E  D  ; queue all domains for patient
"RTN","HMPMETA",309,0)
 . . N HMPFDOM
"RTN","HMPMETA",310,0)
 . . M HMPFDOM=DOMAINS
"RTN","HMPMETA",311,0)
 . . ; if patients extracts are held (version mismatch), put DFN on wait list
"RTN","HMPMETA",312,0)
 . . I $G(^XTMP("HMPFS~"_HMPSRV("ien"),"waiting")) S ^XTMP("HMPFS~"_HMPSRV("ien"),"waiting",HMPFDFN)="" QUIT
"RTN","HMPMETA",313,0)
 . . ; otherwise queue patient
"RTN","HMPMETA",314,0)
 . . D QUINIT(HMPBATCH,HMPFDFN,.HMPFDOM)
"RTN","HMPMETA",315,0)
 Q
"RTN","HMPMETA",316,0)
 ;
"RTN","HMPMETA",317,0)
QUINIT(HMPBATCH,HMPFDFN,HMPFDOM) ; Queue the initial extracts for a patient
"RTN","HMPMETA",318,0)
 ; HMPBATCH="HMPFX~hmpsrvid~dfn"  example: HMPFX~hmpXYZ~229
"RTN","HMPMETA",319,0)
 ; HMPFDOM(n)="domainName"
"RTN","HMPMETA",320,0)
 ; 
"RTN","HMPMETA",321,0)
 ; ^XTMP("HMPFX~hmpsrvid~dfn",0)=expires^created^HMP Patient Extract
"RTN","HMPMETA",322,0)
 ;                           ,0,"status",domain)=0:waiting;1:ready
"RTN","HMPMETA",323,0)
 ;                           ,0,"task",taskIen)=""
"RTN","HMPMETA",324,0)
 ;                           ,taskIen,domain,... (extract data)
"RTN","HMPMETA",325,0)
 ;
"RTN","HMPMETA",326,0)
 ; only done once when beginning the batch, no matter how many tasked jobs
"RTN","HMPMETA",327,0)
 L +^XTMP(HMPBATCH):5 E  D SETERR^HMPDJFS("Cannot lock batch:"_HMPBATCH) QUIT
"RTN","HMPMETA",328,0)
 I '$D(^XTMP(HMPBATCH)) D
"RTN","HMPMETA",329,0)
 . D NEWXTMP^HMPDJFS(HMPBATCH,2,"HMP Patient Extract")
"RTN","HMPMETA",330,0)
 . I $G(ARGS("jobId"))]"" S ^XTMP(HMPBATCH,"JOBID")=ARGS("jobId")  ;US3907
"RTN","HMPMETA",331,0)
 . I $G(ARGS("rootJobId"))]"" S ^XTMP(HMPBATCH,"ROOTJOBID")=ARGS("rootJobId")  ;US3907
"RTN","HMPMETA",332,0)
 . S ^XTMP(HMPBATCH,0,"time")=$H
"RTN","HMPMETA",333,0)
 . D SETMARK^HMPDJFSP("Start",HMPFDFN,HMPBATCH) ; sends full demographics
"RTN","HMPMETA",334,0)
 L -^XTMP(HMPBATCH)
"RTN","HMPMETA",335,0)
 ;
"RTN","HMPMETA",336,0)
 ; set up the domains to be done by this task
"RTN","HMPMETA",337,0)
 N I S I=0 F  S I=$O(HMPFDOM(I)) Q:'I  D SETDOM^HMPDJFSP("status",HMPFDOM(I),0)
"RTN","HMPMETA",338,0)
 ;
"RTN","HMPMETA",339,0)
 ;Call compile in foreground
"RTN","HMPMETA",340,0)
 S ZTSK=$J,^XTMP(HMPBATCH,0,"task",ZTSK)=$H,ZTQUEUED="1" D DQINIT^HMPDJFSP U 0
"RTN","HMPMETA",341,0)
 Q
"RTN","HMPMETA",342,0)
 ;
"RTN","HMPMETA",343,0)
UNSUB(DFN,SRV) ;Unsubscribe
"RTN","HMPMETA",344,0)
 ;Operational Data subscription
"RTN","HMPMETA",345,0)
 I DFN="OPD" D UPDOPD^HMPDJFSP(SRV,"@") Q
"RTN","HMPMETA",346,0)
 ;Patient subscription
"RTN","HMPMETA",347,0)
 N DA,DIK
"RTN","HMPMETA",348,0)
 S DA=DFN,DA(1)=SRV
"RTN","HMPMETA",349,0)
 S DIK="^HMP(800000,"_DA(1)_",1,"
"RTN","HMPMETA",350,0)
 D ^DIK
"RTN","HMPMETA",351,0)
 Q
"RTN","HMPPARAM")
0^75^B16345240^B16541840
"RTN","HMPPARAM",1,0)
HMPPARAM ;SLC/AGP,ASMR/RRB,CK - Parameter routine;May 15, 2016 14:15
"RTN","HMPPARAM",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPPARAM",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPPARAM",4,0)
 ;
"RTN","HMPPARAM",5,0)
 ; DE2818 - SQA findings. Newed HMPAR in GETPARAM +1.  RRB - 10/27/2015
"RTN","HMPPARAM",6,0)
 ; External References          DBIA#
"RTN","HMPPARAM",7,0)
 ; -------------------          -----
"RTN","HMPPARAM",8,0)
 ; ^XTV(8989.51                  2992
"RTN","HMPPARAM",9,0)
 ;
"RTN","HMPPARAM",10,0)
 Q
"RTN","HMPPARAM",11,0)
 ;
"RTN","HMPPARAM",12,0)
BLDENT(UID,ENTITY) ;
"RTN","HMPPARAM",13,0)
 ;urn:va:param:F484:1120:HMP USER PREF
"RTN","HMPPARAM",14,0)
 ;urn:va:param:F484:1120:HMP ROSTER PREF:13
"RTN","HMPPARAM",15,0)
 ;urn:va:param:F484:SYS:HMP USER PREF
"RTN","HMPPARAM",16,0)
 S ENTITY("uid")=UID
"RTN","HMPPARAM",17,0)
 I +$P(UID,":",5)>0 D  Q
"RTN","HMPPARAM",18,0)
 .S ENTITY("entity")="USR"
"RTN","HMPPARAM",19,0)
 .S ENTITY("entityId")=$P(UID,":",5)
"RTN","HMPPARAM",20,0)
 S ENTITY("entity")="SYS"
"RTN","HMPPARAM",21,0)
 Q
"RTN","HMPPARAM",22,0)
 ;
"RTN","HMPPARAM",23,0)
BUILDUID(VALUES,TYPE,ID) ;
"RTN","HMPPARAM",24,0)
 N DOMAIN
"RTN","HMPPARAM",25,0)
 S DOMAIN=$$SYS^HMPUTILS
"RTN","HMPPARAM",26,0)
 S VALUES("uid")="urn:va:"_TYPE_":"_DOMAIN_":"_ID
"RTN","HMPPARAM",27,0)
 Q
"RTN","HMPPARAM",28,0)
 ;
"RTN","HMPPARAM",29,0)
DELPARAM(RESULT,UID) ;
"RTN","HMPPARAM",30,0)
 N ARRAY,ENT,ENTITY,ENTVALUE,ERR,STR,HMPERR
"RTN","HMPPARAM",31,0)
 D BLDENT(UID,.ARRAY)
"RTN","HMPPARAM",32,0)
 ;delete old parameter
"RTN","HMPPARAM",33,0)
 S ENTITY=ARRAY("entity")
"RTN","HMPPARAM",34,0)
 S ENTVALUE=ARRAY("entityId")
"RTN","HMPPARAM",35,0)
 S ENT=$S($G(ENTVALUE)>0:ENTITY_".`"_ENTVALUE,1:ENTITY)
"RTN","HMPPARAM",36,0)
 I $G(ARRAY("uid"))="" Q
"RTN","HMPPARAM",37,0)
 I $G(ENT)="" Q
"RTN","HMPPARAM",38,0)
 D DEL^XPAR(ENT,"HMP PARAMETERS",ARRAY("uid"),.HMPERR)
"RTN","HMPPARAM",39,0)
 Q
"RTN","HMPPARAM",40,0)
 ;
"RTN","HMPPARAM",41,0)
GETALPAR(JSONRES,ENTITY,ENTVALUE,RETVALUE) ;
"RTN","HMPPARAM",42,0)
 N CNT,DECODE,ENT,GETVAL,INST,PARAM,RESULT,HMPERR,HMPLIST
"RTN","HMPPARAM",43,0)
 S ENT=$S($G(ENTVALUE)'="":ENTITY_".`"_ENTVALUE,1:ENTITY)
"RTN","HMPPARAM",44,0)
 D GETLST^XPAR(.HMPLIST,ENT,"HMP PARAMETERS","I")
"RTN","HMPPARAM",45,0)
 I HMPLIST=0 Q
"RTN","HMPPARAM",46,0)
 S GETVAL=$S(RETVALUE="true":1,1:0)
"RTN","HMPPARAM",47,0)
 I GETVAL=0 D   Q
"RTN","HMPPARAM",48,0)
 .S CNT=0,INST="" F  S INST=$O(HMPLIST(INST)) Q:INST=""  S JSONRES(CNT)=INST,CNT=CNT+1
"RTN","HMPPARAM",49,0)
 S CNT=0,INST="" F  S INST=$O(HMPLIST(INST)) Q:INST=""  D
"RTN","HMPPARAM",50,0)
 .S CNT=CNT+1
"RTN","HMPPARAM",51,0)
 .S RESULT("params",CNT,"uid")=INST
"RTN","HMPPARAM",52,0)
 .D GETPARAM(.PARAM,"HMP PARAMETERS",ENTITY,ENTVALUE,INST)
"RTN","HMPPARAM",53,0)
 .I '$D(PARAM) Q
"RTN","HMPPARAM",54,0)
 .M RESULT("params",CNT,"value",":")=PARAM
"RTN","HMPPARAM",55,0)
 .K PARAM
"RTN","HMPPARAM",56,0)
 I '$D(RESULT) Q ""
"RTN","HMPPARAM",57,0)
 S RESULT("success")="true"
"RTN","HMPPARAM",58,0)
 D ENCODE^HMPJSON("RESULT","JSONRES","HMPERR")
"RTN","HMPPARAM",59,0)
 I $D(HMPERR) K JSONRES S TXT(1)="Problem encoding results to json format." D SETERROR(.RESULT,.HMPERR,.TXT,.JSONRES) Q
"RTN","HMPPARAM",60,0)
 Q
"RTN","HMPPARAM",61,0)
 ;
"RTN","HMPPARAM",62,0)
GETPARAM(RESULT,NAME,ENTITY,ENTVALUE,INST) ; Get value for a param
"RTN","HMPPARAM",63,0)
 N CNT,ENT,FORMAT,IEN,HMPAR,HMPPAR,HMPERR
"RTN","HMPPARAM",64,0)
 ;S IEN=$O(^XTV(8989.51,"B",NAME,"")) Q:IEN'>0
"RTN","HMPPARAM",65,0)
 S FORMAT="I"
"RTN","HMPPARAM",66,0)
 ;D BLDLST^XPAREDIT(.HMPPAR,IEN
"RTN","HMPPARAM",67,0)
 S ENT=$S($G(ENTVALUE)'="":ENTITY_".`"_ENTVALUE,1:ENTITY)
"RTN","HMPPARAM",68,0)
 D GETWP^XPAR(.HMPAR,ENT,NAME,INST,.HMPERR)
"RTN","HMPPARAM",69,0)
 S CNT=0 F  S CNT=$O(HMPAR(CNT)) Q:CNT'>0  D
"RTN","HMPPARAM",70,0)
 .S RESULT(CNT)=HMPAR(CNT,0)
"RTN","HMPPARAM",71,0)
 Q
"RTN","HMPPARAM",72,0)
 ;
"RTN","HMPPARAM",73,0)
GETBYUID(RESULT,UID) ;
"RTN","HMPPARAM",74,0)
 N ENTITY
"RTN","HMPPARAM",75,0)
 D BLDENT(UID,.ENTITY)
"RTN","HMPPARAM",76,0)
 D GETPARAM(.RESULT,"HMP PARAMETERS",$G(ENTITY("entity")),$G(ENTITY("entityId")),$G(ENTITY("uid")))
"RTN","HMPPARAM",77,0)
 ;I $D(RESULT)<10 S RESULT(0)="{}"
"RTN","HMPPARAM",78,0)
 Q
"RTN","HMPPARAM",79,0)
 ;
"RTN","HMPPARAM",80,0)
PARSEJSN(VALUE,ARRAY,ERR) ;
"RTN","HMPPARAM",81,0)
 N ERROR,JSON,TXT
"RTN","HMPPARAM",82,0)
 D DECODE^HMPJSON("VALUE","ARRAY","ERROR")
"RTN","HMPPARAM",83,0)
 I $D(ERR) K ARRAY S TXT(1)="Problem decoding json value." D SETERROR(.VALUE,.ERROR,.TXT,.ERR) Q 0
"RTN","HMPPARAM",84,0)
 Q 1
"RTN","HMPPARAM",85,0)
 ;
"RTN","HMPPARAM",86,0)
PUTPARAM(RESULT,VALUE,ENTARR) ;
"RTN","HMPPARAM",87,0)
 N CNT,ENT,ENTITY,ENTVALUE,ERR,STR,HMPERR,X
"RTN","HMPPARAM",88,0)
 I $D(ENTARR)<10 I $$PARSEJSN(.VALUE,.ENTARR,.ERR)=0 M RESULT=ERR Q
"RTN","HMPPARAM",89,0)
 ;delete old parameter
"RTN","HMPPARAM",90,0)
 S ENTITY=ENTARR("entity")
"RTN","HMPPARAM",91,0)
 S ENTVALUE=ENTARR("entityId")
"RTN","HMPPARAM",92,0)
 S ENT=$S($G(ENTVALUE)>0:ENTITY_".`"_ENTVALUE,1:ENTITY)
"RTN","HMPPARAM",93,0)
 D DEL^XPAR(ENT,"HMP PARAMETERS",ENTARR("uid"),.HMPERR)
"RTN","HMPPARAM",94,0)
 S CNT=$O(VALUE(""),-1) I CNT="" S STR(1,0)=VALUE
"RTN","HMPPARAM",95,0)
 I CNT>0 F X=0:1:CNT S STR(X+1,0)=VALUE(X)
"RTN","HMPPARAM",96,0)
 D PUT^XPAR(ENT,"HMP PARAMETERS",ENTARR("uid"),.STR,.HMPERR)
"RTN","HMPPARAM",97,0)
 S RESULT(0)="{""success"":""true""}"
"RTN","HMPPARAM",98,0)
 Q
"RTN","HMPPARAM",99,0)
 ;
"RTN","HMPPARAM",100,0)
PUTBYUID(RESULT,UID,VALUE) ;
"RTN","HMPPARAM",101,0)
 N ENTITY
"RTN","HMPPARAM",102,0)
 D BLDENT(UID,.ENTITY)
"RTN","HMPPARAM",103,0)
 D PUTPARAM(.RESULT,.VALUE,.ENTITY)
"RTN","HMPPARAM",104,0)
 Q
"RTN","HMPPARAM",105,0)
 ;
"RTN","HMPPARAM",106,0)
SETERROR(INPDATA,ERRORMSG,TXT,OUTPUT) ;
"RTN","HMPPARAM",107,0)
 N ERRARR
"RTN","HMPPARAM",108,0)
 D SETERROR^HMPUTILS(.ERRARR,.ERRORMSG,.TXT,.INPDATA)
"RTN","HMPPARAM",109,0)
 D ENCODE^HMPJSON("ERRARR","OUTPUT","ERROR")
"RTN","HMPPARAM",110,0)
 Q
"RTN","HMPPTRPC")
0^80^B10929781^n/a
"RTN","HMPPTRPC",1,0)
HMPPTRPC ;ASMR/MBS/CK - Patient Select RPC;May 15, 2016 14:15
"RTN","HMPPTRPC",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPPTRPC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPPTRPC",4,0)
 ; ROUTINE          IA#
"RTN","HMPPTRPC",5,0)
 ; XLFSTR          10104
"RTN","HMPPTRPC",6,0)
 ; XLFSTR          10104
"RTN","HMPPTRPC",7,0)
 ; VADPT           10061
"RTN","HMPPTRPC",8,0)
 ; MPIF001          2701
"RTN","HMPPTRPC",9,0)
 ; ORQPT2
"RTN","HMPPTRPC",10,0)
 ; XLFDT
"RTN","HMPPTRPC",11,0)
 ; DIC
"RTN","HMPPTRPC",12,0)
 ;
"RTN","HMPPTRPC",13,0)
 Q
"RTN","HMPPTRPC",14,0)
SELECT(RET,CRIT,SEARCH) ; Returns patient information based on search
"RTN","HMPPTRPC",15,0)
 N I,DFN,DFNS,HMPCNT,ICN,PID,CRITFND
"RTN","HMPPTRPC",16,0)
 S RET(1)="" ; Default to empty string return
"RTN","HMPPTRPC",17,0)
 I $G(SEARCH)="" S RET(1)="-1^No patient specified." Q
"RTN","HMPPTRPC",18,0)
 I $G(CRIT)="" S RET(1)="-1^No search critera specified." Q
"RTN","HMPPTRPC",19,0)
 S CRIT=$$UP^XLFSTR(CRIT),CRITFND=0 ; CRITFND will be 1 if we matched the CRIT to a criteria
"RTN","HMPPTRPC",20,0)
 I CRIT="LAST5" D SRLAST5(SEARCH) S CRITFND=1 ; Search by last5
"RTN","HMPPTRPC",21,0)
 I CRIT="NAME" D SRNAME(SEARCH) S CRITFND=1 ; Search by (partial) name
"RTN","HMPPTRPC",22,0)
 I CRIT="ICN" S DFNS(1)=$$GETDFN^MPIF001(SEARCH),ICN=SEARCH,CRITFND=1 ; ICN
"RTN","HMPPTRPC",23,0)
 I CRIT="PID" S DFNS(1)=$P(SEARCH,";",2),PID=SEARCH,CRITFND=1 ; PID - assume 2nd piece is DFN for *this* server
"RTN","HMPPTRPC",24,0)
 I $G(PID)]"",$P(PID,";")'=$$SYS^HMPUTILS S RET(1)="-1^Can only resolve pid for local site." Q
"RTN","HMPPTRPC",25,0)
 ;If we couldn't match a search criteria, return an error
"RTN","HMPPTRPC",26,0)
 I 'CRITFND S RET(1)="-1^Invalid search criteria requested" Q
"RTN","HMPPTRPC",27,0)
 I +$G(DFNS(1))=-1 S RET(1)="" Q
"RTN","HMPPTRPC",28,0)
 S HMPCNT="" F  S HMPCNT=$O(DFNS(HMPCNT)) Q:HMPCNT=""  S DFN=DFNS(HMPCNT) D
"RTN","HMPPTRPC",29,0)
 . N ICN,SENS,SSN,DOB,FULLNAME,FAMNAME,DISPNAME,SUMMARY,GNDRCODE,LAST4,LAST5,PID,GNDRNAME,VADM,GVNNAME
"RTN","HMPPTRPC",30,0)
 . I $$GET1^DIQ(2,DFN,".01")="" Q  ; Skip entries that don't match a valid DFN (mostly useful if CRIT was "PID")
"RTN","HMPPTRPC",31,0)
 . D DEM^VADPT
"RTN","HMPPTRPC",32,0)
 . S ICN=$$GETICN^MPIF001(DFN)
"RTN","HMPPTRPC",33,0)
 . S SENS=$S($$EN1^ORQPT2(DFN)=1:"true",1:"false")
"RTN","HMPPTRPC",34,0)
 . S DOB=$TR($$FMTE^XLFDT(+$P($P($G(VADM(3)),U),"."),"7DZ"),"/","")
"RTN","HMPPTRPC",35,0)
 . S FULLNAME=$G(VADM(1))
"RTN","HMPPTRPC",36,0)
 . S FAMNAME=$P(FULLNAME,",",1),GVNNAME=$P(FULLNAME,",",2,99)
"RTN","HMPPTRPC",37,0)
 . S DISPNAME=$$FRSTCPS(FULLNAME),SUMMARY=DISPNAME
"RTN","HMPPTRPC",38,0)
 . S GNDRCODE="urn:va:pat-gender:"_$P($G(VADM(5)),U),GNDRNAME=$P($G(VADM(5)),U,2)
"RTN","HMPPTRPC",39,0)
 . S LAST4=$P($P($G(VADM(2)),U,2),"-",3),LAST5=$E(FAMNAME,1)_LAST4,SSN="*****"_LAST4
"RTN","HMPPTRPC",40,0)
 . S PID=$$SYS^HMPUTILS_";"_DFN
"RTN","HMPPTRPC",41,0)
 . S RET(HMPCNT)=FULLNAME_U_FAMNAME_U_GVNNAME_U_DISPNAME_U_GNDRCODE_U_GNDRNAME_U_SSN_U_LAST4_U_LAST5_U_DOB_U_SENS_U_DFN
"RTN","HMPPTRPC",42,0)
 . S RET(HMPCNT)=RET(HMPCNT)_U_PID_U_ICN_U_SUMMARY
"RTN","HMPPTRPC",43,0)
 Q
"RTN","HMPPTRPC",44,0)
SRLAST5(SEARCH) ; Search for patients by last5
"RTN","HMPPTRPC",45,0)
 D FIND(SEARCH,"BS5")
"RTN","HMPPTRPC",46,0)
 Q
"RTN","HMPPTRPC",47,0)
SRNAME(SEARCH) ; Search for patients by name
"RTN","HMPPTRPC",48,0)
 D FIND(SEARCH,"")
"RTN","HMPPTRPC",49,0)
 Q
"RTN","HMPPTRPC",50,0)
FIND(SEARCH,XREF) ; Find patients that match search term in x-ref
"RTN","HMPPTRPC",51,0)
 N HMPFIND,HMPERR
"RTN","HMPPTRPC",52,0)
 D FIND^DIC(2,,"@","P",SEARCH,,XREF,,,"HMPFIND","HMPERR")
"RTN","HMPPTRPC",53,0)
 F I=1:1:+$G(HMPFIND("DILIST",0)) S DFNS(I)=HMPFIND("DILIST",I,0)
"RTN","HMPPTRPC",54,0)
 Q
"RTN","HMPPTRPC",55,0)
FRSTCPS(IN) ; Formats patient's name to begin each word with a capital and the rest lowercase
"RTN","HMPPTRPC",56,0)
 N FRSTCHAR,OUT
"RTN","HMPPTRPC",57,0)
 S FRSTCHAR=1,OUT=""
"RTN","HMPPTRPC",58,0)
 F I=1:1:$L(IN) D
"RTN","HMPPTRPC",59,0)
 . N CHAR S CHAR=$E($E(IN,I))
"RTN","HMPPTRPC",60,0)
 . I $$ISALPHA(CHAR) D  Q
"RTN","HMPPTRPC",61,0)
 . . I FRSTCHAR S OUT=OUT_CHAR,FRSTCHAR=0 Q
"RTN","HMPPTRPC",62,0)
 . . S OUT=OUT_$$LOW^XLFSTR(CHAR)
"RTN","HMPPTRPC",63,0)
 . ;otherwise, non-alphabetic character
"RTN","HMPPTRPC",64,0)
 . S OUT=OUT_CHAR,FRSTCHAR=1
"RTN","HMPPTRPC",65,0)
 Q OUT
"RTN","HMPPTRPC",66,0)
ISALPHA(CHAR) ;
"RTN","HMPPTRPC",67,0)
 Q CHAR?1A
"RTN","HMPPTRPC",68,0)
 ;
"RTN","HMPPXRM")
0^89^B14343853^B14531240
"RTN","HMPPXRM",1,0)
HMPPXRM ;SLC/AGP,ASMR/RRB,CK - Clinical Reminders routine;May 15, 2016 14:15
"RTN","HMPPXRM",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPPXRM",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPPXRM",4,0)
 ;
"RTN","HMPPXRM",5,0)
 Q
"RTN","HMPPXRM",6,0)
 ;
"RTN","HMPPXRM",7,0)
EVALLIST(RESULT,PT,USER,LOC) ;
"RTN","HMPPXRM",8,0)
 N CNT,NUM,RIEN,TMP,UID,HMPTMP,HMPSYS
"RTN","HMPPXRM",9,0)
 N DUEDATE,I,J,LASTDONE,NAME,NODE,STATUS,TXT
"RTN","HMPPXRM",10,0)
 ;S USER=$P(USERUID,":",5)
"RTN","HMPPXRM",11,0)
 D GETLIST^ORQQPX(.HMPTMP,LOC)
"RTN","HMPPXRM",12,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPPXRM",13,0)
 S CNT=0,NUM=0 F  S CNT=$O(HMPTMP(CNT)) Q:CNT'>0  D
"RTN","HMPPXRM",14,0)
 .S RIEN=$G(HMPTMP(CNT)) I RIEN'>0 Q
"RTN","HMPPXRM",15,0)
 .;begin fix DE 2818 ICR 6113 ASF 11/16
"RTN","HMPPXRM",16,0)
 .;S NAME="" S NAME=$P($G(^PXD(811.9,RIEN,0)),U,3)
"RTN","HMPPXRM",17,0)
 .;I NAME="" S NAME=$P($G(^PXD(811.9,RIEN,0)),U)
"RTN","HMPPXRM",18,0)
 .S NAME=$$GET1^DIQ(811.9,REIN_",",1.2)
"RTN","HMPPXRM",19,0)
 .I NAME="" S NAME=$$GET1^DIQ(811.9,REIN_",",.01)
"RTN","HMPPXRM",20,0)
 .; end DE2818 fix
"RTN","HMPPXRM",21,0)
 .S UID="urn:va:pxrm:"_HMPSYS_":"_RIEN
"RTN","HMPPXRM",22,0)
 .S NUM=NUM+1,TMP("reminders",NUM,"uid")=UID,TMP("reminders",NUM,"name")=NAME
"RTN","HMPPXRM",23,0)
 .K ^TMP("PXRHM",$J)
"RTN","HMPPXRM",24,0)
 .D MAIN^PXRM(PT,RIEN,5)     ; 5 returns all reminder info
"RTN","HMPPXRM",25,0)
 .S I=1,TXT=""
"RTN","HMPPXRM",26,0)
 .S NAME="",NAME=$O(^TMP("PXRHM",$J,RIEN,NAME)) Q:NAME=""  D
"RTN","HMPPXRM",27,0)
 ..S NODE=$G(^TMP("PXRHM",$J,RIEN,NAME))
"RTN","HMPPXRM",28,0)
 ..S STATUS=$P(NODE,U),DUEDATE=$$JSONDT^HMPUTILS($P(NODE,U,2)),LASTDONE=$$JSONDT^HMPUTILS($P(NODE,U,3))
"RTN","HMPPXRM",29,0)
 ..S J=0 F  S J=$O(^TMP("PXRHM",$J,RIEN,NAME,"TXT",J)) Q:J=""  D
"RTN","HMPPXRM",30,0)
 ...S TXT=$G(TXT)_^TMP("PXRHM",$J,RIEN,NAME,"TXT",J)_$C(13)_$C(10),I=I+1
"RTN","HMPPXRM",31,0)
 .K ^TMP("PXRHM",$J)
"RTN","HMPPXRM",32,0)
 .S TMP("reminders",NUM,"status")=STATUS
"RTN","HMPPXRM",33,0)
 .S TMP("reminders",NUM,"dueDate")=DUEDATE
"RTN","HMPPXRM",34,0)
 .S TMP("reminders",NUM,"lastDone")=LASTDONE
"RTN","HMPPXRM",35,0)
 .S TMP("reminders",NUM,"clinicalMaintenance")=TXT
"RTN","HMPPXRM",36,0)
 S TMP("success")="true"
"RTN","HMPPXRM",37,0)
 D ENCODE^HMPJSON("TMP","RESULT","ERROR")
"RTN","HMPPXRM",38,0)
 I $D(ERROR) D SETERROR(.TMP,.ERROR,.RESULT)
"RTN","HMPPXRM",39,0)
 Q
"RTN","HMPPXRM",40,0)
 ;
"RTN","HMPPXRM",41,0)
EVALREM(RESULT,PT,UID) ;return detail for a pt's clinical reminder
"RTN","HMPPXRM",42,0)
 K ^TMP("PXRHM",$J)
"RTN","HMPPXRM",43,0)
 N DUEDATE,I,J,LASTDONE,NAME,NODE,RIEN,STATUS,TMP,TXT
"RTN","HMPPXRM",44,0)
 S RIEN=$P(UID,":",5)
"RTN","HMPPXRM",45,0)
 D MAIN^PXRM(PT,RIEN,5)     ; 5 returns all reminder info
"RTN","HMPPXRM",46,0)
 S I=1,TXT=""
"RTN","HMPPXRM",47,0)
 S NAME="",NAME=$O(^TMP("PXRHM",$J,RIEN,NAME)) Q:NAME=""  D
"RTN","HMPPXRM",48,0)
 .S NODE=$G(^TMP("PXRHM",$J,RIEN,NAME))
"RTN","HMPPXRM",49,0)
 .S STATUS=$P(NODE,U),DUEDATE=$$JSONDT^HMPUTILS($P(NODE,U,2)),LASTDONE=$$JSONDT^HMPUTILS($P(NODE,U,3))
"RTN","HMPPXRM",50,0)
 .S J=0 F  S J=$O(^TMP("PXRHM",$J,RIEN,NAME,"TXT",J)) Q:J=""  D
"RTN","HMPPXRM",51,0)
 ..S TXT=$G(TXT)_^TMP("PXRHM",$J,RIEN,NAME,"TXT",J)_$C(13)_$C(10),I=I+1
"RTN","HMPPXRM",52,0)
 K ^TMP("PXRHM",$J)
"RTN","HMPPXRM",53,0)
 S TMP("uid")=UID
"RTN","HMPPXRM",54,0)
 S TMP("status")=STATUS
"RTN","HMPPXRM",55,0)
 S TMP("dueDate")=DUEDATE
"RTN","HMPPXRM",56,0)
 S TMP("lastDone")=LASTDONE
"RTN","HMPPXRM",57,0)
 S TMP("clinicalMaintenance")=TXT
"RTN","HMPPXRM",58,0)
 S TMP("success")="true"
"RTN","HMPPXRM",59,0)
 D ENCODE^HMPJSON("TMP","RESULT","ERROR")
"RTN","HMPPXRM",60,0)
 I $D(ERROR) D SETERROR(.TMP,.ERROR,.RESULT)
"RTN","HMPPXRM",61,0)
 Q
"RTN","HMPPXRM",62,0)
 ;
"RTN","HMPPXRM",63,0)
REMLIST(RESULT,USERUID,LOC) ;
"RTN","HMPPXRM",64,0)
 N CNT,NUM,RIEN,TMP,UID,USER,HMPTMP,HMPSYS
"RTN","HMPPXRM",65,0)
 S USER=$P(USERUID,":",5)
"RTN","HMPPXRM",66,0)
 D GETLIST^ORQQPX(.HMPTMP,LOC)
"RTN","HMPPXRM",67,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPPXRM",68,0)
 S CNT=0,NUM=0 F  S CNT=$O(HMPTMP(CNT)) Q:CNT'>0  D
"RTN","HMPPXRM",69,0)
 .S RIEN=$G(HMPTMP(CNT)) I RIEN'>0 Q
"RTN","HMPPXRM",70,0)
 .;begin fix DE 2818 ICR 6113 ASF 11/16
"RTN","HMPPXRM",71,0)
 .;S NAME="" S NAME=$P($G(^PXD(811.9,RIEN,0)),U,3)
"RTN","HMPPXRM",72,0)
 .;I NAME="" S NAME=$P($G(^PXD(811.9,RIEN,0)),U)
"RTN","HMPPXRM",73,0)
 .S NAME=$$GET1^DIQ(811.9,REIN_",",1.2)
"RTN","HMPPXRM",74,0)
 .I NAME="" S NAME=$$GET1^DIQ(811.9,REIN_",",.01)
"RTN","HMPPXRM",75,0)
 .; end DE2818 fix
"RTN","HMPPXRM",76,0)
 .S UID="urn:va:pxrm:"_HMPSYS_":"_RIEN
"RTN","HMPPXRM",77,0)
 .S NUM=NUM+1,TMP("reminders",NUM,"uid")=UID,TMP("reminders",NUM,"name")=NAME
"RTN","HMPPXRM",78,0)
 S TMP("success")="true"
"RTN","HMPPXRM",79,0)
 D ENCODE^HMPJSON("TMP","RESULT","ERROR")
"RTN","HMPPXRM",80,0)
 I $D(ERROR) D SETERROR(.TMP,.ERROR,.RESULT)
"RTN","HMPPXRM",81,0)
 Q
"RTN","HMPPXRM",82,0)
 ;
"RTN","HMPPXRM",83,0)
SETERROR(INPDATA,ERRORMSG,OUTPUT) ;
"RTN","HMPPXRM",84,0)
 N ERRARR,TXT
"RTN","HMPPXRM",85,0)
 S TXT(1)="Problem encoding json output"
"RTN","HMPPXRM",86,0)
 D SETERROR^HMPUTILS(.ERRARR,.ERRORMSG,.TXT,.INPDATA)
"RTN","HMPPXRM",87,0)
 D ENCODE^HMPJSON("ERRARR","OUTPUT","ERROR")
"RTN","HMPPXRM",88,0)
 Q
"RTN","HMPPXRM",89,0)
 ;
"RTN","HMPSTMP")
0^83^B79306076^B70461106
"RTN","HMPSTMP",1,0)
HMPSTMP ;ASMR/JD,BL,ASF,CK - MetaStamp ;May 15, 2016 14:15
"RTN","HMPSTMP",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPSTMP",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPSTMP",4,0)
 ;
"RTN","HMPSTMP",5,0)
 ; Returns the most recent date/time
"RTN","HMPSTMP",6,0)
 ; JD - 6/5/15 - Added code to the DOC section to consider the attachment date
"RTN","HMPSTMP",7,0)
 ;               as one of the dates if it exists
"RTN","HMPSTMP",8,0)
 Q
"RTN","HMPSTMP",9,0)
 ;
"RTN","HMPSTMP",10,0)
EN(A) ; extrinsic function, used to create "stampTime" or "lastUpdateTime" subscript in arrays
"RTN","HMPSTMP",11,0)
 K B
"RTN","HMPSTMP",12,0)
 N C
"RTN","HMPSTMP",13,0)
 ; A is either "now" or a domain name (per PTDOMS^HMPDJFSD)
"RTN","HMPSTMP",14,0)
 ; B is the return value (stampTime)
"RTN","HMPSTMP",15,0)
 S C=$$UP^XLFSTR(A)
"RTN","HMPSTMP",16,0)
 I C="NOW" G NOW
"RTN","HMPSTMP",17,0)
 I C="ADM" G ADM
"RTN","HMPSTMP",18,0)
 I C="ALLERGY" G ALL
"RTN","HMPSTMP",19,0)
 I C="AUXILIARY" G AUX
"RTN","HMPSTMP",20,0)
 I C="APPOINTMENT" G APP
"RTN","HMPSTMP",21,0)
 I C="DIAGNOSIS" G DIA
"RTN","HMPSTMP",22,0)
 I C="DOCUMENT" G DOC
"RTN","HMPSTMP",23,0)
 I C="FACTOR" G FAC
"RTN","HMPSTMP",24,0)
 I C="IMMUNIZATION" G IMM
"RTN","HMPSTMP",25,0)
 I C="LAB" G LAB
"RTN","HMPSTMP",26,0)
 I C="MED" G MED
"RTN","HMPSTMP",27,0)
 I C="OBS" G OBS
"RTN","HMPSTMP",28,0)
 I C="ORDER" G ORD
"RTN","HMPSTMP",29,0)
 I C="PROBLEM" G PRO
"RTN","HMPSTMP",30,0)
 I C="PROCEDURE" G PRC
"RTN","HMPSTMP",31,0)
 I C="CONSULT" G CON
"RTN","HMPSTMP",32,0)
 I C="IMAGE" G IMA
"RTN","HMPSTMP",33,0)
 I C="SURGERY" G SUR
"RTN","HMPSTMP",34,0)
 I C="TASK" G TAS
"RTN","HMPSTMP",35,0)
 I C="VISIT" G VIS
"RTN","HMPSTMP",36,0)
 I C="VITAL" G VIT
"RTN","HMPSTMP",37,0)
 I C="PTF" G PTF
"RTN","HMPSTMP",38,0)
 I C="EXAM" G EXA
"RTN","HMPSTMP",39,0)
 I C="CPT" G CPT
"RTN","HMPSTMP",40,0)
 I C="EDUCATION" G EDU
"RTN","HMPSTMP",41,0)
 I C="POV" G POV
"RTN","HMPSTMP",42,0)
 I C="SKIN" G SKI
"RTN","HMPSTMP",43,0)
 I C="TREATMENT" G TRE
"RTN","HMPSTMP",44,0)
 I C="MH" G MH
"RTN","HMPSTMP",45,0)
 ;
"RTN","HMPSTMP",46,0)
 ;DE2818, changed code to fall through instead of "Q B", which would be undefined at this point
"RTN","HMPSTMP",47,0)
 ;fall through to NOW
"RTN","HMPSTMP",48,0)
NOW ;
"RTN","HMPSTMP",49,0)
 ; Set stamp time in YYYYMMDDHHMMSS format (FMTHL7 will return time zone)
"RTN","HMPSTMP",50,0)
 S B=$P($$FMTHL7^XLFDT($$NOW^XLFDT),"-")
"RTN","HMPSTMP",51,0)
 S B=$E(B_"000000",1,14)  ; Need padding to force YYYYMMDDHHMMSS precision
"RTN","HMPSTMP",52,0)
 Q B
"RTN","HMPSTMP",53,0)
ADM ; Admissions (these are visits whose ID starts with an "H").  JD - January 26, 2015
"RTN","HMPSTMP",54,0)
 K DATA
"RTN","HMPSTMP",55,0)
 S DATE(1)=$G(ADM("dateTime"))
"RTN","HMPSTMP",56,0)
 S DATE(2)=$G(ADM("stay","dischargeDateTime"))
"RTN","HMPSTMP",57,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",58,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",59,0)
ALL ; Allergy ; rhl 20141231
"RTN","HMPSTMP",60,0)
 K DATE
"RTN","HMPSTMP",61,0)
 S DATE(1)=$G(REAC("entered"))
"RTN","HMPSTMP",62,0)
 S DATE(2)=$G(REAC("verified"))
"RTN","HMPSTMP",63,0)
 ;  dates in observations array
"RTN","HMPSTMP",64,0)
 N I,J
"RTN","HMPSTMP",65,0)
 S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",66,0)
 S I=0
"RTN","HMPSTMP",67,0)
 F  S I=$O(REAC("observations",I)) Q:I=""  D
"RTN","HMPSTMP",68,0)
 . I $G(REAC("observations",I,"date"))]"" S J=J+1,DATE(J)=REAC("observations",I,"date")
"RTN","HMPSTMP",69,0)
 ;  dates in comment array
"RTN","HMPSTMP",70,0)
 N I,J
"RTN","HMPSTMP",71,0)
 S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",72,0)
 S I=0
"RTN","HMPSTMP",73,0)
 F  S I=$O(REAC("comments",I)) Q:I=""  D
"RTN","HMPSTMP",74,0)
 . I $G(REAC("comments",I,"entered"))]"" S J=J+1,DATE(J)=REAC("comments",I,"entered")
"RTN","HMPSTMP",75,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",76,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",77,0)
AUX ; Auxiliary
"RTN","HMPSTMP",78,0)
 Q ""
"RTN","HMPSTMP",79,0)
 K DATE
"RTN","HMPSTMP",80,0)
 ;S DATE(1)=$G(
"RTN","HMPSTMP",81,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",82,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",83,0)
APP ; Appointment
"RTN","HMPSTMP",84,0)
 K DATE
"RTN","HMPSTMP",85,0)
 S DATE(1)=$G(APPT("dateTime"))
"RTN","HMPSTMP",86,0)
 S DATE(2)=$G(APPT("checkIn"))
"RTN","HMPSTMP",87,0)
 S DATE(3)=$G(APPT("checkOut"))
"RTN","HMPSTMP",88,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",89,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",90,0)
DIA ; Diagnosis
"RTN","HMPSTMP",91,0)
 Q ""
"RTN","HMPSTMP",92,0)
 K DATE
"RTN","HMPSTMP",93,0)
 ;S DATE(1)=$G(
"RTN","HMPSTMP",94,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",95,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",96,0)
DOC ; Document
"RTN","HMPSTMP",97,0)
 N AUDDT
"RTN","HMPSTMP",98,0)
 S AUDDT=""  ; Audit trail date/time
"RTN","HMPSTMP",99,0)
 K DATE
"RTN","HMPSTMP",100,0)
 S DATE(1)=$G(DOC("referenceDateTime"))
"RTN","HMPSTMP",101,0)
 S DATE(2)=$G(DOC("entered"))
"RTN","HMPSTMP",102,0)
 ;DE2818, ^TIU(8925.5) references - ICR 6279
"RTN","HMPSTMP",103,0)
 ; Find the most recent audit trail entry for the document
"RTN","HMPSTMP",104,0)
 S:$G(DOC("localId")) AUDDT=$O(^TIU(8925.5,"B",DOC("localId"),""),-1)
"RTN","HMPSTMP",105,0)
 ; Get the audit trail date/time
"RTN","HMPSTMP",106,0)
 S:AUDDT AUDDT=$P($G(^TIU(8925.5,AUDDT,3)),"^",2)
"RTN","HMPSTMP",107,0)
 S:AUDDT DATE(3)=$$JSONDT^HMPUTILS(AUDDT)
"RTN","HMPSTMP",108,0)
 ;go through HMPDJ array
"RTN","HMPSTMP",109,0)
 N I,II,J
"RTN","HMPSTMP",110,0)
 S J=""
"RTN","HMPSTMP",111,0)
 S J=$O(DATE(J),-1)
"RTN","HMPSTMP",112,0)
 S I=0
"RTN","HMPSTMP",113,0)
 F  S I=$O(DOC("text",I)) Q:I=""  D
"RTN","HMPSTMP",114,0)
 . I $G(DOC("text",I,"dateTime"))]"" S J=J+1,DATE(J)=DOC("text",I,"dateTime")
"RTN","HMPSTMP",115,0)
 . S II=0 F  S II=$O(DOC("text",I,"clinicians",II)) Q:II=""  D
"RTN","HMPSTMP",116,0)
 . . I $G(DOC("text",I,"clinicians",II,"signedDateTime"))]"" S J=J+1,DATE(J)=DOC("text",I,"clinicians",II,"signedDateTime")
"RTN","HMPSTMP",117,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",118,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",119,0)
FAC ; Factor
"RTN","HMPSTMP",120,0)
 K DATE
"RTN","HMPSTMP",121,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",122,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",123,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",124,0)
IMM ; Immunization
"RTN","HMPSTMP",125,0)
 K DATE
"RTN","HMPSTMP",126,0)
 S DATE(1)=$G(PCE("administeredDateTime"))
"RTN","HMPSTMP",127,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",128,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",129,0)
LAB ; Lab
"RTN","HMPSTMP",130,0)
 K DATE
"RTN","HMPSTMP",131,0)
 S DATE(1)=$G(LAB("observed"))
"RTN","HMPSTMP",132,0)
 S DATE(2)=$G(LAB("resulted"))
"RTN","HMPSTMP",133,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",134,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",135,0)
MED ; Med
"RTN","HMPSTMP",136,0)
 K DATE
"RTN","HMPSTMP",137,0)
 S DATE(1)=$G(MED("orders",1,"ordered"))
"RTN","HMPSTMP",138,0)
 S DATE(2)=$G(MED("overallStart"))
"RTN","HMPSTMP",139,0)
 S DATE(3)=$G(MED("overallStop"))
"RTN","HMPSTMP",140,0)
 S DATE(4)=$G(MED("stopped"))
"RTN","HMPSTMP",141,0)
 S DATE(5)=$G(MED("lastFilled"))
"RTN","HMPSTMP",142,0)
 ;go through value array
"RTN","HMPSTMP",143,0)
 N I,J
"RTN","HMPSTMP",144,0)
 S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",145,0)
 S I=0
"RTN","HMPSTMP",146,0)
 F  S I=$O(MED("dosages",I)) Q:I=""  D
"RTN","HMPSTMP",147,0)
 . I $G(MED("dosages",I,"start"))]"" S J=J+1,DATE(J)=MED("dosages",I,"start")
"RTN","HMPSTMP",148,0)
 . I $G(MED("dosages",I,"stop"))]"" S J=J+1,DATE(J)=MED("dosages",I,"stop")
"RTN","HMPSTMP",149,0)
 S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",150,0)
 S I=0
"RTN","HMPSTMP",151,0)
 F  S I=$O(MED("fills",I)) Q:I=""  D
"RTN","HMPSTMP",152,0)
 . I $G(MED("fills",I,"dispenseDate"))]"" S J=J+1,DATE(J)=MED("fills",I,"dispenseDate")
"RTN","HMPSTMP",153,0)
 . I $G(MED("fills",I,"releaseDate"))]"" S J=J+1,DATE(J)=MED("fills",I,"releaseDate")
"RTN","HMPSTMP",154,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",155,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",156,0)
OBS ; Obs ; rhl 20141231
"RTN","HMPSTMP",157,0)
 K DATE
"RTN","HMPSTMP",158,0)
 S DATE(1)=$G(CLIO("entered"))
"RTN","HMPSTMP",159,0)
 S DATE(2)=$G(CLIO("observed"))
"RTN","HMPSTMP",160,0)
 S DATE(3)=$G(CLIO("setStart"))
"RTN","HMPSTMP",161,0)
 S DATE(4)=$G(CLIO("setStop"))
"RTN","HMPSTMP",162,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",163,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",164,0)
ORD ; Order ; RHL 20141231
"RTN","HMPSTMP",165,0)
 K DATE
"RTN","HMPSTMP",166,0)
 S DATE(1)=$G(ORDER("entered"))
"RTN","HMPSTMP",167,0)
 ;S DATE(2)=$G(ORDER("start"))
"RTN","HMPSTMP",168,0)
 ;S DATE(3)=$G(ORDER("stop"))
"RTN","HMPSTMP",169,0)
 ;these are dates in signature/verification dates
"RTN","HMPSTMP",170,0)
 I $G(ORDER("clinicians")) D
"RTN","HMPSTMP",171,0)
 . N I,J
"RTN","HMPSTMP",172,0)
 . S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",173,0)
 . S I=0
"RTN","HMPSTMP",174,0)
 . F  S I=$O(ORDER("clinicians",I)) Q:I=""  D
"RTN","HMPSTMP",175,0)
 . . I $G(ORDER("clinicians",I,"signedDateTime"))]"" S J=J+1,DATE(J)=ORDER("clinicians",I,"signedDateTime")
"RTN","HMPSTMP",176,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",177,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",178,0)
 ;
"RTN","HMPSTMP",179,0)
PRO ; Problem
"RTN","HMPSTMP",180,0)
 K DATE N I,J,T
"RTN","HMPSTMP",181,0)
 S DATE(1)=$G(PROB("entered"))
"RTN","HMPSTMP",182,0)
 S DATE(2)=$G(PROB("updated"))
"RTN","HMPSTMP",183,0)
 S DATE(3)=$G(PROB("onset"))
"RTN","HMPSTMP",184,0)
 S DATE(4)=$G(PROB("resolved"))
"RTN","HMPSTMP",185,0)
 ;there may be dates in comments
"RTN","HMPSTMP",186,0)
 S I=0,J=4  ; J starts at 4 because of the logic above
"RTN","HMPSTMP",187,0)
 F  S I=$O(PROB("comments",I)) Q:I=""  S T=$G(PROB("comments",I,"entered")) S:T J=J+1,DATE(J)=T
"RTN","HMPSTMP",188,0)
 ; ASF - DE3691, get lastUpdateTime, Feb 29, 2016
"RTN","HMPSTMP",189,0)
 D 
"RTN","HMPSTMP",190,0)
 . ;if freshness item get timestamp from stream get last update from freshness stream
"RTN","HMPSTMP",191,0)
 . S T=$G(FILTER("freshnessDateTime"))
"RTN","HMPSTMP",192,0)
 . I T S J=J+1,DATE(J)=$$JSONDT^HMPUTILS(T) Q
"RTN","HMPSTMP",193,0)
 . ;else get from audit file
"RTN","HMPSTMP",194,0)
 . S T=$O(^GMPL(125.8,"AD",ID,0))  ; PROBLEM LIST AUDIT, ICR 2974, last changed date/time with seconds
"RTN","HMPSTMP",195,0)
 . I T S J=J+1,DATE(J)=$$JSONDT^HMPUTILS(9999999-T)  ; got an edited date/time (inverse order)
"RTN","HMPSTMP",196,0)
 ;
"RTN","HMPSTMP",197,0)
 Q $$FINDNEW(.DATE)  ; determine newest date
"RTN","HMPSTMP",198,0)
 ;
"RTN","HMPSTMP",199,0)
PRC ; Procedure
"RTN","HMPSTMP",200,0)
 K DATE
"RTN","HMPSTMP",201,0)
 S DATE(1)=$G(PROC("dateTime"))
"RTN","HMPSTMP",202,0)
 S DATE(2)=$G(PROC("requested"))
"RTN","HMPSTMP",203,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",204,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",205,0)
CON ; Consult
"RTN","HMPSTMP",206,0)
 K DATE
"RTN","HMPSTMP",207,0)
 S DATE(1)=$G(CONS("dateTime"))
"RTN","HMPSTMP",208,0)
 S DATE(2)=$G(CONS("earliestDate"))
"RTN","HMPSTMP",209,0)
 S DATE(3)=$G(ACT("entered"))
"RTN","HMPSTMP",210,0)
 S DATE(4)=$G(ACT("dateTime"))
"RTN","HMPSTMP",211,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",212,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",213,0)
IMA ; Image ; RHL 20150102
"RTN","HMPSTMP",214,0)
 K DATE
"RTN","HMPSTMP",215,0)
 S DATE(1)=$G(EXAM("dateTime"))
"RTN","HMPSTMP",216,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",217,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",218,0)
SUR ; Surgery ; RHL 20150102
"RTN","HMPSTMP",219,0)
 K DATE
"RTN","HMPSTMP",220,0)
 S DATE(1)=$G(SURG("dateTime"))
"RTN","HMPSTMP",221,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",222,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",223,0)
TAS ; Task
"RTN","HMPSTMP",224,0)
 Q ""
"RTN","HMPSTMP",225,0)
 K DATE
"RTN","HMPSTMP",226,0)
 ;S DATE(1)=$G(
"RTN","HMPSTMP",227,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",228,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",229,0)
VIS ; Visit
"RTN","HMPSTMP",230,0)
 K DATE
"RTN","HMPSTMP",231,0)
 S DATE(1)=$G(VST("dateTime"))
"RTN","HMPSTMP",232,0)
 S DATE(2)=$G(VST("checkOut"))
"RTN","HMPSTMP",233,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",234,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",235,0)
VIT ; Vital
"RTN","HMPSTMP",236,0)
 K DATE
"RTN","HMPSTMP",237,0)
 S DATE(1)=$G(VIT("observed"))
"RTN","HMPSTMP",238,0)
 S DATE(2)=$G(VIT("resulted"))
"RTN","HMPSTMP",239,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",240,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",241,0)
PTF ; Ptf ; RHL 20150102
"RTN","HMPSTMP",242,0)
 K DATE
"RTN","HMPSTMP",243,0)
 S DATE(1)=$G(PTF("arrivalDateTime"))
"RTN","HMPSTMP",244,0)
 S DATE(2)=$G(PTF("dischargeDateTime"))
"RTN","HMPSTMP",245,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",246,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",247,0)
EXA ; Exam
"RTN","HMPSTMP",248,0)
 K DATE
"RTN","HMPSTMP",249,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",250,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",251,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",252,0)
CPT ; CPT
"RTN","HMPSTMP",253,0)
 K DATE
"RTN","HMPSTMP",254,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",255,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",256,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",257,0)
EDU ; Education
"RTN","HMPSTMP",258,0)
 K DATE
"RTN","HMPSTMP",259,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",260,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",261,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",262,0)
POV ; Pov
"RTN","HMPSTMP",263,0)
 K DATE
"RTN","HMPSTMP",264,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",265,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",266,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",267,0)
SKI ; Skin
"RTN","HMPSTMP",268,0)
 K DATE
"RTN","HMPSTMP",269,0)
 S DATE(1)=$G(PCE("entered"))
"RTN","HMPSTMP",270,0)
 S DATE(2)=$G(PCE("dateRead"))
"RTN","HMPSTMP",271,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",272,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",273,0)
TRE ; Treatment ; RHL 20150102
"RTN","HMPSTMP",274,0)
 K DATE
"RTN","HMPSTMP",275,0)
 S DATE(1)=$G(NTX("entered"))
"RTN","HMPSTMP",276,0)
 S DATE(2)=$G(NTX("start"))
"RTN","HMPSTMP",277,0)
 S DATE(3)=$G(NTX("stop"))
"RTN","HMPSTMP",278,0)
 ;these are dates in signature/verification dates; is this used for NTX orders
"RTN","HMPSTMP",279,0)
 I $G(NTX("clinicians")) D
"RTN","HMPSTMP",280,0)
 . N I,J
"RTN","HMPSTMP",281,0)
 . S J="",J=$O(DATE(J),-1)
"RTN","HMPSTMP",282,0)
 . S I=0
"RTN","HMPSTMP",283,0)
 . F  S I=$O(NTX("clinicians",I)) Q:I=""  D
"RTN","HMPSTMP",284,0)
 . . I $G(NTX("clinicians",I,"signedDateTime"))]"" S J=J+1,DATE(J)=NTX("clinicians",I,"signedDateTime")
"RTN","HMPSTMP",285,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",286,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",287,0)
MH ; Mh   ; RHL 20150103
"RTN","HMPSTMP",288,0)
 K DATE
"RTN","HMPSTMP",289,0)
 S DATE(1)=$G(MH("administeredDateTime"))
"RTN","HMPSTMP",290,0)
 ;DETERMINE WHICH ONE IS NEWER
"RTN","HMPSTMP",291,0)
 Q $$FINDNEW(.DATE)
"RTN","HMPSTMP",292,0)
FINDNEW(DATE)  ; function, find the latest date from DATE array
"RTN","HMPSTMP",293,0)
 ;DATE array has following format DATE(1)=DATE DATE(2)=DATE
"RTN","HMPSTMP",294,0)
 N ADATE,COMDATE,NDATE,X
"RTN","HMPSTMP",295,0)
 ; Jan 28, 2016, DE3519;bl set date for comparison, now plus 60 seconds padded with zeroes, no time zone offset
"RTN","HMPSTMP",296,0)
 S NDATE=$E($P($$FMTHL7^XLFDT($$FMADD^XLFDT($$NOW^XLFDT,0,0,0,60)),"-")_"000000",1,14)
"RTN","HMPSTMP",297,0)
 S X=0,COMDATE=0  ; initialize starting date to zero
"RTN","HMPSTMP",298,0)
 F  S X=$O(DATE(X)) Q:'X  D:$E(DATE(X),7,8)  ; evaluate only if precise date. DE3548
"RTN","HMPSTMP",299,0)
 . S ADATE=$E(DATE(X)_"000000",1,14) ; Need padding down to the second (YYYYMMDDHHMM). JD-1/23/15
"RTN","HMPSTMP",300,0)
 . I ADATE>NDATE Q  ; DE3519;bl prevent future date/times in lastUpdateTime
"RTN","HMPSTMP",301,0)
 . I ADATE>COMDATE S COMDATE=ADATE
"RTN","HMPSTMP",302,0)
 I 'COMDATE S COMDATE=$E($P($$FMTHL7^XLFDT($$NOW^XLFDT),"-")_"000000",1,14)
"RTN","HMPSTMP",303,0)
 Q COMDATE
"RTN","HMPSTMP",304,0)
 ;
"RTN","HMPTFU2")
0^84^B39725294^B40086168
"RTN","HMPTFU2",1,0)
HMPTFU2 ;ASMR/JCH,CK - Utilities for the Treating Facility file 391.91 ;May 15, 2016 14:15
"RTN","HMPTFU2",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPTFU2",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPTFU2",4,0)
 ;
"RTN","HMPTFU2",5,0)
 ; Reference to ^DGCN(391.91 is NOT currently supported; see ICR #2911 for an existing Private ICR between 
"RTN","HMPTFU2",6,0)
 ;  Registration and CIRN that would meet the needs of this routine, or provide an example for a new ICR.
"RTN","HMPTFU2",7,0)
 ;
"RTN","HMPTFU2",8,0)
 Q
"RTN","HMPTFU2",9,0)
 ;
"RTN","HMPTFU2",10,0)
TFL(LIST,PT) ;for this PT [patient] (either DFN, ICN or EDIPI) return the list of treating facilities
"RTN","HMPTFU2",11,0)
 ; CALLED FROM RPC HMP LOCAL GET CORRESPONDINGIDS
"RTN","HMPTFU2",12,0)
 ; PT values :   Source ID^Source ID Type^Assigning Authority^Assigning Facility
"RTN","HMPTFU2",13,0)
 ;  ICN example:   1008520438V882204^NI^USVHA^200M
"RTN","HMPTFU2",14,0)
 ;  DFN example:   100000511^PI^USVHA^500
"RTN","HMPTFU2",15,0)
 ;  EDIPI example: 852043888^NI^USDOD^200DOD
"RTN","HMPTFU2",16,0)
 ;
"RTN","HMPTFU2",17,0)
 ; SOURCE ID:      SOURCE ID is the unique system assigned identifier at the identified facility for the
"RTN","HMPTFU2",18,0)
 ;                 patient record.  The value of SOURCE ID varies, depending on the source facility. 
"RTN","HMPTFU2",19,0)
 ;                 If SOURCE ID is from the Master Patient Index, the value is the Integration 
"RTN","HMPTFU2",20,0)
 ;                 Control Number (ICN).  If SOURCE ID is from the Department of Defense (DOD), the
"RTN","HMPTFU2",21,0)
 ;                 value is the Electronic Data Interchange Personal Identifier (EDIPI), which is 
"RTN","HMPTFU2",22,0)
 ;                 their equivalent of an ICN. In the future, SOURCE ID may come from other sources 
"RTN","HMPTFU2",23,0)
 ;                 due to additional initiatives.
"RTN","HMPTFU2",24,0)
 ;
"RTN","HMPTFU2",25,0)
 ; SOURCE ID TYPE: SOURCE ID TYPE defines the data source for the TREATING FACILITY LIST file (#391.91) entry.
"RTN","HMPTFU2",26,0)
 ;                 The source ID type is a reference to the HL7 Table 0203, Identifier Type, and the VA
"RTN","HMPTFU2",27,0)
 ;                 Identity Management user defined values: NI (National Identifier), PI (Patient Identifier)
"RTN","HMPTFU2",28,0)
 ; 
"RTN","HMPTFU2",29,0)
 ; Return:
"RTN","HMPTFU2",30,0)
 ; This will return the ICN and the list of treating facilities in the following format:
"RTN","HMPTFU2",31,0)
 ;   RESULT(n)=Id^IdType^AssigningFacility^AssigningAuthority^IdStatus
"RTN","HMPTFU2",32,0)
 ;     Examples:
"RTN","HMPTFU2",33,0)
 ;      RESULT(1)="1011232151V598646^NI^200M^A"
"RTN","HMPTFU2",34,0)
 ;      RESULT(2)="7168937^PI^91E3^USVHA^A"
"RTN","HMPTFU2",35,0)
 ;      RESULT(3)="852043888^NI^200DOD^USDOD^A"
"RTN","HMPTFU2",36,0)
 ;
"RTN","HMPTFU2",37,0)
 ; ID STATUS:      ID STATUS supports joint VA/DoD medical centers, Veteran's Record Management (VRM), and Virtual 
"RTN","HMPTFU2",38,0)
 ;                 Lifetime Electronic Record (VLER) initiatives.  This field allows the capture of resolved 
"RTN","HMPTFU2",39,0)
 ;                 duplicate events and exposes the related identifier and identifier status to the consuming 
"RTN","HMPTFU2",40,0)
 ;                 applications. A value of ""A"" indicates that the patient record is an active record on 
"RTN","HMPTFU2",41,0)
 ;                 the identifying system (e.g., VAMC or DoD). A value of "H" indicates that the patient 
"RTN","HMPTFU2",42,0)
 ;                 record was identified as part of a duplicate pair, has been merged, and is no longer active 
"RTN","HMPTFU2",43,0)
 ;                 on the identifying system (e.g., VAMC or DoD).
"RTN","HMPTFU2",44,0)
 ;
"RTN","HMPTFU2",45,0)
 N X,ICN,DFN,EDIPI,ASSIGN,ID,SITE,TYPE,SITEIEN,TFIEN
"RTN","HMPTFU2",46,0)
 ;
"RTN","HMPTFU2",47,0)
 ; Master Patient Index (MPI) must be installed to continue
"RTN","HMPTFU2",48,0)
 S X="MPIF001" X ^%ZOSF("TEST") I '$T S LIST(1)="-1^MPI Not Installed" Q
"RTN","HMPTFU2",49,0)
 ;
"RTN","HMPTFU2",50,0)
 K LIST ; Clear "return" variable
"RTN","HMPTFU2",51,0)
 ;
"RTN","HMPTFU2",52,0)
 ; what do we have
"RTN","HMPTFU2",53,0)
 S TYPE=$P(PT,"^",2) ; SOURCE ID TYPE
"RTN","HMPTFU2",54,0)
 S SITE=$P(PT,"^",4) ; 
"RTN","HMPTFU2",55,0)
 S ID=$P(PT,"^")
"RTN","HMPTFU2",56,0)
 S ASSIGN=$P(PT,"^",3)
"RTN","HMPTFU2",57,0)
 ; check input data
"RTN","HMPTFU2",58,0)
 I ID']"" S LIST(1)="-1^Id is not defined." Q
"RTN","HMPTFU2",59,0)
 I TYPE'="NI",TYPE'="PI" S LIST(1)="-1^Invalid Id Type." Q
"RTN","HMPTFU2",60,0)
 I ASSIGN'="USVHA",ASSIGN'="USDOD" S LIST(1)="-1^Invalid Assigning Authority." Q
"RTN","HMPTFU2",61,0)
 I SITE']"" S LIST(1)="-1^Missing Assigning Facility." Q
"RTN","HMPTFU2",62,0)
 ; find the ien for the station number
"RTN","HMPTFU2",63,0)
 S SITEIEN=$O(^DIC(4,"D",SITE,0))
"RTN","HMPTFU2",64,0)
 I 'SITEIEN S LIST(1)="-1^Assigning Facility is not defined in database." Q
"RTN","HMPTFU2",65,0)
 ;
"RTN","HMPTFU2",66,0)
 I TYPE="PI",ASSIGN="USVHA" S DFN=ID
"RTN","HMPTFU2",67,0)
 I TYPE="NI",ASSIGN="USVHA",SITE="200M" S ICN=ID
"RTN","HMPTFU2",68,0)
 I TYPE="NI",ASSIGN="USDOD",SITE="200DOD" S EDIPI=ID
"RTN","HMPTFU2",69,0)
 I $D(ICN) S DFN=$$GETDFN^MPIF001(ICN) D  Q:$D(LIST(1))
"RTN","HMPTFU2",70,0)
 . I +DFN<0 S LIST(1)="-1^ICN is not known" Q
"RTN","HMPTFU2",71,0)
 . S SITEIEN=$$IEN^XUAF4($P($$SITE^VASITE,"^",3))
"RTN","HMPTFU2",72,0)
 ;
"RTN","HMPTFU2",73,0)
 I $D(DFN) S ICN=$$GETICN^MPIF001(DFN)
"RTN","HMPTFU2",74,0)
 ; DFN should be defined, but ICN may not.
"RTN","HMPTFU2",75,0)
 ;Use new xref AISS appropriately to retrieve DFN from EDIPI
"RTN","HMPTFU2",76,0)
 I $D(EDIPI)=""!(ASSIGN="")!(TYPE="")!(SITEIEN="") S LIST(1)="-1^Insufficient data" Q
"RTN","HMPTFU2",77,0)
 I $D(EDIPI),'$D(^DGCN(391.91,"AISS",EDIPI,ASSIGN,TYPE,SITEIEN)) D  Q
"RTN","HMPTFU2",78,0)
 . S LIST(1)="-1^EDIPI Record is unknown at this facility"
"RTN","HMPTFU2",79,0)
 I $D(EDIPI),$D(^DGCN(391.91,"AISS",EDIPI,ASSIGN,TYPE,SITEIEN)) D
"RTN","HMPTFU2",80,0)
 .S EN=$O(^DGCN(391.91,"AISS",EDIPI,ASSIGN,TYPE,SITEIEN,0))
"RTN","HMPTFU2",81,0)
 .S DFN=$P($G(^DGCN(391.91,EN,0)),"^")
"RTN","HMPTFU2",82,0)
 ;
"RTN","HMPTFU2",83,0)
 ; if ICN is not defined, it is OK, but DFN should be defined
"RTN","HMPTFU2",84,0)
 ; bad input, such as Id^NI^USVHA^123
"RTN","HMPTFU2",85,0)
 I '$G(DFN) S LIST(1)="-1^Invalid input" Q
"RTN","HMPTFU2",86,0)
 ; check DFN and Site to be matching an entry in file #391.91
"RTN","HMPTFU2",87,0)
 I '$O(^DGCN(391.91,"APAT",DFN,SITEIEN,0)) D  Q
"RTN","HMPTFU2",88,0)
 . S LIST(1)="-1^Id as '"_ID_"'"_" is not in database"
"RTN","HMPTFU2",89,0)
 ; DFN should be defined, but ICN may not.
"RTN","HMPTFU2",90,0)
 S X=$$QUERYTF($P($G(ICN),"V"),"LIST")
"RTN","HMPTFU2",91,0)
 I $P(X,U)="1" S LIST(1)="-1"_U_$P(X,U,2) Q
"RTN","HMPTFU2",92,0)
 Q
"RTN","HMPTFU2",93,0)
 ;
"RTN","HMPTFU2",94,0)
GETICN(EDIPI) ;return the ICN when EDIPI is passed
"RTN","HMPTFU2",95,0)
 N EN,DFN,ICN,IEN
"RTN","HMPTFU2",96,0)
 S IEN=$$IEN^XUAF4("200DOD")
"RTN","HMPTFU2",97,0)
 I 'IEN Q "-1^Unknown Assigning Facility."
"RTN","HMPTFU2",98,0)
 I '$D(^DGCN(391.91,"ASCR",EDIPI,IEN)) Q "-1^EDIPI Record is unknown at this facility"
"RTN","HMPTFU2",99,0)
 I $D(^DGCN(391.91,"ASCR",EDIPI,IEN)) D
"RTN","HMPTFU2",100,0)
 .S EN=$O(^DGCN(391.91,"ASCR",EDIPI,$$IEN^XUAF4("200DOD"),""))
"RTN","HMPTFU2",101,0)
 .S DFN=$P($G(^DGCN(391.91,EN,0)),"^")
"RTN","HMPTFU2",102,0)
 .I DFN'="" S ICN=$$GETICN^MPIF001(DFN)
"RTN","HMPTFU2",103,0)
 .I DFN="" S ICN="-1^No Site Record associated with this entry"
"RTN","HMPTFU2",104,0)
 Q ICN
"RTN","HMPTFU2",105,0)
 ;
"RTN","HMPTFU2",106,0)
QUERYTF(PAT,ARY) ;a query for Treating Facility.
"RTN","HMPTFU2",107,0)
 ;INPUT   PAT - The patient's ICN
"RTN","HMPTFU2",108,0)
 ;        ARY - The array in which to return the Treating facility info.
"RTN","HMPTFU2",109,0)
 ;OUTPUT  A list of the Treating Facilities in the array provided from
"RTN","HMPTFU2",110,0)
 ;        the parameter.  It will be in the structure of x(1), x(2) etc.
"RTN","HMPTFU2",111,0)
 ;  Ex  X(1)=<ID> ^ <ID TYPE> ^ <Assigning Authority> ^ <Assigning Facility> ^ <ID Status>
"RTN","HMPTFU2",112,0)
 ;
"RTN","HMPTFU2",113,0)
 ; This is also a function call.  If there is an error then "1^error description" will be returned. 
"RTN","HMPTFU2",114,0)
 ; If no data is found the array will not be populated and "1^error description" will be returned.
"RTN","HMPTFU2",115,0)
 ;
"RTN","HMPTFU2",116,0)
 N PDFN,HMPER,LP,CTR
"RTN","HMPTFU2",117,0)
 ;
"RTN","HMPTFU2",118,0)
 ; ICN is not required
"RTN","HMPTFU2",119,0)
 I ('$D(ARY)) S HMPER="1^Parameter missing." G QUERYTFQ
"RTN","HMPTFU2",120,0)
 S HMPER=0,CTR=1
"RTN","HMPTFU2",121,0)
 S X="MPIF001" X ^%ZOSF("TEST") I '$T G QUERYTFQ
"RTN","HMPTFU2",122,0)
 S PDFN=$G(DFN)
"RTN","HMPTFU2",123,0)
 I '$G(PDFN) S HMPER="1^DFN is not defined." G QUERYTFQ
"RTN","HMPTFU2",124,0)
 ;SET FIRST ENTRY TO BE THE ICN - FULL ICN - PAT IS NOT THE ICN
"RTN","HMPTFU2",125,0)
 S @ARY@(CTR)=$$GETICN^MPIF001(PDFN)_"^NI^200M^USVHA^A"
"RTN","HMPTFU2",126,0)
 ;**856 - MVI 1371 (ckn)
"RTN","HMPTFU2",127,0)
 ;Loop through all TFIENs for site
"RTN","HMPTFU2",128,0)
 ;F LP=0:0 S LP=$O(^DGCN(391.91,"APAT",PDFN,LP)) Q:'LP  S TFIEN=$O(^(LP,"")) D SET(TFIEN,ARY,.CTR)
"RTN","HMPTFU2",129,0)
 F LP=0:0 S LP=$O(^DGCN(391.91,"APAT",PDFN,LP)) Q:'LP  D
"RTN","HMPTFU2",130,0)
 .S TFIEN=0 F  S TFIEN=$O(^DGCN(391.91,"APAT",PDFN,LP,TFIEN)) Q:'TFIEN  D
"RTN","HMPTFU2",131,0)
 ..D SET(TFIEN,ARY,.CTR)
"RTN","HMPTFU2",132,0)
 I $D(@ARY)'>9 S HMPER="1^Could not find Treating Facilities"
"RTN","HMPTFU2",133,0)
QUERYTFQ Q HMPER
"RTN","HMPTFU2",134,0)
 ;
"RTN","HMPTFU2",135,0)
SET(TFIEN,ARY,CTR) ;This sets the array with the treating facility list.
"RTN","HMPTFU2",136,0)
 ;  Ex  ARY(1)=<ID> ^ <ID TYPE> ^ <Assigning Facility> ^ <Assigning Authority> ^ <ID Status>
"RTN","HMPTFU2",137,0)
 N DGCN,INSTIEN,SOURCE,EN,SDFN,STATUS,SITEN,ID,IDTYPE,SITE,ASSAUTH,FOUND,NODE,NODE0,NODE2
"RTN","HMPTFU2",138,0)
 S DGCN(0)=$G(^DGCN(391.91,TFIEN,0)),SITEN=""
"RTN","HMPTFU2",139,0)
 ;
"RTN","HMPTFU2",140,0)
 S INSTIEN=$P($G(DGCN(0)),"^",2) ;            TREATING FACILITY LIST (#391.91) INSTITUTION field (#.02)
"RTN","HMPTFU2",141,0)
 I INSTIEN'="" S SITEN=$$STA^XUAF4(INSTIEN) ; STATION from Institution IEN
"RTN","HMPTFU2",142,0)
 S ID=$P(DGCN(0),"^") ;                       ID=Patient DFN field (#.01)
"RTN","HMPTFU2",143,0)
 ;
"RTN","HMPTFU2",144,0)
 S NODE2=$G(^DGCN(391.91,TFIEN,2))
"RTN","HMPTFU2",145,0)
 S SDFN=$P(NODE2,"^",2) ; SDFN="SOURCE ID"
"RTN","HMPTFU2",146,0)
 S STATUS=$P(NODE2,"^",3) ; STATUS="IDENTIFIER STATUS"
"RTN","HMPTFU2",147,0)
 S ASSAUTH=$P(NODE2,"^") ; Assigning Authority
"RTN","HMPTFU2",148,0)
 ;
"RTN","HMPTFU2",149,0)
 S NODE0=$G(^DGCN(391.91,TFIEN,0))
"RTN","HMPTFU2",150,0)
 S IDTYPE=$P(NODE0,"^",9) ; SOURCE ID TYPE
"RTN","HMPTFU2",151,0)
 ;
"RTN","HMPTFU2",152,0)
 I SITEN="200DOD"!(SITEN["200N") S IDTYPE="NI"
"RTN","HMPTFU2",153,0)
 I SITEN="200DOD" S ASSAUTH="USDOD"
"RTN","HMPTFU2",154,0)
 I IDTYPE="" S IDTYPE="PI"
"RTN","HMPTFU2",155,0)
 I ASSAUTH="" S ASSAUTH="USVHA"
"RTN","HMPTFU2",156,0)
 I SITEN["200N"&(IDTYPE="NI")&(ASSAUTH="USVHA") S ASSAUTH=""
"RTN","HMPTFU2",157,0)
 I IDTYPE="PI" S SITEN=$$TF2SITEN(TFIEN) Q:SITEN=""
"RTN","HMPTFU2",158,0)
 ;
"RTN","HMPTFU2",159,0)
 ; If VA Internal Patient ID, get site hash from domain associated with Treating Facility
"RTN","HMPTFU2",160,0)
 S NODE0=$G(^DGCN(391.91,TFIEN,0))
"RTN","HMPTFU2",161,0)
 S NODE2=$G(^DGCN(391.91,TFIEN,2))
"RTN","HMPTFU2",162,0)
 S SDFN=$P(NODE2,"^",2),STATUS=$P(NODE2,"^",3),IDTYPE=$P(NODE0,"^",9)
"RTN","HMPTFU2",163,0)
 ; DE2345 - MBS 9/15/2015; Only return active entries
"RTN","HMPTFU2",164,0)
 I STATUS'="A" Q
"RTN","HMPTFU2",165,0)
 S ASSAUTH=$P(NODE2,"^")
"RTN","HMPTFU2",166,0)
 I SITEN="200DOD"!(SITEN["200N") S IDTYPE="NI"
"RTN","HMPTFU2",167,0)
 I SITEN="200DOD" S ASSAUTH="USDOD"
"RTN","HMPTFU2",168,0)
 I IDTYPE="" S IDTYPE="PI"
"RTN","HMPTFU2",169,0)
 I ASSAUTH="" S ASSAUTH="USVHA"
"RTN","HMPTFU2",170,0)
 I SITEN["200N"&(IDTYPE="NI")&(ASSAUTH="USVHA") S ASSAUTH=""
"RTN","HMPTFU2",171,0)
 I SDFN'="" S CTR=CTR+1,@ARY@(CTR)=SDFN_"^"_IDTYPE_"^"_SITEN_"^"_ASSAUTH_"^"_STATUS,FOUND=1
"RTN","HMPTFU2",172,0)
 Q
"RTN","HMPTFU2",173,0)
TF2SITEN(TFIEN) ;Find the DOMAIN associated with the TREATING FACILITY and return the station number.
"RTN","HMPTFU2",174,0)
 ;Currently, our test systems' station numbers are not set up for local DOMAINs. This would result in these
"RTN","HMPTFU2",175,0)
 ;entries failing all the time, thus breaking existing behavior. For the time being, we will default to
"RTN","HMPTFU2",176,0)
 ;the old behavior if we cannot locate a station number as a temporary measure. In the future, we need to
"RTN","HMPTFU2",177,0)
 ;fix the test systems to set up the station numbers correctly, and then change this code to return
"RTN","HMPTFU2",178,0)
 ;an empty string if the DOMAIN could not be resolved.
"RTN","HMPTFU2",179,0)
 S SITEN=""
"RTN","HMPTFU2",180,0)
 Q:'+$G(TFIEN) ""
"RTN","HMPTFU2",181,0)
 Q:'$D(^DGCN(391.91,TFIEN)) ""
"RTN","HMPTFU2",182,0)
 ;Get station number from Institution file (pointed to from Treating Facility List)
"RTN","HMPTFU2",183,0)
 N INSTNUM,STNNUM,DONE,I
"RTN","HMPTFU2",184,0)
 S INSTNUM=$P($G(^DGCN(391.91,TFIEN,0)),U,2) Q:'+INSTNUM SITEN
"RTN","HMPTFU2",185,0)
 S STNNUM=$P($G(^DIC(4,INSTNUM,99)),U) Q:'+STNNUM SITEN
"RTN","HMPTFU2",186,0)
 ;DE2345 - MBS 9/15/2015; Do not return entries with station numbers=+200
"RTN","HMPTFU2",187,0)
 I STNNUM?1"200".A Q ""
"RTN","HMPTFU2",188,0)
 ;Domain file doesn't have an x-ref on station number, so we have to brute-force it
"RTN","HMPTFU2",189,0)
 S (I,DONE)=0 F  S I=$O(^DIC(4.2,I)) Q:'+I  D  Q:DONE
"RTN","HMPTFU2",190,0)
 . I $P(^DIC(4.2,I,0),U,13)=STNNUM S SITEN=$$SYS^HMPUTILS($P(^DIC(4.2,I,0),U)),DONE=1
"RTN","HMPTFU2",191,0)
 Q SITEN
"RTN","HMPTFU2",192,0)
 ;
"RTN","HMPUPD")
0^86^B25062781^B25123694
"RTN","HMPUPD",1,0)
HMPUPD ;SLC/MKB,ASMR/RRB,CK - Update local data ;May 15, 2016 14:15
"RTN","HMPUPD",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPUPD",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPUPD",4,0)
 ;
"RTN","HMPUPD",5,0)
 Q
"RTN","HMPUPD",6,0)
 ;
"RTN","HMPUPD",7,0)
PHONE(HMP,JSON) ; RPC = HMP PUT PHONE
"RTN","HMPUPD",8,0)
 Q
"RTN","HMPUPD",9,0)
PUT(HMP,DFN,CMD,JSON) ; -- update phone numbers
"RTN","HMPUPD",10,0)
 ; RPC = HMP PUT DEMOGRAPHICS
"RTN","HMPUPD",11,0)
 ;
"RTN","HMPUPD",12,0)
 N ARRAY,HMPERR,ERR,HOME,CELL,WORK,NOK,ECON,X,OK,HMPSYS
"RTN","HMPUPD",13,0)
 S HMPSYS=$$SYS^HMPUTILS
"RTN","HMPUPD",14,0)
 D DECODE^HMPJSON("JSON","ARRAY","HMPERR")
"RTN","HMPUPD",15,0)
 I $D(HMPERR) D  G PQ
"RTN","HMPUPD",16,0)
 . K ARRAY N HMPTMP,HMPTXT
"RTN","HMPUPD",17,0)
 . S HMPTXT(1)="Problem decoding json input."
"RTN","HMPUPD",18,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.JSON)
"RTN","HMPUPD",19,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","ARRAY","HMPERR")
"RTN","HMPUPD",20,0)
 . S HMP(.5)="{""apiVersion"":""1.01"",""error"":{"
"RTN","HMPUPD",21,0)
 . M HMP(1)=ARRAY
"RTN","HMPUPD",22,0)
 . S HMP(2)="}}"
"RTN","HMPUPD",23,0)
 ;
"RTN","HMPUPD",24,0)
 S DFN=+$G(DFN) I DFN<1 S ERR=$$ERR(1,DFN) G PHQ
"RTN","HMPUPD",25,0)
 S CMD=$G(CMD) ;can only update phone#
"RTN","HMPUPD",26,0)
 N HMPX,HMPDR,I,J S (HMPDR,HOME,CELL,WORK,NOK,ECON)=""
"RTN","HMPUPD",27,0)
 D VAL("old")
"RTN","HMPUPD",28,0)
 S I="" F  S I=$O(ARRAY("telecom",I)) Q:I<1  D
"RTN","HMPUPD",29,0)
 . I $G(ARRAY("telecom",I,"use"))="H" D  Q
"RTN","HMPUPD",30,0)
 .. S HOME=$G(ARRAY("telecom",I,"value"))
"RTN","HMPUPD",31,0)
 .. I HOME=HOME("old") S HOME="" Q           ;no change
"RTN","HMPUPD",32,0)
 .. I "@"[HOME S:$L(HOME("old")) HOME="@" Q  ;delete
"RTN","HMPUPD",33,0)
 .. S HOME=$$FORMAT(HOME),ARRAY("telecom",I,"value")=HOME
"RTN","HMPUPD",34,0)
 . I $G(ARRAY("telecom",I,"use"))="MC" D  Q
"RTN","HMPUPD",35,0)
 .. S CELL=$G(ARRAY("telecom",I,"value"))
"RTN","HMPUPD",36,0)
 .. I CELL=CELL("old") S CELL="" Q           ;no change
"RTN","HMPUPD",37,0)
 .. I "@"[CELL S:$L(CELL("old")) CELL="@" Q  ;delete
"RTN","HMPUPD",38,0)
 .. S CELL=$$FORMAT(CELL),ARRAY("telecom",I,"value")=CELL
"RTN","HMPUPD",39,0)
 . I $G(ARRAY("telecom",I,"use"))="WP" D  Q
"RTN","HMPUPD",40,0)
 .. S WORK=$G(ARRAY("telecom",I,"value"))
"RTN","HMPUPD",41,0)
 .. I WORK=WORK("old") S WORK="" Q           ;no change
"RTN","HMPUPD",42,0)
 .. I "@"[WORK S:$L(WORK("old")) WORK="@" Q  ;delete
"RTN","HMPUPD",43,0)
 .. S WORK=$$FORMAT(WORK),ARRAY("telecom",I,"value")=WORK
"RTN","HMPUPD",44,0)
 S I="" F  S I=$O(ARRAY("contact",I)) Q:I<1  D
"RTN","HMPUPD",45,0)
 . S X=$P($G(ARRAY("contact",I,"typeCode")),":",4) Q:X=""  ;NOK or ECON
"RTN","HMPUPD",46,0)
 . S J="" F  S J=$O(ARRAY("contact",I,"telecom",J)) Q:J<1  D
"RTN","HMPUPD",47,0)
 .. Q:$G(ARRAY("contact",I,"telecom",J,"use"))'="H"
"RTN","HMPUPD",48,0)
 .. S @X=$G(ARRAY("contact",I,"telecom",J,"value"))
"RTN","HMPUPD",49,0)
 .. I @X=@X@("old") S @X="" Q           ;no change
"RTN","HMPUPD",50,0)
 .. I "@"[@X S:$L(@X@("old")) @X="@" Q  ;delete
"RTN","HMPUPD",51,0)
 .. S @X=$$FORMAT(@X),ARRAY("contact",I,"telecom",J,"value")=@X
"RTN","HMPUPD",52,0)
 .. ; X="NOK" S NOK=$$FORMAT(NOK),ARRAY("contact",I,"telecom",J,"value")=NOK
"RTN","HMPUPD",53,0)
 ;
"RTN","HMPUPD",54,0)
 S:$L(HOME) HMPX(.131)=HOME,HMPDR=".131"
"RTN","HMPUPD",55,0)
 S:$L(CELL) HMPX(.134)=CELL,HMPDR=HMPDR_$S($L(HMPDR):";",1:"")_".134"
"RTN","HMPUPD",56,0)
 S:$L(WORK) HMPX(.132)=WORK,HMPDR=HMPDR_$S($L(HMPDR):";",1:"")_".132"
"RTN","HMPUPD",57,0)
 S:$L(ECON) HMPX(.339)=ECON,HMPDR=HMPDR_$S($L(HMPDR):";",1:"")_".339"
"RTN","HMPUPD",58,0)
 S:$L(NOK) HMPX(.219)=NOK,HMPDR=HMPDR_$S($L(HMPDR):";",1:"")_".219"
"RTN","HMPUPD",59,0)
 I '$O(HMPX(0)) S ERR=$$ERR(3) G PHQ
"RTN","HMPUPD",60,0)
 D EDIT^VAFCPTED(DFN,"HMPX",HMPDR)
"RTN","HMPUPD",61,0)
 S X=$G(^DPT(DFN,.13)),OK=1 D  ;check global ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",62,0)
 . I $L(HOME),$S(HOME="@":$L($P(X,U)),1:(HMPX(.131)'=$P(X,U))) S OK=0
"RTN","HMPUPD",63,0)
 . I $L(CELL),$S(CELL="@":$L($P(X,U,4)),1:(HMPX(.134)'=$P(X,U,4))) S OK=0
"RTN","HMPUPD",64,0)
 . I $L(WORK),$S(WORK="@":$L($P(X,U,2)),1:(HMPX(.132)'=$P(X,U,2))) S OK=0
"RTN","HMPUPD",65,0)
 . I $L(ECON) S X=$G(^DPT(DFN,.33)) I $S(ECON="@":$L($P(X,U,9)),1:(HMPX(.339)'=$P(X,U,9))) S OK=0 ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",66,0)
 . I $L(NOK) S X=$G(^DPT(DFN,.21)) I $S(NOK="@":$L($P(X,U,9)),1:(HMPX(.219)'=$P(X,U,9))) S OK=0 ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",67,0)
 S:'OK ERR=$$ERR(5)
"RTN","HMPUPD",68,0)
 ;
"RTN","HMPUPD",69,0)
PHQ ; add item count and terminating characters
"RTN","HMPUPD",70,0)
 I $D(ERR) S HMP(1)="{""apiVersion"":""1.01"",""error"":{""message"":"""_ERR_"""},""success"":false}" G PQ
"RTN","HMPUPD",71,0)
 ; HMP="{""apiVersion"":""1.01"",""data"":{""updated"":"_""""_$$HL7NOW_""""_",""localId"":"""_DFN_"""},""success"":true}"
"RTN","HMPUPD",72,0)
 D POSTX^HMPEVNT("patient",DFN)
"RTN","HMPUPD",73,0)
 D ENCODE^HMPJSON("ARRAY","HMP","HMPERR")
"RTN","HMPUPD",74,0)
 I $D(HMPERR) D  G PQ
"RTN","HMPUPD",75,0)
 . K HMP N HMPTMP,HMPTXT
"RTN","HMPUPD",76,0)
 . S HMPTXT(1)="Problem encoding json output."
"RTN","HMPUPD",77,0)
 . D SETERROR^HMPUTILS(.HMPTMP,.HMPERR,.HMPTXT,.ARRAY)
"RTN","HMPUPD",78,0)
 . K HMPERR D ENCODE^HMPJSON("HMPTMP","HMP","HMPERR")
"RTN","HMPUPD",79,0)
 . S HMP(.5)="{""apiVersion"":""1.01"",""error"":{",HMP(99)="}}"
"RTN","HMPUPD",80,0)
 S HMP(.5)="{""apiVersion"":""1.01"",""params"":{"_$$SYS^HMPDJ_"},""success"":true,"
"RTN","HMPUPD",81,0)
 S HMP(.6)="""data"":{""updated"":"""_$$HL7NOW^HMPDJ_""",""totalItems"":1,""items"":["
"RTN","HMPUPD",82,0)
 S HMP(99)="]}}"
"RTN","HMPUPD",83,0)
PQ ; exit
"RTN","HMPUPD",84,0)
 K ^TMP($J,"HMP")
"RTN","HMPUPD",85,0)
 M ^TMP($J,"HMP")=HMP
"RTN","HMPUPD",86,0)
 K HMP S HMP=$NA(^TMP($J,"HMP"))
"RTN","HMPUPD",87,0)
 Q
"RTN","HMPUPD",88,0)
 ;
"RTN","HMPUPD",89,0)
FORMAT(X) ; -- enforce (xxx)xxx-xxxx phone format
"RTN","HMPUPD",90,0)
 S X=$G(X) I X?1"("3N1")"3N1"-"4N.E Q X
"RTN","HMPUPD",91,0)
 N P,N,I,Y S P=""
"RTN","HMPUPD",92,0)
 F I=1:1:$L(X) S N=$E(X,I) I N=+N S P=P_N
"RTN","HMPUPD",93,0)
 S:$L(P)<10 P=$E("0000000000",1,10-$L(P))_P
"RTN","HMPUPD",94,0)
 S Y=$S(P:"("_$E(P,1,3)_")"_$E(P,4,6)_"-"_$E(P,7,10),1:"")
"RTN","HMPUPD",95,0)
 Q Y
"RTN","HMPUPD",96,0)
 ;
"RTN","HMPUPD",97,0)
HL7NOW() ; -- Return current time in HL7 format
"RTN","HMPUPD",98,0)
 Q $P($$FMTHL7^XLFDT($$NOW^XLFDT),"-")
"RTN","HMPUPD",99,0)
 ;
"RTN","HMPUPD",100,0)
ERR(X,VAL) ; -- return error message
"RTN","HMPUPD",101,0)
 N MSG  S MSG="Error"
"RTN","HMPUPD",102,0)
 I X=1  S MSG="Patient with dfn '"_$G(VAL)_"' not found"
"RTN","HMPUPD",103,0)
 I X=2  S MSG="Domain type '"_$G(VAL)_"' not recognized"
"RTN","HMPUPD",104,0)
 I X=3  S MSG="Data not changed"
"RTN","HMPUPD",105,0)
 I X=4  S MSG="Unable to create new object"
"RTN","HMPUPD",106,0)
 I X=5  S MSG="Update failed"
"RTN","HMPUPD",107,0)
 I X=99 S MSG="Unknown request"
"RTN","HMPUPD",108,0)
 Q MSG
"RTN","HMPUPD",109,0)
 ;
"RTN","HMPUPD",110,0)
VAL(SUB) ; -- pull values from ^DPT
"RTN","HMPUPD",111,0)
 N X S X=$G(^DPT(DFN,.13)) ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",112,0)
 S HOME(SUB)=$P(X,U),CELL(SUB)=$P(X,U,4),WORK(SUB)=$P(X,U,2)
"RTN","HMPUPD",113,0)
 S X=$G(^DPT(DFN,.33)),ECON(SUB)=$P(X,U,9) ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",114,0)
 S X=$G(^DPT(DFN,.21)),NOK(SUB)=$P(X,U,9) ;ICR 10035 DE2818 ASF 11/12/15
"RTN","HMPUPD",115,0)
 Q
"RTN","HMPUTIL1")
0^87^B46934983^B42764058
"RTN","HMPUTIL1",1,0)
HMPUTIL1 ;SLC/AGP,ASMR/RRB,CPC - HMP utilities routine ;May 15, 2016 14:15
"RTN","HMPUTIL1",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPUTIL1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPUTIL1",4,0)
 ;
"RTN","HMPUTIL1",5,0)
 Q
"RTN","HMPUTIL1",6,0)
 ;
"RTN","HMPUTIL1",7,0)
 ; ADHOC subroutine refactored for DE1788
"RTN","HMPUTIL1",8,0)
ADHOC(HMPDMINP,HMPFCNT,DFN) ; Add syncStart metastamp and syncStatus to unsolicited updates
"RTN","HMPUTIL1",9,0)
 Q:($G(HMPDMINP)="")!($G(DFN)="")  ; domain and DFN required
"RTN","HMPUTIL1",10,0)
 ; HMPFCNT = count of objects, passed by ref.
"RTN","HMPUTIL1",11,0)
 ; expects HMPFSTR (set in HMPDJFSG) is ^XTMP freshness stream subscript 
"RTN","HMPUTIL1",12,0)
 ; the heading from APIHDR^HMPDJFSG is in ^TMP("HMPF",$J) already
"RTN","HMPUTIL1",13,0)
 ; the JSON built here is placed inside a JSON array, with a '[' after the heading
"RTN","HMPUTIL1",14,0)
 ;
"RTN","HMPUTIL1",15,0)
 N HMPA4JSN,HMPDAT,HMPDMTOT,HMPDOM,HMPID,HMPJSERR,HMPJSON,HMPSUB,I,J,LSTLN,QTE,SUB,X,Y,DELJSON
"RTN","HMPUTIL1",16,0)
 N HMPJSNSY
"RTN","HMPUTIL1",17,0)
 ; HMPA4JSN, HMPJSON, HMPJSERR - used for JSON encoder
"RTN","HMPUTIL1",18,0)
 ; HMPA4JSN - array to encode
"RTN","HMPUTIL1",19,0)
 ; HMPJSON - JSON result
"RTN","HMPUTIL1",20,0)
 ; HMPJSERR - error text from encoder
"RTN","HMPUTIL1",21,0)
 ; QTE - " character
"RTN","HMPUTIL1",22,0)
 ; HMPJSNSY - The system id value for the JSON Encoder, If fully numeric it needs a " prepended
"RTN","HMPUTIL1",23,0)
 S HMPDAT("DELDATE")="",QTE=$C(34)
"RTN","HMPUTIL1",24,0)
 S HMPDMTOT=0  ; domain total
"RTN","HMPUTIL1",25,0)
 ; Save delete date/time for later use.
"RTN","HMPUTIL1",26,0)
 I $G(ACT)="@" D
"RTN","HMPUTIL1",27,0)
 . D  ;DE4307 get from freshness save if available
"RTN","HMPUTIL1",28,0)
 ..  I +$G(FILTER("freshnessDateTime")) S HMPDAT("DELDATE")=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime")) Q
"RTN","HMPUTIL1",29,0)
 ..  S Y=$$FMTH^XLFDT($P(HMPFSTRM,"~",3))  ; Get the date from fresh stream (HMPFS~<server>~<date>)
"RTN","HMPUTIL1",30,0)
 ..  S Y=$$HTFM^XLFDT($P(Y,",")_","_$G(ARGS("hmp-fst"),0))  ; Add delete time stored in ARGS("hmp-fst")
"RTN","HMPUTIL1",31,0)
 ..  S HMPDAT("DELDATE")=$$JSONDT^HMPUTILS(Y)  ; delete date/time into JSON format
"RTN","HMPUTIL1",32,0)
 . S DELJSON="{""pid"":"""_$$PID^HMPDJFS(DFN)_""",""removed"":""true"",""stampTime"":"_HMPDAT("DELDATE")_",""uid"":"""_$G(HMP97)_"""}"
"RTN","HMPUTIL1",33,0)
 ;
"RTN","HMPUTIL1",34,0)
 S HMPA4JSN=$NA(^TMP($J,"ARRAY4JSON")) K @HMPA4JSN ; data array for JSON
"RTN","HMPUTIL1",35,0)
 S HMPJSON=$NA(^TMP($J,"JSONRESULT")) K @HMPJSON  ; JSON result
"RTN","HMPUTIL1",36,0)
 ;
"RTN","HMPUTIL1",37,0)
 S HMPDAT("STAMPTIME")=$$EN^HMPSTMP("NOW"),HMPID=$$SYS^HMPUTILS,HMPJSNSY=$S(+HMPID=HMPID:""""_HMPID,1:HMPID)
"RTN","HMPUTIL1",38,0)
 ;
"RTN","HMPUTIL1",39,0)
 D:DFN'="OPD"  ; get PID data for patient
"RTN","HMPUTIL1",40,0)
 .N ITM,VAL  ; $$PIDS returns: ,"pid":"9E4B;3","systemId":"9E4B","localId":"3","icn":"10207V420718"
"RTN","HMPUTIL1",41,0)
 .S Y=$$PIDS^HMPDJFS(DFN)  ; parse Y, remove quotes save values in HMPID('item')
"RTN","HMPUTIL1",42,0)
 .F J=2:1:$L(Y,",") S X=$P(Y,",",J),ITM=$TR($P(X,":"),QTE),VAL=$TR($P(X,":",2),QTE) S:ITM]"" HMPID(ITM)=VAL
"RTN","HMPUTIL1",43,0)
 ;
"RTN","HMPUTIL1",44,0)
 ; transform domain name for quick orders to match the uid
"RTN","HMPUTIL1",45,0)
 S HMPDOM=HMPDMINP I HMPDOM="quick" S HMPDOM="qo"
"RTN","HMPUTIL1",46,0)
 ;
"RTN","HMPUTIL1",47,0)
 ; stamp time put into HMPDAT("STAMPTIME")
"RTN","HMPUTIL1",48,0)
 S HMPSUB=""
"RTN","HMPUTIL1",49,0)
 S HMPDAT("STAMPTIME")=""
"RTN","HMPUTIL1",50,0)
 F  S HMPSUB=$O(^TMP("HMP",$J,HMPSUB)) Q:'HMPSUB  D
"RTN","HMPUTIL1",51,0)
 .N DONE,HMPN,NEXT,SRCH,HMPDATP ;cpc 2015/10/21
"RTN","HMPUTIL1",52,0)
 .S SRCH="""uid"""_":"_""""_"urn:va:"_HMPDOM_":"
"RTN","HMPUTIL1",53,0)
 .; Search back from last record - but include start of next to cover crossovers
"RTN","HMPUTIL1",54,0)
 .S HMPDAT="" ;cpc 2015/10/21
"RTN","HMPUTIL1",55,0)
 .S HMPN="",HMPDAT("UID")="",DONE=""
"RTN","HMPUTIL1",56,0)
 .F  S HMPN=$O(^TMP("HMP",$J,HMPSUB,HMPN),-1) Q:'HMPN  D  Q:DONE
"RTN","HMPUTIL1",57,0)
 ..S HMPDATP=$E(HMPDAT,1,100) ;cpc 2015/10/21
"RTN","HMPUTIL1",58,0)
 ..S HMPDAT=$G(^TMP("HMP",$J,HMPSUB,HMPN)) Q:HMPDAT="null"!'$L(HMPDAT)
"RTN","HMPUTIL1",59,0)
 ..S HMPDAT=HMPDAT_HMPDATP ;cpc 2015/10/21 - look for crossover data
"RTN","HMPUTIL1",60,0)
 ..;Search for last occurrence of uid in record (this will be parent)
"RTN","HMPUTIL1",61,0)
 ..I '$G(HMPDAT(HMPSUB,"UID")),$F(HMPDAT,SRCH) F I=2:1 S NEXT=$P($P(HMPDAT,SRCH,I),QTE) Q:NEXT=""  S HMPDAT(HMPSUB,"UID")=NEXT ;cpc 2015/10/21
"RTN","HMPUTIL1",62,0)
 ..;BL;CPC Extract stamptime if present (patient data ONLY)
"RTN","HMPUTIL1",63,0)
 ..;cpc 2015/10/09 - conditionalize tests
"RTN","HMPUTIL1",64,0)
 ..I '$G(HMPDAT(HMPSUB,"STAMPTIME")),$F(HMPDAT,"stampTime") D  ;cpc 2015/10/21
"RTN","HMPUTIL1",65,0)
 ...S HMPDAT(HMPSUB,"STAMPTIME")=$P($P(HMPDAT,"""stampTime"":",2),",")
"RTN","HMPUTIL1",66,0)
 ...;Keep the latest stamptime so that we can use it for the overall metastamp
"RTN","HMPUTIL1",67,0)
 ...I HMPDAT(HMPSUB,"STAMPTIME")>HMPDAT("STAMPTIME") S HMPDAT("STAMPTIME")=HMPDAT(HMPSUB,"STAMPTIME")
"RTN","HMPUTIL1",68,0)
 ..;Patient data requires both UID and stampTime to be complete
"RTN","HMPUTIL1",69,0)
 ..S:$G(HMPDAT(HMPSUB,"UID"))&$G(HMPDAT(HMPSUB,"STAMPTIME")) DONE=1
"RTN","HMPUTIL1",70,0)
 ..;cpc 2015/10/09 - end
"RTN","HMPUTIL1",71,0)
 ;
"RTN","HMPUTIL1",72,0)
 ; HMP97 is uid, SET in FRESHITM^HMPDJFSG
"RTN","HMPUTIL1",73,0)
 I $G(ACT)="@" S HMPDAT("UID")=$P($G(HMP97),":",4,99)
"RTN","HMPUTIL1",74,0)
 ;
"RTN","HMPUTIL1",75,0)
 S @HMPA4JSN@("collection")=$S(DFN="OPD":"OPDsyncStart",1:"syncStart")
"RTN","HMPUTIL1",76,0)
 I DFN="OPD" S @HMPA4JSN@("systemId")=$P(HMPID,";") ; set systemId for OPD
"RTN","HMPUTIL1",77,0)
 S X="" F  S X=$O(HMPID(X)) Q:X=""  S @HMPA4JSN@(X)=HMPID(X)  ; add pid, systemId, localId, icn
"RTN","HMPUTIL1",78,0)
 ;
"RTN","HMPUTIL1",79,0)
 ;DE4307 - if stamptime still doesn't exist then get from freshness
"RTN","HMPUTIL1",80,0)
 I '+HMPDAT("STAMPTIME"),+$G(FILTER("freshnessDateTime")) S HMPDAT("STAMPTIME")=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime"))
"RTN","HMPUTIL1",81,0)
 ; build metastamp components
"RTN","HMPUTIL1",82,0)
 S SUB="metaStamp"
"RTN","HMPUTIL1",83,0)
 S X="" F  S X=$O(HMPID(X)) Q:X=""  S @HMPA4JSN@(SUB,X)=HMPID(X)  ; add pid, systemId, localId, icn
"RTN","HMPUTIL1",84,0)
 S @HMPA4JSN@(SUB,"stampTime")=HMPDAT("STAMPTIME")
"RTN","HMPUTIL1",85,0)
 ;
"RTN","HMPUTIL1",86,0)
 S SUB(1)="sourceMetaStamp",X=""
"RTN","HMPUTIL1",87,0)
 F  S X=$O(HMPID(X)) Q:X=""  S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,X)=HMPID(X)  ; add pid, systemId, localId, icn ;de4757 use stringed version of system
"RTN","HMPUTIL1",88,0)
 S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,"stampTime")=HMPDAT("STAMPTIME")
"RTN","HMPUTIL1",89,0)
 ;
"RTN","HMPUTIL1",90,0)
 S SUB(2)="domainMetaStamp"
"RTN","HMPUTIL1",91,0)
 S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,SUB(2),HMPDOM,"domain")=HMPDOM
"RTN","HMPUTIL1",92,0)
 S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,SUB(2),HMPDOM,"stampTime")=$S($L($G(HMPDAT("DELDATE"))):HMPDAT("DELDATE"),1:HMPDAT("STAMPTIME"))
"RTN","HMPUTIL1",93,0)
 ;
"RTN","HMPUTIL1",94,0)
 ; Loop through HMPSUB to generate the eventMetastamp
"RTN","HMPUTIL1",95,0)
 S SUB(3)=$S(DFN="OPD":"itemMetaStamp",1:"eventMetaStamp"),HMPSUB="" ;cpc 2015/10/22
"RTN","HMPUTIL1",96,0)
 F  S HMPSUB=$O(HMPDAT(HMPSUB)) Q:'HMPSUB  D
"RTN","HMPUTIL1",97,0)
 .S SUB(4)="urn:va:"_HMPDOM_":"_$S($G(ACT)="@":HMPDAT("UID"),1:HMPDAT(HMPSUB,"UID")) ;CPC won't exist for deletion
"RTN","HMPUTIL1",98,0)
 .S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,SUB(2),HMPDOM,SUB(3),SUB(4),"stampTime")=$S($L($G(HMPDAT("DELDATE"))):HMPDAT("DELDATE"),1:HMPDAT(HMPSUB,"STAMPTIME"))
"RTN","HMPUTIL1",99,0)
 ;
"RTN","HMPUTIL1",100,0)
 D ENCODE^HMPJSON(HMPA4JSN,HMPJSON,"HMPJSERR")
"RTN","HMPUTIL1",101,0)
 I $D(HMPJSERR) S $EC=",JSON encode error in unsolicited update," Q
"RTN","HMPUTIL1",102,0)
 ; find last line of JSON
"RTN","HMPUTIL1",103,0)
 S LSTLN=0 F J=1:1 Q:'$D(@HMPJSON@(J))  S LSTLN=J
"RTN","HMPUTIL1",104,0)
 ; Merge in data section from FRESHITM^HMPDJFSG
"RTN","HMPUTIL1",105,0)
 ; Add a comma after the syncStart Message for the actual data
"RTN","HMPUTIL1",106,0)
 S @HMPJSON@(LSTLN,.3)=","
"RTN","HMPUTIL1",107,0)
 S HMPSUB=""
"RTN","HMPUTIL1",108,0)
 ;
"RTN","HMPUTIL1",109,0)
 ; do the merge
"RTN","HMPUTIL1",110,0)
 F  S HMPSUB=$O(^TMP("HMP",$J,HMPSUB)) Q:'HMPSUB  D
"RTN","HMPUTIL1",111,0)
 .N HMPX,HMPDATA
"RTN","HMPUTIL1",112,0)
 .S LSTLN=LSTLN+1
"RTN","HMPUTIL1",113,0)
 .; If it is patient data add the wrapper with pid
"RTN","HMPUTIL1",114,0)
 .I DFN'="OPD" S @HMPJSON@(LSTLN,.4)="{""collection"":"""_HMPDOM_""""_$$PIDS^HMPDJFS(DFN)_",""seq"":1,""total"":1,""object"":"_$S($G(ACT)="@":DELJSON,1:"")
"RTN","HMPUTIL1",115,0)
 .; If it is operational data add the wrapper without pid
"RTN","HMPUTIL1",116,0)
 .I DFN="OPD",$G(ACT)="@" S @HMPJSON@(LSTLN,.4)="{""collection"":"""_HMPDOM_""",""seq"":1,""total"":1,""object"":"_DELJSON ;;US5647
"RTN","HMPUTIL1",117,0)
 .; If it is operational data and to be deleted
"RTN","HMPUTIL1",118,0)
 .I DFN="OPD",$G(ACT)'="@"  D  ;US5859
"RTN","HMPUTIL1",119,0)
 ..S @HMPJSON@(LSTLN,.4)="{""collection"":"""_HMPDOM_""",""seq"":1,""total"":1,""object"":"
"RTN","HMPUTIL1",120,0)
 ..S HMPX="""stampTime"":"_QTE_$S($L($G(HMPDAT("DELDATE"))):HMPDAT("DELDATE"),1:HMPDAT("STAMPTIME"))_QTE_","
"RTN","HMPUTIL1",121,0)
 ..S HMPDATA=^TMP("HMP",$J,HMPSUB,1)
"RTN","HMPUTIL1",122,0)
 ..S ^TMP("HMP",$J,HMPSUB,1)="{"_HMPX_$P(HMPDATA,"{",2,999)
"RTN","HMPUTIL1",123,0)
 .M @HMPJSON@(LSTLN)=^TMP("HMP",$J,HMPSUB)
"RTN","HMPUTIL1",124,0)
 .; Close the wrapper
"RTN","HMPUTIL1",125,0)
 .S HMPCLFLG=1
"RTN","HMPUTIL1",126,0)
 .; Add the closing brace for the wrapper
"RTN","HMPUTIL1",127,0)
 .S @HMPJSON@(LSTLN+1,.1)="}"
"RTN","HMPUTIL1",128,0)
 .; Increment the domain total
"RTN","HMPUTIL1",129,0)
 .S HMPDMTOT=HMPDMTOT+1
"RTN","HMPUTIL1",130,0)
 ;
"RTN","HMPUTIL1",131,0)
 S HMPFCNT=$G(HMPFCNT)+1
"RTN","HMPUTIL1",132,0)
 M ^TMP("HMPF",$J,HMPFCNT)=@HMPJSON
"RTN","HMPUTIL1",133,0)
 ; need a comma if more than one item
"RTN","HMPUTIL1",134,0)
 I HMPFCNT>1 S ^TMP("HMPF",$J,HMPFCNT,.3)=$S(HMPLITEM="SYNC":"},",1:",") S HMPLITEM="FRESH" ; DE3502
"RTN","HMPUTIL1",135,0)
 ;
"RTN","HMPUTIL1",136,0)
 ; clean up residual data in ^TMP($J), may be quite a lot
"RTN","HMPUTIL1",137,0)
 K @HMPA4JSN,@HMPJSON
"RTN","HMPUTIL1",138,0)
 Q
"RTN","HMPUTIL1",139,0)
 ;
"RTN","HMPUTILS")
0^88^B41539926^B39059234
"RTN","HMPUTILS",1,0)
HMPUTILS ;SLC/AGP,ASMR/RRB,CK -- HMP utilities routine ;May 15, 2016 14:15
"RTN","HMPUTILS",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1**;May 15, 2016;Build 4
"RTN","HMPUTILS",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPUTILS",4,0)
 ;
"RTN","HMPUTILS",5,0)
 ; External References          DBIA#
"RTN","HMPUTILS",6,0)
 ; -------------------          -----
"RTN","HMPUTILS",7,0)
 ; XLFCRC                        3156
"RTN","HMPUTILS",8,0)
 ; XLFDT                        10103
"RTN","HMPUTILS",9,0)
 ; XLFUTL                        2622
"RTN","HMPUTILS",10,0)
 ; XUPARAM                       2541
"RTN","HMPUTILS",11,0)
 ;
"RTN","HMPUTILS",12,0)
 ; DE2818/RRB: SQA findings 1st 3 lines
"RTN","HMPUTILS",13,0)
 Q
"RTN","HMPUTILS",14,0)
 ;
"RTN","HMPUTILS",15,0)
CHKSP(HMPFHMP) ; -- ^XTMP check before patient subscription starts to cache   *BEGIN*S68-PJH
"RTN","HMPUTILS",16,0)
 ; Input HMPFHMP - server name
"RTN","HMPUTILS",17,0)
 N HMPOK
"RTN","HMPUTILS",18,0)
 S HMPOK=0
"RTN","HMPUTILS",19,0)
 F  D  Q:HMPOK
"RTN","HMPUTILS",20,0)
 . ; -- if ok to run, reset DISK USAGE STATUS to 'WITHIN LIMIT' and continue ; US8228
"RTN","HMPUTILS",21,0)
 . I $$OKTORUN^HMPDJFSP("subscribe") S HMPOK=1 D STATUS^HMPMETA(HMPOK,HMPFHMP) Q  ; US8228
"RTN","HMPUTILS",22,0)
 . ; -- otherwise make sure DISK USAGE STATUS is 'EXCEEDED LIMIT' and wait ; US8228
"RTN","HMPUTILS",23,0)
 . D STATUS^HMPMETA(HMPOK,HMPFHMP) H $$GETSECS^HMPDJFSP  ; US8228
"RTN","HMPUTILS",24,0)
 Q  ;  *END*S68-PJH
"RTN","HMPUTILS",25,0)
 ;
"RTN","HMPUTILS",26,0)
SETERROR(RESULT,ERROR,EXTERROR,DATA) ; -- error text for JSON
"RTN","HMPUTILS",27,0)
 N CNT,TEMP,HMPTEMP,XCNT
"RTN","HMPUTILS",28,0)
 S HMPTEMP="HMPXTEMP ERRORS"
"RTN","HMPUTILS",29,0)
 I '$D(^XTMP(HMPTEMP,0)) S ^XTMP(HMPTEMP,0)=$$FMADD^XLFDT(DT,7)_U_DT_U_"HMP ERROR GLOBAL"
"RTN","HMPUTILS",30,0)
 S RESULT("success")="false"
"RTN","HMPUTILS",31,0)
 I $D(DATA) S XCNT=$O(^XTMP(HMPTEMP,""),-1)+1 M ^XTMP(HMPTEMP,XCNT,"ERROR")=DATA
"RTN","HMPUTILS",32,0)
 I $D(ERROR) D SETERRTX(.TEMP,.ERROR) S RESULT("error","code")=TEMP
"RTN","HMPUTILS",33,0)
 I +$G(XCNT)>0 S RESULT("error","code")=$G(RESULT("error","code"))_" See ^XTMP("_HMPTEMP_","_XCNT_",DATA) for data"
"RTN","HMPUTILS",34,0)
 I $D(EXTERROR) D SETERRTX(.TEMP,.EXTERROR) I TEMP'="" S RESULT("error","message")=TEMP
"RTN","HMPUTILS",35,0)
 ;
"RTN","HMPUTILS",36,0)
 Q
"RTN","HMPUTILS",37,0)
 ;
"RTN","HMPUTILS",38,0)
SETERRTX(TEMP,ERROR) ;
"RTN","HMPUTILS",39,0)
 S TEMP=""
"RTN","HMPUTILS",40,0)
 S CNT=0 F  S CNT=$O(ERROR(CNT)) Q:CNT'>0  D
"RTN","HMPUTILS",41,0)
 .S TEMP=$S(TEMP'="":TEMP=TEMP_$C(13,10)_ERROR(CNT),1:ERROR(CNT))
"RTN","HMPUTILS",42,0)
 Q
"RTN","HMPUTILS",43,0)
 ;
"RTN","HMPUTILS",44,0)
SETTEXT(X,VALUE) ; -- format word processing
"RTN","HMPUTILS",45,0)
 N FIRST,I,LINE
"RTN","HMPUTILS",46,0)
 S FIRST=1
"RTN","HMPUTILS",47,0)
 S I=0 F  S I=$O(@X@(I)) Q:I<1  D
"RTN","HMPUTILS",48,0)
 .S LINE=$S($D(@X@(I,0)):@X@(I,0),1:@X@(I))
"RTN","HMPUTILS",49,0)
 .; FIRST=1 S @VALUE@(I)=LINE,FIRST=0 Q
"RTN","HMPUTILS",50,0)
 .S @VALUE@(I)=LINE_$C(13)_$C(10)
"RTN","HMPUTILS",51,0)
 Q
"RTN","HMPUTILS",52,0)
 ;
"RTN","HMPUTILS",53,0)
SPLITVAL(NODE,ARRAY) ; -- split a value into a list
"RTN","HMPUTILS",54,0)
 N CNT,NAME,VALUE,FIELD
"RTN","HMPUTILS",55,0)
 S NAME="" F  S NAME=$O(ARRAY(NAME)) Q:NAME=""  D
"RTN","HMPUTILS",56,0)
 .S CNT=+ARRAY(NAME)
"RTN","HMPUTILS",57,0)
 .S VALUE=$P($G(NODE),U,CNT)
"RTN","HMPUTILS",58,0)
 .I NAME="Code" S FIELD=$P(ARRAY(NAME),U,2) S VALUE=$$SETVURN(FIELD,VALUE)
"RTN","HMPUTILS",59,0)
 .S ARRAY(NAME)=VALUE
"RTN","HMPUTILS",60,0)
 Q
"RTN","HMPUTILS",61,0)
 ;
"RTN","HMPUTILS",62,0)
SETPROV(NODE,PROV) ; -- providers
"RTN","HMPUTILS",63,0)
 S PROV("providerUid")=$$SETUID("user",,+NODE)
"RTN","HMPUTILS",64,0)
 S PROV("providerName")=$P(NODE,U,2)
"RTN","HMPUTILS",65,0)
 Q
"RTN","HMPUTILS",66,0)
 ;
"RTN","HMPUTILS",67,0)
SETUID(DOMAIN,PAT,ID,ADDDATA) ; -- create uid string
"RTN","HMPUTILS",68,0)
 N RESULT,SYS
"RTN","HMPUTILS",69,0)
 S SYS=$S($D(HMPSYS):HMPSYS,1:$$SYS)
"RTN","HMPUTILS",70,0)
 S RESULT="urn:va:"_DOMAIN_":"_SYS_":"_$S($G(PAT):PAT_":",1:"")_ID
"RTN","HMPUTILS",71,0)
 I $L($G(ADDDATA)) S RESULT=RESULT_":"_ADDDATA
"RTN","HMPUTILS",72,0)
 Q RESULT
"RTN","HMPUTILS",73,0)
 ;
"RTN","HMPUTILS",74,0)
SETFCURN(DOMAIN,FACILITY,VALUE) ; -- create facility urn
"RTN","HMPUTILS",75,0)
 Q "urn:va:"_DOMAIN_":"_FACILITY_":"_VALUE
"RTN","HMPUTILS",76,0)
 ;
"RTN","HMPUTILS",77,0)
SETVURN(DOMAIN,VALUE) ; -- create VA urn
"RTN","HMPUTILS",78,0)
 N RESULT S RESULT=""
"RTN","HMPUTILS",79,0)
 S RESULT="urn:va:"_DOMAIN_":"_VALUE
"RTN","HMPUTILS",80,0)
 Q RESULT
"RTN","HMPUTILS",81,0)
 ;
"RTN","HMPUTILS",82,0)
SYS(NAME) ; -- return hashed system name from HMP SYSTEM NAME parameter, or calculate from NAME parameter if it exists
"RTN","HMPUTILS",83,0)
 ; DE4463 4/22/2016 CK - changed HMP routines to all call this function
"RTN","HMPUTILS",84,0)
 ;  SYS^HMPUTILS returns a 4 digit hashed site, padded with leading zeros
"RTN","HMPUTILS",85,0)
 I '$L($G(NAME)) Q $$GET^XPAR("SYS","HMP SYSTEM NAME")
"RTN","HMPUTILS",86,0)
 Q $TR($J($$BASE^XLFUTL($$CRC16^XLFCRC(NAME),10,16),4)," ",0)
"RTN","HMPUTILS",87,0)
 ;
"RTN","HMPUTILS",88,0)
SETNCS(CODESET,VALUE) ; -- create national codeset urn
"RTN","HMPUTILS",89,0)
 Q "urn:"_CODESET_":"_VALUE
"RTN","HMPUTILS",90,0)
 ;
"RTN","HMPUTILS",91,0)
JSONDT(X) ; -- convert FileMan DT to HL7 DT for JSON
"RTN","HMPUTILS",92,0)
 N HL7DT,T,Y
"RTN","HMPUTILS",93,0)
 ;DE3116 4/12/16 ASF,JC function updated to handle FM date problems
"RTN","HMPUTILS",94,0)
 ; T indicates that a time was included
"RTN","HMPUTILS",95,0)
 S T=0 I $E(X,8)=".",$E(X,6,7) S T=1  ; if there's a time it must be a precise date
"RTN","HMPUTILS",96,0)
 S Y=$S(T:X,1:X\1)  ; strip time if imprecise date
"RTN","HMPUTILS",97,0)
 I T,($E(Y,9,10)>23)!($E(Y,11,12)>59)!($E(Y,13,14)>59) S Y=$$FMADD^XLFDT(Y,0,0,0,0) ;DE3116 ASF 04/09/16 allows for hrs >24 and mins >60
"RTN","HMPUTILS",98,0)
 S HL7DT=$P($$FMTHL7^XLFDT(Y),"-")  ; remove time zone offset
"RTN","HMPUTILS",99,0)
 S:T HL7DT=$E(HL7DT_"000000",1,14)  ; if time passed, result must be 14 chars.
"RTN","HMPUTILS",100,0)
 Q HL7DT
"RTN","HMPUTILS",101,0)
 ;
"RTN","HMPUTILS",102,0)
FACILITY(X,Y) ; -- add facility info to array for JSON
"RTN","HMPUTILS",103,0)
 ;  X=STATION NUMBER^STATION NAME
"RTN","HMPUTILS",104,0)
 ;  Y=Variable array name
"RTN","HMPUTILS",105,0)
 ; >D FACILITY^HMPUTILS("500^CAMP MASTER","LAB")
"RTN","HMPUTILS",106,0)
 ;
"RTN","HMPUTILS",107,0)
 S @Y@("facilityCode")=$P(X,"^")
"RTN","HMPUTILS",108,0)
 S @Y@("facilityName")=$P(X,"^",2)
"RTN","HMPUTILS",109,0)
 Q
"RTN","HMPUTILS",110,0)
VERSRV()   ; Return server version of option name
"RTN","HMPUTILS",111,0)
 N HMPLST,VAL
"RTN","HMPUTILS",112,0)
 D FIND^DIC(19,"",1,"X","HMP UI CONTEXT",1,,,,"HMPLST")
"RTN","HMPUTILS",113,0)
 S VAL=$G(HMPLST("DILIST","ID",1,1))
"RTN","HMPUTILS",114,0)
 Q $$UP^XLFSTR($P(VAL,"version ",2))
"RTN","HMPUTILS",115,0)
 ;
"RTN","HMPUTILS",116,0)
VERCMP(CUR,VAL) ; Returns 1 if CUR<VAL, -1 if CUR>VAL, 0 if equal
"RTN","HMPUTILS",117,0)
 N CURMAJOR,CURMINOR,CURSNAP,VALMAJOR,VALMINOR,VALSNAP
"RTN","HMPUTILS",118,0)
 S CURMAJOR=$P(CUR,"-"),CURMINOR=$P(CUR,"-",2),CURSNAP=$E($P(CUR,"-",3),1,4)="SNAP"
"RTN","HMPUTILS",119,0)
 S VALMAJOR=$P(VAL,"-"),VALMINOR=$P(VAL,"-",2),VALSNAP=$E($P(VAL,"-",3),1,4)="SNAP"
"RTN","HMPUTILS",120,0)
 I $E(VALMINOR)="P" S VALMINOR=$E(VALMINOR,2,99)     ; "P"ilot versions (old)
"RTN","HMPUTILS",121,0)
 I $E(CURMINOR)="P" S CURMINOR=$E(VALMINOR,2,99)
"RTN","HMPUTILS",122,0)
 I $E(VALMINOR)="S" S VALMINOR=$E(VALMINOR,2,99)*10  ; "S"print versions
"RTN","HMPUTILS",123,0)
 I $E(CURMINOR)="S" S CURMINOR=$E(CURMINOR,2,99)*10
"RTN","HMPUTILS",124,0)
 Q:VALMAJOR>CURMAJOR 1   Q:VALMAJOR<CURMAJOR -1  ; compare major versions
"RTN","HMPUTILS",125,0)
 Q:VALMINOR>CURMINOR 1   Q:VALMINOR<CURMINOR -1  ; compare minor versions
"RTN","HMPUTILS",126,0)
 Q:(CURSNAP&'VALSNAP) 1  Q:(VALSNAP&'CURSNAP) -1 ; "SNAPSHOT" < released
"RTN","HMPUTILS",127,0)
 Q 0
"RTN","HMPUTILS",128,0)
 ;
"RTN","HMPUTILS",129,0)
WDWH() ; What kind of data exists?
"RTN","HMPUTILS",130,0)
 ; HMPA   = loop counter
"RTN","HMPUTILS",131,0)
 ; HMPB   = dummy variable
"RTN","HMPUTILS",132,0)
 ; HMPOPD = 1 if operational data exists
"RTN","HMPUTILS",133,0)
 ;         "" otherwise
"RTN","HMPUTILS",134,0)
 ; HMPPAT = 1 if patient data exists
"RTN","HMPUTILS",135,0)
 ;         "" otherwise
"RTN","HMPUTILS",136,0)
 ; HMPRET = return variable - 0 if no data exists
"RTN","HMPUTILS",137,0)
 ;                            1 if ONLY patient data exists
"RTN","HMPUTILS",138,0)
 ;                            2 if ONLY operational data exists
"RTN","HMPUTILS",139,0)
 ;                            3 if BOTH patient and operational data exist
"RTN","HMPUTILS",140,0)
 N HMPA,HMPOPD,HMPPAT,HMPRET
"RTN","HMPUTILS",141,0)
 S (HMPOPD,HMPPAT)="",HMPA="HMPFX",HMPRET=0
"RTN","HMPUTILS",142,0)
 F  S HMPA=$O(^XTMP(HMPA)) Q:HMPA']""  D
"RTN","HMPUTILS",143,0)
 .S HMPB=$P(HMPA,"~",3)
"RTN","HMPUTILS",144,0)
 .I HMPB="OPD" S HMPOPD=1 Q
"RTN","HMPUTILS",145,0)
 .I HMPB=+HMPB S HMPPAT=1
"RTN","HMPUTILS",146,0)
 I HMPPAT,'HMPOPD S HMPRET=1
"RTN","HMPUTILS",147,0)
 I 'HMPPAT,HMPOPD S HMPRET=2
"RTN","HMPUTILS",148,0)
 I HMPPAT,HMPOPD S HMPRET=3
"RTN","HMPUTILS",149,0)
 Q HMPRET
"RTN","HMPUTILS",150,0)
 ;
"RTN","HMPUTILS",151,0)
NODATA(A) ; Is there any patient data; JD - 2/23/15
"RTN","HMPUTILS",152,0)
 ; Returns 1 if there is no patient data
"RTN","HMPUTILS",153,0)
 ;          0 Otherwise
"RTN","HMPUTILS",154,0)
 ; HMPA = Loop counter
"RTN","HMPUTILS",155,0)
 ; HMPF = Dummy variable
"RTN","HMPUTILS",156,0)
 N HMPA,HMPF
"RTN","HMPUTILS",157,0)
 S HMPF=0,HMPA=""
"RTN","HMPUTILS",158,0)
 F  S HMPA=$O(^XTMP(A,0,"count",HMPA)) Q:HMPF!(HMPA']"")  D
"RTN","HMPUTILS",159,0)
 .I +$G(^XTMP(A,0,"count",HMPA))>0 S HMPF=1 Q
"RTN","HMPUTILS",160,0)
 Q $S(HMPF:0,1:1)
"RTN","HMPUTILS",161,0)
 ;
"RTN","HMPUTILS",162,0)
GETSIZE(HMPMODE,HMPSRVN) ; -- returns current aggregate extract size for extracts waiting to be sent to HMP servers
"RTN","HMPUTILS",163,0)
 ; input: HMPMODE := [ estimate - use estimated domain average sizes (default) |
"RTN","HMPUTILS",164,0)
 ;                     actual - walk though object nodes to calculate using $LENGTH ]
"RTN","HMPUTILS",165,0)
 ;        HMPSRVN := name of HMP server [optional - defaults to all HMP servers]
"RTN","HMPUTILS",166,0)
 ; returns: total size ^ object count
"RTN","HMPUTILS",167,0)
 ;
"RTN","HMPUTILS",168,0)
 ; -- loop thru extracts for server(s) 
"RTN","HMPUTILS",169,0)
 N ROOT,BATCH,TASK,DOMAIN,OBJS,OBJCNT,OBJSIZES,TOTAL
"RTN","HMPUTILS",170,0)
 S HMPMODE=$G(HMPMODE,"estimate")
"RTN","HMPUTILS",171,0)
 I HMPMODE="estimate" D GETLST^XPAR(.OBJSIZES,"PKG","HMP DOMAIN SIZES","I")
"RTN","HMPUTILS",172,0)
 S (OBJCNT,TOTAL)=0
"RTN","HMPUTILS",173,0)
 S ROOT="HMPFX~"_$S($G(HMPSRVN)]"":HMPSRVN_"~",1:"")
"RTN","HMPUTILS",174,0)
 S BATCH=ROOT
"RTN","HMPUTILS",175,0)
 F  S BATCH=$O(^XTMP(BATCH)) Q:$E(BATCH,1,$L(ROOT))'=ROOT  D
"RTN","HMPUTILS",176,0)
 . S TASK=0 F  S TASK=$O(^XTMP(BATCH,TASK)) Q:'TASK  D
"RTN","HMPUTILS",177,0)
 . . S DOMAIN="" F  S DOMAIN=$O(^XTMP(BATCH,TASK,DOMAIN)) Q:DOMAIN=""  D
"RTN","HMPUTILS",178,0)
 . . . S OBJS=+$O(^XTMP(BATCH,TASK,DOMAIN," "),-1)
"RTN","HMPUTILS",179,0)
 . . . S OBJCNT=OBJCNT+OBJS
"RTN","HMPUTILS",180,0)
 . . . I HMPMODE="actual" S TOTAL=TOTAL+$$WALK(BATCH,TASK,DOMAIN) Q
"RTN","HMPUTILS",181,0)
 . . . S TOTAL=TOTAL+(OBJS*$G(OBJSIZES($P(DOMAIN,"#")),1000))
"RTN","HMPUTILS",182,0)
 Q TOTAL_"^"_OBJCNT
"RTN","HMPUTILS",183,0)
 ;
"RTN","HMPUTILS",184,0)
WALK(BATCH,TASK,DOMAIN) ; -- walk through domain objectS in task to get actual size
"RTN","HMPUTILS",185,0)
 N OBJ,SIZE,NODE
"RTN","HMPUTILS",186,0)
 S (OBJ,SIZE)=0
"RTN","HMPUTILS",187,0)
 F  S OBJ=$O(^XTMP(BATCH,TASK,DOMAIN,OBJ)) Q:'OBJ  D
"RTN","HMPUTILS",188,0)
 . S NODE=0 F  S NODE=$O(^XTMP(BATCH,TASK,DOMAIN,OBJ,NODE)) Q:'NODE  S SIZE=SIZE+$L(^(NODE))
"RTN","HMPUTILS",189,0)
 Q SIZE
"VER")
8.0^22.0
**END**
**END**

