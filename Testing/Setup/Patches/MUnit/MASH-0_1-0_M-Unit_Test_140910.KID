KIDS Distribution saved on Sep 10, 2014@14:37:04
Implements the M-Unit Test functionality.
**KIDS**:MASH*0.1*0^

**INSTALL NAME**
MASH*0.1*0
"BLD",5528,0)
MASH*0.1*0^MASH UTILITIES^0^3140910^y
"BLD",5528,1,0)
^^2^2^3140829^
"BLD",5528,1,1,0)
M-Unit Test functionality to provide basic unit testing framework for M 
"BLD",5528,1,2,0)
development.
"BLD",5528,4,0)
^9.64PA^17.9001^1
"BLD",5528,4,17.9001,0)
17.9001
"BLD",5528,4,17.9001,222)
y^y^f^^n^^y^o^n
"BLD",5528,4,"B",17.9001,17.9001)

"BLD",5528,"ABPKG")
n
"BLD",5528,"INI")
ZZUTPRE
"BLD",5528,"INID")
^n^n
"BLD",5528,"INIT")
ZZUTPOST
"BLD",5528,"KRN",0)
^9.67PA^8989.52^19
"BLD",5528,"KRN",.4,0)
.4
"BLD",5528,"KRN",.401,0)
.401
"BLD",5528,"KRN",.402,0)
.402
"BLD",5528,"KRN",.403,0)
.403
"BLD",5528,"KRN",.5,0)
.5
"BLD",5528,"KRN",.84,0)
.84
"BLD",5528,"KRN",3.6,0)
3.6
"BLD",5528,"KRN",3.8,0)
3.8
"BLD",5528,"KRN",9.2,0)
9.2
"BLD",5528,"KRN",9.8,0)
9.8
"BLD",5528,"KRN",9.8,"NM",0)
^9.68A^9^9
"BLD",5528,"KRN",9.8,"NM",1,0)
ut^^0^B257937062
"BLD",5528,"KRN",9.8,"NM",2,0)
ut1^^0^B87092328
"BLD",5528,"KRN",9.8,"NM",3,0)
utt1^^0^B25860592
"BLD",5528,"KRN",9.8,"NM",4,0)
utt2^^0^B473823
"BLD",5528,"KRN",9.8,"NM",5,0)
utt3^^0^B1493136
"BLD",5528,"KRN",9.8,"NM",6,0)
utt4^^0^B1419637
"BLD",5528,"KRN",9.8,"NM",7,0)
utt5^^0^B22421637
"BLD",5528,"KRN",9.8,"NM",8,0)
utt6^^0^B29243478
"BLD",5528,"KRN",9.8,"NM",9,0)
uttcovr^^0^B2835727
"BLD",5528,"KRN",9.8,"NM","B","ut",1)

"BLD",5528,"KRN",9.8,"NM","B","ut1",2)

"BLD",5528,"KRN",9.8,"NM","B","utt1",3)

"BLD",5528,"KRN",9.8,"NM","B","utt2",4)

"BLD",5528,"KRN",9.8,"NM","B","utt3",5)

"BLD",5528,"KRN",9.8,"NM","B","utt4",6)

"BLD",5528,"KRN",9.8,"NM","B","utt5",7)

"BLD",5528,"KRN",9.8,"NM","B","utt6",8)

"BLD",5528,"KRN",9.8,"NM","B","uttcovr",9)

"BLD",5528,"KRN",19,0)
19
"BLD",5528,"KRN",19,"NM",0)
^9.68A^3^3
"BLD",5528,"KRN",19,"NM",1,0)
utMUNIT^^0
"BLD",5528,"KRN",19,"NM",2,0)
utMUNIT GROUP EDIT^^0
"BLD",5528,"KRN",19,"NM",3,0)
utMUNIT GROUP RUN^^0
"BLD",5528,"KRN",19,"NM","B","utMUNIT",1)

"BLD",5528,"KRN",19,"NM","B","utMUNIT GROUP EDIT",2)

"BLD",5528,"KRN",19,"NM","B","utMUNIT GROUP RUN",3)

"BLD",5528,"KRN",19.1,0)
19.1
"BLD",5528,"KRN",101,0)
101
"BLD",5528,"KRN",409.61,0)
409.61
"BLD",5528,"KRN",771,0)
771
"BLD",5528,"KRN",870,0)
870
"BLD",5528,"KRN",8989.51,0)
8989.51
"BLD",5528,"KRN",8989.52,0)
8989.52
"BLD",5528,"KRN",8994,0)
8994
"BLD",5528,"KRN",8994,"NM",0)
^9.68A^3^3
"BLD",5528,"KRN",8994,"NM",1,0)
utMUNIT-TEST GROUP LOAD^^0
"BLD",5528,"KRN",8994,"NM",2,0)
utMUNIT-TEST LOAD^^0
"BLD",5528,"KRN",8994,"NM",3,0)
utMUNIT-TEST NEXT^^0
"BLD",5528,"KRN",8994,"NM","B","utMUNIT-TEST GROUP LOAD",1)

"BLD",5528,"KRN",8994,"NM","B","utMUNIT-TEST LOAD",2)

"BLD",5528,"KRN",8994,"NM","B","utMUNIT-TEST NEXT",3)

"BLD",5528,"KRN","B",.4,.4)

"BLD",5528,"KRN","B",.401,.401)

"BLD",5528,"KRN","B",.402,.402)

"BLD",5528,"KRN","B",.403,.403)

"BLD",5528,"KRN","B",.5,.5)

"BLD",5528,"KRN","B",.84,.84)

"BLD",5528,"KRN","B",3.6,3.6)

"BLD",5528,"KRN","B",3.8,3.8)

"BLD",5528,"KRN","B",9.2,9.2)

"BLD",5528,"KRN","B",9.8,9.8)

"BLD",5528,"KRN","B",19,19)

"BLD",5528,"KRN","B",19.1,19.1)

"BLD",5528,"KRN","B",101,101)

"BLD",5528,"KRN","B",409.61,409.61)

"BLD",5528,"KRN","B",771,771)

"BLD",5528,"KRN","B",870,870)

"BLD",5528,"KRN","B",8989.51,8989.51)

"BLD",5528,"KRN","B",8989.52,8989.52)

"BLD",5528,"KRN","B",8994,8994)

"BLD",5528,"QUES",0)
^9.62^^
"DATA",17.9001,1,0)
TESTS FOR UNIT TEST ROUTINES
"DATA",17.9001,1,1,0)
^17.90011^5^5
"DATA",17.9001,1,1,1,0)
%utt1
"DATA",17.9001,1,1,2,0)
%utt2
"DATA",17.9001,1,1,3,0)
%utt3
"DATA",17.9001,1,1,4,0)
%utt4
"DATA",17.9001,1,1,5,0)
%utt5
"FIA",17.9001)
M-UNIT TEST GROUP
"FIA",17.9001,0)
^%ut(17.9001,
"FIA",17.9001,0,0)
17.9001
"FIA",17.9001,0,1)
y^y^f^^n^^y^o^n
"FIA",17.9001,0,10)

"FIA",17.9001,0,11)

"FIA",17.9001,0,"RLRO")

"FIA",17.9001,0,"VR")
0.1^MASH
"FIA",17.9001,17.9001)
0
"FIA",17.9001,17.90011)
0
"FIA",17.9001,17.90012)
0
"INI")
ZZUTPRE
"INIT")
ZZUTPOST
"KRN",19,10068,-1)
0^1
"KRN",19,10068,0)
utMUNIT^M-Unit Tester^^B^^^^^^^^
"KRN",19,10068,1,0)
^^1^1^3140805^
"KRN",19,10068,1,1,0)
This is the context option for M-Unit Test functionality.
"KRN",19,10068,"RPC",0)
^19.05P^3^3
"KRN",19,10068,"RPC",1,0)
utMUNIT-TEST GROUP LOAD
"KRN",19,10068,"RPC",2,0)
utMUNIT-TEST LOAD
"KRN",19,10068,"RPC",3,0)
utMUNIT-TEST NEXT
"KRN",19,10068,"U")
M-UNIT TESTER
"KRN",19,10069,-1)
0^2
"KRN",19,10069,0)
utMUNIT GROUP EDIT^M-Unit Test Group Edit^^E^^^^^^^^TOOLKIT
"KRN",19,10069,1,0)
^19.06^6^6^3031030^^^
"KRN",19,10069,1,1,0)
This option can be used to maintain a listing of unit tests related to a 
"KRN",19,10069,1,2,0)
specific topic.  The Group identifies the topic, and the unit tests 
"KRN",19,10069,1,3,0)
related to that topic are added in the multiple.  Unit Tests can be run 
"KRN",19,10069,1,4,0)
by selecting a group, and all unit tests included in the multiple will be 
"KRN",19,10069,1,5,0)
used for the test.  In addition, any other references under the XTROU tag 
"KRN",19,10069,1,6,0)
in any of the included test routines will be included in the run.
"KRN",19,10069,30)
%ut(17.9001,
"KRN",19,10069,31)
AEMQL
"KRN",19,10069,50)
17.9001
"KRN",19,10069,51)
.01;1
"KRN",19,10069,"U")
M-UNIT TEST GROUP EDIT
"KRN",19,10070,-1)
0^3
"KRN",19,10070,0)
utMUNIT GROUP RUN^Run M-Unit Tests From Test Groups^^R^^^^^^^^TOOLKIT
"KRN",19,10070,1,0)
^^2^2^3031030^
"KRN",19,10070,1,1,0)
Provides a means of initiating a unit test run from the menu system based 
"KRN",19,10070,1,2,0)
on entries in the M-UNIT TEST GROUP file (#17.9001).
"KRN",19,10070,25)
PICKSET^%ut
"KRN",19,10070,"U")
RUN M-UNIT TESTS FROM TEST GRO
"KRN",8994,1866,-1)
0^1
"KRN",8994,1866,0)
utMUNIT-TEST GROUP LOAD^GUISET^%ut^4^^^^1
"KRN",8994,1867,-1)
0^2
"KRN",8994,1867,0)
utMUNIT-TEST LOAD^GUILOAD^%ut^4^^^^1
"KRN",8994,1868,-1)
0^3
"KRN",8994,1868,0)
utMUNIT-TEST NEXT^GUINEXT^%ut^4^^^^1
"MBREQ")
0
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",201,-1)
1^1
"PKG",201,0)
MASH UTILITIES^%u^Utilities associated with the M Advanced Shell
"PKG",201,20,0)
^9.402P^^
"PKG",201,22,0)
^9.49I^1^1
"PKG",201,22,1,0)
0.1
"PKG",201,22,1,"PAH",1,0)
0^3140910^2802
"PKG",201,22,1,"PAH",1,1,0)
^^2^2^3140910
"PKG",201,22,1,"PAH",1,1,1,0)
M-Unit Test functionality to provide basic unit testing framework for M 
"PKG",201,22,1,"PAH",1,1,2,0)
development.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
11
"RTN","ZZUTPOST")
0^^B30449799
"RTN","ZZUTPOST",1,0)
ut01POST ;VEN-SMH/JLI - post install for M-Unit Test software ;08/28/14  12:29
"RTN","ZZUTPOST",2,0)
 ;;0.1;MASH UTILITIES
"RTN","ZZUTPOST",3,0)
 N X,I
"RTN","ZZUTPOST",4,0)
 I +$SY=47 D  R X:$G(DTIME,300) D MES^XPDUTL(" ")
"RTN","ZZUTPOST",5,0)
 . S X(1)=" "
"RTN","ZZUTPOST",6,0)
 . S X(2)="In the next section, as it tries to copy the ut* routines"
"RTN","ZZUTPOST",7,0)
 . S X(3)="to %ut* routines watch for text that indicates the following:"
"RTN","ZZUTPOST",8,0)
 . S X(4)=" "
"RTN","ZZUTPOST",9,0)
 . S X(5)="cp: cannot create regular file `/_ut.m': Permission denied"
"RTN","ZZUTPOST",10,0)
 . S X(6)=" "
"RTN","ZZUTPOST",11,0)
 . S X(7)="If this is seen, respond Yes at the prompt after the attempt:"
"RTN","ZZUTPOST",12,0)
 . S X(8)="   Press ENTER to continue: "
"RTN","ZZUTPOST",13,0)
 . F I=1:1:18 D MES^XPDUTL(" ") ; create a blank screen for text
"RTN","ZZUTPOST",14,0)
 . D MES^XPDUTL(.X)
"RTN","ZZUTPOST",15,0)
 . Q
"RTN","ZZUTPOST",16,0)
 D RENAME
"RTN","ZZUTPOST",17,0)
 I +$SY=47 D  R X:$G(DTIME,300) I "Yy"[$E($G(X)) D GTMPROB
"RTN","ZZUTPOST",18,0)
 . K X
"RTN","ZZUTPOST",19,0)
 . S X(1)=" "
"RTN","ZZUTPOST",20,0)
 . S X(2)="  Your entry on the next line may not echo"
"RTN","ZZUTPOST",21,0)
 . S X(3)="If error text was seen enter Y (and RETURN):  NO// "
"RTN","ZZUTPOST",22,0)
 . D MES^XPDUTL(.X)
"RTN","ZZUTPOST",23,0)
 . Q
"RTN","ZZUTPOST",24,0)
 Q
"RTN","ZZUTPOST",25,0)
 ;
"RTN","ZZUTPOST",26,0)
RENAME ;
"RTN","ZZUTPOST",27,0)
 N %S,%D ; Source, destination
"RTN","ZZUTPOST",28,0)
 S U="^"
"RTN","ZZUTPOST",29,0)
 S %S="ut^ut1^utt1^utt2^utt3^utt4^utt5^utt6^uttcovr"
"RTN","ZZUTPOST",30,0)
 S %D="%ut^%ut1^%utt1^%utt2^%utt3^%utt4^%utt5^%utt6^%uttcovr"
"RTN","ZZUTPOST",31,0)
 ;
"RTN","ZZUTPOST",32,0)
MOVE ; rename % routines
"RTN","ZZUTPOST",33,0)
 N %,X,Y,M
"RTN","ZZUTPOST",34,0)
 F %=1:1:$L(%D,"^") D  D MES(M) I +$SY=47 D MES(" ")
"RTN","ZZUTPOST",35,0)
 . S M="",X=$P(%S,U,%) ; from
"RTN","ZZUTPOST",36,0)
 . S Y=$P(%D,U,%) ; to
"RTN","ZZUTPOST",37,0)
 . Q:X=""
"RTN","ZZUTPOST",38,0)
 . S M="Routine: "_$J(X,8)
"RTN","ZZUTPOST",39,0)
 . Q:Y=""  I $T(^@X)=""  S M=M_"  Missing" Q
"RTN","ZZUTPOST",40,0)
 . S M=M_" Loaded, "
"RTN","ZZUTPOST",41,0)
 . D COPY(X,Y)
"RTN","ZZUTPOST",42,0)
 . S M=M_"Saved as "_$J(Y,8)
"RTN","ZZUTPOST",43,0)
 ;
"RTN","ZZUTPOST",44,0)
 QUIT  ; END
"RTN","ZZUTPOST",45,0)
 ;
"RTN","ZZUTPOST",46,0)
COPY(FROM,TO) ;
"RTN","ZZUTPOST",47,0)
 N XVAL
"RTN","ZZUTPOST",48,0)
 I +$SYSTEM=0 S XVAL="ZL @FROM ZS @TO" X XVAL QUIT
"RTN","ZZUTPOST",49,0)
 I +$SYSTEM=47 DO  QUIT
"RTN","ZZUTPOST",50,0)
 . S FROM=$$PATH(FROM)
"RTN","ZZUTPOST",51,0)
 . S TO=$$PATH(TO,"WRITE")
"RTN","ZZUTPOST",52,0)
 . N CMD S CMD="cp "_FROM_" "_TO
"RTN","ZZUTPOST",53,0)
 . O "cp":(shell="/bin/sh":command=CMD:WRITEONLY)::"PIPE"
"RTN","ZZUTPOST",54,0)
 . U "cp" C "cp"
"RTN","ZZUTPOST",55,0)
 QUIT
"RTN","ZZUTPOST",56,0)
 ;
"RTN","ZZUTPOST",57,0)
PATH(ROUTINE,MODE) ; for GT.M return source file with path for a routine
"RTN","ZZUTPOST",58,0)
 ;input: ROUTINE=Name of routine
"RTN","ZZUTPOST",59,0)
 ;       MODE="READ" or "WRITE" defaults to READ
"RTN","ZZUTPOST",60,0)
 ;output: Full filename
"RTN","ZZUTPOST",61,0)
 ;
"RTN","ZZUTPOST",62,0)
 S MODE=$G(MODE,"READ") ;set MODE to default value
"RTN","ZZUTPOST",63,0)
 N FILE S FILE=$TR(ROUTINE,"%","_")_".m" ;convert rtn name to filename
"RTN","ZZUTPOST",64,0)
 N ZRO S ZRO=$ZRO
"RTN","ZZUTPOST",65,0)
 ;
"RTN","ZZUTPOST",66,0)
 ; Get source routine
"RTN","ZZUTPOST",67,0)
 N %ZR
"RTN","ZZUTPOST",68,0)
 I MODE="READ" D SILENT^%RSEL(ROUTINE,"SRC") Q %ZR(ROUTINE)_FILE
"RTN","ZZUTPOST",69,0)
 ;
"RTN","ZZUTPOST",70,0)
 ; We are writing. Parse directories and get 1st routine directory
"RTN","ZZUTPOST",71,0)
 N DIRS
"RTN","ZZUTPOST",72,0)
 D PARSEZRO(.DIRS,ZRO)
"RTN","ZZUTPOST",73,0)
 N PATH S PATH=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",74,0)
 ;
"RTN","ZZUTPOST",75,0)
 QUIT PATH_FILE ;end of PATH return directory and filename
"RTN","ZZUTPOST",76,0)
 ;
"RTN","ZZUTPOST",77,0)
 ;
"RTN","ZZUTPOST",78,0)
PARSEZRO(DIRS,ZRO) ; Parse $zroutines properly into an array
"RTN","ZZUTPOST",79,0)
 N PIECE
"RTN","ZZUTPOST",80,0)
 N I
"RTN","ZZUTPOST",81,0)
 F I=1:1:$L(ZRO," ") S PIECE(I)=$P(ZRO," ",I)
"RTN","ZZUTPOST",82,0)
 N CNT S CNT=1
"RTN","ZZUTPOST",83,0)
 F I=0:0 S I=$O(PIECE(I)) Q:'I  D
"RTN","ZZUTPOST",84,0)
 . S DIRS(CNT)=$G(DIRS(CNT))_PIECE(I)
"RTN","ZZUTPOST",85,0)
 . I DIRS(CNT)["("&(DIRS(CNT)[")") S CNT=CNT+1 QUIT
"RTN","ZZUTPOST",86,0)
 . I DIRS(CNT)'["("&(DIRS(CNT)'[")") S CNT=CNT+1 QUIT
"RTN","ZZUTPOST",87,0)
 . S DIRS(CNT)=DIRS(CNT)_" " ; prep for next piece
"RTN","ZZUTPOST",88,0)
 QUIT
"RTN","ZZUTPOST",89,0)
 ;
"RTN","ZZUTPOST",90,0)
ZRO1ST(DIRS) ; $$ Get first routine directory
"RTN","ZZUTPOST",91,0)
 N OUT ; $$ return
"RTN","ZZUTPOST",92,0)
 N %1 S %1=DIRS(1) ; 1st directory
"RTN","ZZUTPOST",93,0)
 ; Parse with (...)
"RTN","ZZUTPOST",94,0)
 I %1["(" DO
"RTN","ZZUTPOST",95,0)
 . S OUT=$P(%1,"(",2)
"RTN","ZZUTPOST",96,0)
 . I OUT[" " S OUT=$P(OUT," ")
"RTN","ZZUTPOST",97,0)
 . E  S OUT=$P(OUT,")")
"RTN","ZZUTPOST",98,0)
 ; no parens
"RTN","ZZUTPOST",99,0)
 E  S OUT=%1
"RTN","ZZUTPOST",100,0)
 ;
"RTN","ZZUTPOST",101,0)
 ; Add trailing slash
"RTN","ZZUTPOST",102,0)
 I $E(OUT,$L(OUT))'="/" S OUT=OUT_"/"
"RTN","ZZUTPOST",103,0)
 QUIT OUT
"RTN","ZZUTPOST",104,0)
 ;
"RTN","ZZUTPOST",105,0)
MES(T,B) ;Write message.
"RTN","ZZUTPOST",106,0)
 S B=$G(B)
"RTN","ZZUTPOST",107,0)
 I $L($T(BMES^XPDUTL)) D BMES^XPDUTL(T):B,MES^XPDUTL(T):'B Q
"RTN","ZZUTPOST",108,0)
 W:B ! W !,T
"RTN","ZZUTPOST",109,0)
 Q
"RTN","ZZUTPOST",110,0)
 ;
"RTN","ZZUTPOST",111,0)
TEST ; @TEST - TESTING TESTING
"RTN","ZZUTPOST",112,0)
 ;
"RTN","ZZUTPOST",113,0)
 N ZR S ZR="o(p r) /var/abc(/var/abc/r/) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",114,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",115,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",116,0)
 I FIRSTDIR'="p" S $EC=",U1,"
"RTN","ZZUTPOST",117,0)
 ;
"RTN","ZZUTPOST",118,0)
 N ZR S ZR="/var/abc(/var/abc/r/) o(p r) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",119,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",120,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",121,0)
 I FIRSTDIR'="/var/abc/r/" S $EC=",U1,"
"RTN","ZZUTPOST",122,0)
 ;
"RTN","ZZUTPOST",123,0)
 N ZR S ZR="/abc/def /var/abc(/var/abc/r/) o(p r) $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",124,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",125,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",126,0)
 I FIRSTDIR'="/abc/def" S $EC=",U1,"
"RTN","ZZUTPOST",127,0)
 ;
"RTN","ZZUTPOST",128,0)
 WRITE "All tests have run successfully!",!
"RTN","ZZUTPOST",129,0)
 QUIT
"RTN","ZZUTPOST",130,0)
 ;
"RTN","ZZUTPOST",131,0)
GTMPROB ; come here in case of error trying to run unit tests - checks whether renaming worked
"RTN","ZZUTPOST",132,0)
 N X
"RTN","ZZUTPOST",133,0)
 S X(1)=" "
"RTN","ZZUTPOST",134,0)
 S X(2)="*** An error occurred during renaming of routines to %ut*."
"RTN","ZZUTPOST",135,0)
 S X(3)="*** The renaming has been seen to fail on one type of Linux system."
"RTN","ZZUTPOST",136,0)
 S X(4)="*** In this case, at the Linux command line copy each ut*.m routine"
"RTN","ZZUTPOST",137,0)
 S X(5)="*** (ut.m, ut1.m, utt1.m, utt2.m, utt3.m, utt4.m, utt5.m, utt6.m, and "
"RTN","ZZUTPOST",138,0)
 S X(6)="*** uttcovr.m) to _ut*.m (e.g., 'cp ut.m _ut.m', 'cp ut1.m _ut1.m',"
"RTN","ZZUTPOST",139,0)
 S X(7)="*** 'cp utt1.m _utt1.m', etc., to 'cp uttcovr.m _uttcovr.m').  Then in GT.M"
"RTN","ZZUTPOST",140,0)
 S X(8)="*** use the command 'ZLINK %ut', then 'ZLINK %ut1', etc., these may"
"RTN","ZZUTPOST",141,0)
 S X(9)="*** indicate an undefined local variable error, but continue doing it."
"RTN","ZZUTPOST",142,0)
 S X(10)="*** When complete, use the M command 'DO ^%utt1' to run the unit tests on"
"RTN","ZZUTPOST",143,0)
 S X(11)="*** the %ut and %ut1 routines to confirm they are working"
"RTN","ZZUTPOST",144,0)
 S X(12)=" "
"RTN","ZZUTPOST",145,0)
 S X(13)="  Press Enter to continue: "
"RTN","ZZUTPOST",146,0)
 D MES^XPDUTL(.X)
"RTN","ZZUTPOST",147,0)
 R X:$G(DTIME,300)
"RTN","ZZUTPOST",148,0)
 Q
"RTN","ZZUTPRE")
0^^B3651860
"RTN","ZZUTPRE",1,0)
ut01PRE ;VEN/JLI - pre installation routine to set up MASH UTILITIES package and assign %ut routines and globals ;08/22/14  13:02
"RTN","ZZUTPRE",2,0)
 ;;0.1;MASH UTILITIES
"RTN","ZZUTPRE",3,0)
 ;
"RTN","ZZUTPRE",4,0)
 ; The following is used to create, if it does not exist, the MASH UTILITIES
"RTN","ZZUTPRE",5,0)
 ; package, and to assign the %u namespace to this package.  This special
"RTN","ZZUTPRE",6,0)
 ; processing is necessary, since the input transform currently will not accept a
"RTN","ZZUTPRE",7,0)
 ; % or lower case character in the namespace.
"RTN","ZZUTPRE",8,0)
 I '$D(^DIC(9.4,"B","MASH UTILITIES")) N DIC,X S DIC="^DIC(9.4,",DIC(0)="",X="MASH UTILITIES",DIC("DR")="1////%u;2///Utilities associated with the M Advanced Shell" D FILE^DICN
"RTN","ZZUTPRE",9,0)
 ; and if necessary, as in CACHE, map %ut routine and namespace in the current account.
"RTN","ZZUTPRE",10,0)
 I +$SY=0 D CACHEMAP ; This routine is CACHE specific
"RTN","ZZUTPRE",11,0)
 Q
"RTN","ZZUTPRE",12,0)
 ; The following code was provided by Sam Habiel to map %
"RTN","ZZUTPRE",13,0)
CACHEMAP ; Map %ut* Globals and Routines away from %SYS in Cache
"RTN","ZZUTPRE",14,0)
 ; Get current namespace
"RTN","ZZUTPRE",15,0)
 N NMSP
"RTN","ZZUTPRE",16,0)
 I $P($P($ZV,") ",2),"(")<2012 S NMSP=$ZU(5)
"RTN","ZZUTPRE",17,0)
 I $P($P($ZV,") ",2),"(")>2011 S NMSP=$NAMESPACE
"RTN","ZZUTPRE",18,0)
 ;
"RTN","ZZUTPRE",19,0)
 ; Map %ut globals away from %SYS
"RTN","ZZUTPRE",20,0)
 ZN "%SYS" ; Go to SYS
"RTN","ZZUTPRE",21,0)
 N % S %=##class(Config.Configuration).GetGlobalMapping(NMSP,"%ut*","",NMSP,NMSP)
"RTN","ZZUTPRE",22,0)
 I '% S %=##class(Config.Configuration).AddGlobalMapping(NMSP,"%ut*","",NMSP,NMSP)
"RTN","ZZUTPRE",23,0)
 I '% W !,"Error="_$SYSTEM.Status.GetErrorText(%) QUIT
"RTN","ZZUTPRE",24,0)
 ;
"RTN","ZZUTPRE",25,0)
 ; Map %ut routines away from %SYS
"RTN","ZZUTPRE",26,0)
 N A S A("Database")=NMSP
"RTN","ZZUTPRE",27,0)
 N % S %=##Class(Config.MapRoutines).Get(NMSP,"%ut*",.A)
"RTN","ZZUTPRE",28,0)
 S A("Database")=NMSP
"RTN","ZZUTPRE",29,0)
 I '% S %=##Class(Config.MapRoutines).Create(NMSP,"%ut*",.A)
"RTN","ZZUTPRE",30,0)
 I '% W !,"Error="_$SYSTEM.Status.GetErrorText(%) QUIT
"RTN","ZZUTPRE",31,0)
 ZN NMSP ; Go back
"RTN","ZZUTPRE",32,0)
 QUIT
"RTN","ut")
0^1^B257937062
"RTN","ut",1,0)
%ut ;VEN-SMH/JLI - PRIMARY PROGRAM FOR M-UNIT TESTING ;08/29/14  09:31
"RTN","ut",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","ut",3,0)
 ;
"RTN","ut",4,0)
 ; This routine and its companion, %ut1, provide the basic functionality for
"RTN","ut",5,0)
 ; running unit tests on parts of M programs either at the command line level
"RTN","ut",6,0)
 ; or via the M-Unit GUI application for windows operating systems.
"RTN","ut",7,0)
 ;
"RTN","ut",8,0)
 ; Original by Dr. Joel Ivey
"RTN","ut",9,0)
 ; Contributions by Dr. Sam Habiel
"RTN","ut",10,0)
 ;
"RTN","ut",11,0)
 ; 100622 JLI - corrected typo in comments where %utINPT was listed as %utINP
"RTN","ut",12,0)
 ; 100622 JLI - removed a comment which indicated data could potentially be returned from the called routine
"RTN","ut",13,0)
 ;              in the %utINPT array.
"RTN","ut",14,0)
 ; 100622 JLI - added code to handle STARTUP and SHUTDOWN from GUI app
"RTN","ut",15,0)
 ; 110719 JLI - modified separators in GUI handling from ^ to ~~^~~
"RTN","ut",16,0)
 ;              in the variable XTGUISEP if using a newer version of the
"RTN","ut",17,0)
 ;              GUI app (otherwise, it is simply set to ^) since results
"RTN","ut",18,0)
 ;              with a series of ^ embedded disturbed the output reported
"RTN","ut",19,0)
 ; 130726 SMH - Fixed SETUP and TEARDOWN so that they run before/after each
"RTN","ut",20,0)
 ;              test rather than once. General refactoring.
"RTN","ut",21,0)
 ; 130726 SMH - SETUT initialized IO in case it's not there to $P. Inits vars
"RTN","ut",22,0)
 ;              using DT^DICRW.
"RTN","ut",23,0)
 ; 131217 SMH - Change call in SETUP to S U="^" instead of DT^DICRW
"RTN","ut",24,0)
 ; 131218 SMH - Any checks to $ZE will also check $ZS for GT.M.
"RTN","ut",25,0)
 ; 131218 SMH - Remove calls to %ZISUTL to manage devices to prevent dependence on VISTA.
"RTN","ut",26,0)
 ;              Use %utNIT("DEV","OLD") for old devices
"RTN","ut",27,0)
 ; 140109 SMH - Add parameter %utBREAK - Break upon error
"RTN","ut",28,0)
 ; 1402   SMH - Break will cause the break to happen even on failed tests.
"RTN","ut",29,0)
 ; 140401 SMH - Added Succeed entry point for take it into your hands tester.
"RTN","ut",30,0)
 ; 140401 SMH - Reformatted the output of M-Unit so that the test's name
"RTN","ut",31,0)
 ;              will print BEFORE the execution of the test. This has been
"RTN","ut",32,0)
 ;              really confusing for beginning users of M-Unit, so this was
"RTN","ut",33,0)
 ;              necessary.
"RTN","ut",34,0)
 ; 140401 SMH - OK message gets printed at the end of --- as [OK].
"RTN","ut",35,0)
 ; 140401 SMH - FAIL message now prints. Previously, OK failed to be printed.
"RTN","ut",36,0)
 ;              Unfortunately, that's rather passive aggressive. Now it
"RTN","ut",37,0)
 ;              explicitly says that a test failed.
"RTN","ut",38,0)
 ; 140503 SMH - Fixed IO issues all over the routine. Much simpler now.
"RTN","ut",39,0)
 ; 140731 JLI - Combined routine changes between JLI and SMH
"RTN","ut",40,0)
 ;              Moved routines from %utNIT and %utNIT1 to %ut and %ut1
"RTN","ut",41,0)
 ;              Updated unit test routines (%utt1 to %utt6)
"RTN","ut",42,0)
 ;              Created M-UNIT TEST GROUP file at 17.9001 based on the 17.9001 file
"RTN","ut",43,0)
 Q
"RTN","ut",44,0)
 ;
"RTN","ut",45,0)
EN(%utRNAM,%utVERB,%utBREAK) ; .SR Entry point with primary test routine name, optional 1 for verbose output
"RTN","ut",46,0)
 N %utLIST,%utROU,%ut
"RTN","ut",47,0)
 I '+$G(%utVERB) S %utVERB=0
"RTN","ut",48,0)
 S %utLIST=1,%utROU(%utLIST)=%utRNAM
"RTN","ut",49,0)
 D SETUT
"RTN","ut",50,0)
 D EN1(.%utROU,%utLIST)
"RTN","ut",51,0)
 Q
"RTN","ut",52,0)
 ;
"RTN","ut",53,0)
SETUT ;
"RTN","ut",54,0)
 ; VEN/SMH 26JUL2013
"RTN","ut",55,0)
 I '($D(IO)#2) S IO=$P
"RTN","ut",56,0)
 S U="^"
"RTN","ut",57,0)
 ; VEN/SMH 26JUL2013 END
"RTN","ut",58,0)
 ;
"RTN","ut",59,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",60,0)
 S %ut("IO")=IO
"RTN","ut",61,0)
 S %ut=1 ; set to identify unit test being run check with $$ISUTEST^%ut()
"RTN","ut",62,0)
 ;
"RTN","ut",63,0)
 ; ZEXCEPT: %utBREAK
"RTN","ut",64,0)
 I $G(%utBREAK) S %ut("BREAK")=1
"RTN","ut",65,0)
 Q
"RTN","ut",66,0)
 ;
"RTN","ut",67,0)
EN1(%utROU,%utLIST) ;
"RTN","ut",68,0)
 ; VEN/SMH 26JUL2013 - This block is refactored to fix problems with
"RTN","ut",69,0)
 ; SETUP and TEARDOWN not happening at the right time
"RTN","ut",70,0)
 N %utERRL,%utK,%utI,%utJ,%utSTRT
"RTN","ut",71,0)
 ; ZEXCEPT: %utVERB   -- ARGUMENT TO EN
"RTN","ut",72,0)
 ; ZEXCEPT: %utGUI      -- CONDITIONALLY DEFINED BY GUINEXT
"RTN","ut",73,0)
 ; ZEXCEPT: %ut  -- NEWED IN EN
"RTN","ut",74,0)
 ;
"RTN","ut",75,0)
 ; Structure map for %ut
"RTN","ut",76,0)
 ; -- CURR = Counter for routine number. Used as sub in %utROU
"RTN","ut",77,0)
 ; -- ECNT = Entry point count in loop (cf. NERT); VEN/SMH - Needed?
"RTN","ut",78,0)
 ; -- FAIL = Number of failures
"RTN","ut",79,0)
 ; -- CHK  = Number of checks ran (TF/EQ/FAIL)
"RTN","ut",80,0)
 ; -- NENT = Number of entry points ran
"RTN","ut",81,0)
 ; -- ERRN = Number of errors
"RTN","ut",82,0)
 S %ut("CURR")=0,%ut("ECNT")=0,%ut("FAIL")=0,%ut("CHK")=0,%ut("NENT")=0,%ut("ERRN")=0
"RTN","ut",83,0)
 ;
"RTN","ut",84,0)
 ; -- GET LIST OF ROUTINES --
"RTN","ut",85,0)
 ; first get any tree of routines from this one
"RTN","ut",86,0)
 D GETTREE^%ut1(.%utROU,.%utLIST)
"RTN","ut",87,0)
 ;
"RTN","ut",88,0)
 ; -- STARTUP --
"RTN","ut",89,0)
 ; 070224 - following code added to allow one overall STARTUP code JLI
"RTN","ut",90,0)
 F  S %ut("CURR")=%ut("CURR")+1 Q:'$D(%utROU(%ut("CURR")))  D  I $G(%utSTRT)'="" D @%utSTRT Q
"RTN","ut",91,0)
 . I $T(@("STARTUP^"_%utROU(%ut("CURR"))))'="" S %utSTRT="STARTUP^"_%utROU(%ut("CURR"))
"RTN","ut",92,0)
 . Q
"RTN","ut",93,0)
 ; 070224 - end of addition JLI
"RTN","ut",94,0)
 ;
"RTN","ut",95,0)
 ;
"RTN","ut",96,0)
 ; Now process each routine that has been referenced
"RTN","ut",97,0)
 S %ut("CURR")=0
"RTN","ut",98,0)
 F  S %ut("CURR")=%ut("CURR")+1 Q:'$D(%utROU(%ut("CURR")))  D
"RTN","ut",99,0)
 . N %utETRY ; Test list to run
"RTN","ut",100,0)
 . ;
"RTN","ut",101,0)
 . ; Collect Test list.
"RTN","ut",102,0)
 . D CHEKTEST^%ut1(%utROU(%ut("CURR")),.%ut,.%utETRY)
"RTN","ut",103,0)
 . ;
"RTN","ut",104,0)
 . ; if a SETUP entry point exists, save it off in %ut
"RTN","ut",105,0)
 . N %utSETUP S %utSETUP="SETUP^"_%utROU(%ut("CURR"))
"RTN","ut",106,0)
 . S %ut("LINE")=$T(@%utSETUP) I %ut("LINE")'="" S %ut("SETUP")=%utSETUP
"RTN","ut",107,0)
 . K %utSETUP ; we're done!
"RTN","ut",108,0)
 . ;
"RTN","ut",109,0)
 . ; if a TEARDOWN entry point exists, ditto
"RTN","ut",110,0)
 . N %utTEARDOWN S %utTEARDOWN="TEARDOWN^"_%utROU(%ut("CURR"))
"RTN","ut",111,0)
 . S %ut("LINE")=$T(@%utTEARDOWN) I %ut("LINE")'="" S %ut("TEARDOWN")=%utTEARDOWN
"RTN","ut",112,0)
 . K %utTEARDOWN ; done here.
"RTN","ut",113,0)
 . ;
"RTN","ut",114,0)
 . ; VEN/SMH 26JUL2013 - this block changed to correct running of setup and teardown
"RTN","ut",115,0)
 . ; run each of the specified entry points
"RTN","ut",116,0)
 . ;
"RTN","ut",117,0)
 . ; == THIS FOR/DO BLOCK IS THE CENTRAL TEST RUNNER ==
"RTN","ut",118,0)
 . S %utI=0
"RTN","ut",119,0)
 . F  S %utI=$O(%utETRY(%utI)) Q:%utI'>0  S %ut("ENUM")=%ut("ERRN")+%ut("FAIL") D
"RTN","ut",120,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",121,0)
 . . ;
"RTN","ut",122,0)
 . . ; Run Set-up Code (only if present)
"RTN","ut",123,0)
 . . S %ut("ENT")=$G(%ut("SETUP")) ; Current entry
"RTN","ut",124,0)
 . . S %ut("NAME")="Set-up Code"
"RTN","ut",125,0)
 . . D:%ut("ENT")]"" @%ut("ENT")
"RTN","ut",126,0)
 . . ;
"RTN","ut",127,0)
 . . ; Run actual test
"RTN","ut",128,0)
 . . S %ut("ECNT")=%ut("ECNT")+1
"RTN","ut",129,0)
 . . S %ut("NAME")=%utETRY(%utI,"NAME")
"RTN","ut",130,0)
 . . S %ut("ENT")=%utETRY(%utI)_"^"_%utROU(%ut("CURR"))
"RTN","ut",131,0)
 . . I %utVERB,'$D(%utGUI) D VERBOSE1(.%utETRY,%utI) ; Say what we executed.
"RTN","ut",132,0)
 . . D @%ut("ENT")
"RTN","ut",133,0)
 . . ;
"RTN","ut",134,0)
 . . ; Run Teardown Code (only if present)
"RTN","ut",135,0)
 . . S %ut("ENT")=$G(%ut("TEARDOWN"))
"RTN","ut",136,0)
 . . S %ut("NAME")="Teardown Code"
"RTN","ut",137,0)
 . . D:%ut("ENT")]"" @%ut("ENT")
"RTN","ut",138,0)
 . . ;
"RTN","ut",139,0)
 . . ; ENUM = Number of errors + failures
"RTN","ut",140,0)
 . . ; Only print out the success message [OK] If our error number remains
"RTN","ut",141,0)
 . . ; the same as when we started the loop.
"RTN","ut",142,0)
 . . I %utVERB,'$D(%utGUI) D
"RTN","ut",143,0)
 . . . I %ut("ENUM")=(%ut("ERRN")+%ut("FAIL")) D VERBOSE(.%utETRY,%utI,1) I 1
"RTN","ut",144,0)
 . . . E  D VERBOSE(.%utETRY,%utI,0)
"RTN","ut",145,0)
 . ;
"RTN","ut",146,0)
 . ;
"RTN","ut",147,0)
 . ; keep a %utCNT of number of entry points executed across all routines
"RTN","ut",148,0)
 . S %ut("NENT")=%ut("NENT")+%ut("ENTN")
"RTN","ut",149,0)
 . Q
"RTN","ut",150,0)
 ;
"RTN","ut",151,0)
 ; -- SHUTDOWN --
"RTN","ut",152,0)
 ; 070224 - following code added to allow one overall SHUTDOWN code JLI
"RTN","ut",153,0)
 N XTFINISH
"RTN","ut",154,0)
 S %ut("CURR")=0
"RTN","ut",155,0)
 F  S %ut("CURR")=%ut("CURR")+1 Q:'$D(%utROU(%ut("CURR")))  D  I $G(XTFINISH)'="" D @XTFINISH Q
"RTN","ut",156,0)
 . I $T(@("SHUTDOWN^"_%utROU(%ut("CURR"))))'="" S XTFINISH="SHUTDOWN^"_%utROU(%ut("CURR"))
"RTN","ut",157,0)
 . Q
"RTN","ut",158,0)
 ; 070224 - End of addition JLI
"RTN","ut",159,0)
 ; and output the results
"RTN","ut",160,0)
 D SETIO
"RTN","ut",161,0)
 W !!,"Ran ",%utLIST," Routine",$S(%utLIST>1:"s",1:""),", ",%ut("NENT")," Entry Tag",$S(%ut("NENT")>1:"s",1:"")
"RTN","ut",162,0)
 W !,"Checked ",%ut("CHK")," test",$S(%ut("CHK")>1:"s",1:""),", with ",%ut("FAIL")," failure",$S(%ut("FAIL")'=1:"s",1:"")," and encountered ",%ut("ERRN")," error",$S(%ut("ERRN")'=1:"s",1:""),"."
"RTN","ut",163,0)
 D RESETIO
"RTN","ut",164,0)
 Q
"RTN","ut",165,0)
 ; -- end EN1
"RTN","ut",166,0)
VERBOSE(%utETRY,%utI,SUCCESS) ; Say whether we succeeded or failed.
"RTN","ut",167,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",168,0)
 D SETIO
"RTN","ut",169,0)
 N I F I=$X+3:1:73 W "-"
"RTN","ut",170,0)
 W ?73
"RTN","ut",171,0)
 I $G(SUCCESS) W "[OK]"
"RTN","ut",172,0)
 E  W "[FAIL]"
"RTN","ut",173,0)
 D RESETIO
"RTN","ut",174,0)
 Q
"RTN","ut",175,0)
 ;
"RTN","ut",176,0)
VERBOSE1(%utETRY,%utI) ; Print out the entry point info
"RTN","ut",177,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",178,0)
 D SETIO
"RTN","ut",179,0)
 W !,%utETRY(%utI) I $G(%utETRY(%utI,"NAME"))'="" W " - ",%utETRY(%utI,"NAME")
"RTN","ut",180,0)
 D RESETIO
"RTN","ut",181,0)
 Q
"RTN","ut",182,0)
CHKTF(XTSTVAL,XTERMSG) ; Entry point for checking True or False values
"RTN","ut",183,0)
 ; ZEXCEPT: %utERRL,%utGUI - CREATED IN SETUP, KILLED IN END
"RTN","ut",184,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",185,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",186,0)
 I '$D(XTSTVAL) D NVLDARG Q
"RTN","ut",187,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut",188,0)
 S %ut("CHK")=$G(%ut("CHK"))+1
"RTN","ut",189,0)
 I '$D(%utGUI) D
"RTN","ut",190,0)
 . D SETIO
"RTN","ut",191,0)
 . I 'XTSTVAL W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " D
"RTN","ut",192,0)
 . . W XTERMSG,! S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",193,0)
 . . I $D(%ut("BREAK")) BREAK  ; Break upon failure
"RTN","ut",194,0)
 . . Q
"RTN","ut",195,0)
 . I XTSTVAL W "."
"RTN","ut",196,0)
 . D RESETIO
"RTN","ut",197,0)
 . Q
"RTN","ut",198,0)
 I $D(%utGUI),'XTSTVAL S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut",199,0)
 Q
"RTN","ut",200,0)
 ;
"RTN","ut",201,0)
CHKEQ(XTEXPECT,XTACTUAL,XTERMSG) ; Entry point for checking values to see if they are EQUAL
"RTN","ut",202,0)
 N FAILMSG
"RTN","ut",203,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut",204,0)
 ; ZEXCEPT: %ut  -- NEWED IN EN
"RTN","ut",205,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",206,0)
 I '$D(XTEXPECT)!'$D(XTACTUAL) D NVLDARG Q  ; JLI 140824 changed from AND to OR, since both necessary, but only one might be entered
"RTN","ut",207,0)
 S XTACTUAL=$G(XTACTUAL),XTEXPECT=$G(XTEXPECT)
"RTN","ut",208,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut",209,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",210,0)
 I XTEXPECT'=XTACTUAL S FAILMSG="<"_XTEXPECT_"> vs <"_XTACTUAL_"> - "
"RTN","ut",211,0)
 I '$D(%utGUI) D
"RTN","ut",212,0)
 . D SETIO
"RTN","ut",213,0)
 . I XTEXPECT'=XTACTUAL W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W FAILMSG,XTERMSG,! D
"RTN","ut",214,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",215,0)
     . . I $D(%ut("BREAK")) BREAK  ; Break upon failure
"RTN","ut",216,0)
 . . Q
"RTN","ut",217,0)
 . E  W "."
"RTN","ut",218,0)
 . D RESETIO
"RTN","ut",219,0)
 . Q
"RTN","ut",220,0)
 I $D(%utGUI),XTEXPECT'=XTACTUAL S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_FAILMSG_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut",221,0)
 Q
"RTN","ut",222,0)
 ;
"RTN","ut",223,0)
FAIL(XTERMSG) ; Entry point for generating a failure message
"RTN","ut",224,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut",225,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",226,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",227,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut",228,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",229,0)
 I '$D(%utGUI) D
"RTN","ut",230,0)
 . D SETIO
"RTN","ut",231,0)
 . W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W XTERMSG,! D
"RTN","ut",232,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",233,0)
 . . I $D(%ut("BREAK")) BREAK  ; Break upon failure
"RTN","ut",234,0)
 . . Q
"RTN","ut",235,0)
 . D RESETIO
"RTN","ut",236,0)
 . Q
"RTN","ut",237,0)
 I $D(%utGUI) S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut",238,0)
 Q
"RTN","ut",239,0)
SUCCEED ; Entry point for forcing a success (Thx David Whitten)
"RTN","ut",240,0)
 ; ZEXCEPT: %utERRL,%utGUI - CREATED IN SETUP, KILLED IN END
"RTN","ut",241,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",242,0)
 ; Switch IO and write out the dot for activity
"RTN","ut",243,0)
 I '$D(%utGUI) D
"RTN","ut",244,0)
 . D SETIO
"RTN","ut",245,0)
 . W "."
"RTN","ut",246,0)
 . D RESETIO
"RTN","ut",247,0)
 ;
"RTN","ut",248,0)
 ; Increment test counter
"RTN","ut",249,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",250,0)
 QUIT
"RTN","ut",251,0)
 ;
"RTN","ut",252,0)
CHKLEAKS(%utCODE,%utLOC,%utINPT) ; functionality to check for variable leaks on executing a section of code
"RTN","ut",253,0)
 ; %utCODE - A string that specifies the code that is to be XECUTED and checked for leaks.
"RTN","ut",254,0)
 ;            this should be a complete piece of code (e.g., "S X=$$NOW^XLFDT()" or "D EN^%ut(""ROUNAME"")")
"RTN","ut",255,0)
 ; %utLOC  - A string that is used to indicate the code tested for variable leaks
"RTN","ut",256,0)
 ; %utINPT - An optional variable which may be passed by reference.  This may
"RTN","ut",257,0)
 ;           be used to pass any variable values, etc. into the code to be
"RTN","ut",258,0)
 ;           XECUTED.  In this case, set the subscript to the variable name and the
"RTN","ut",259,0)
 ;           value of the subscripted variable to the desired value of the subscript.
"RTN","ut",260,0)
 ;              e.g., (using NAME as my current namespace)
"RTN","ut",261,0)
 ;                   S CODE="S %utINPT=$$ENTRY^ROUTINE(ZZVALUE1,ZZVALUE2)"
"RTN","ut",262,0)
 ;                   S NAMELOC="ENTRY^ROUTINE leak test"   (or simply "ENTRY^ROUTINE")
"RTN","ut",263,0)
 ;                   S NAMEINPT("ZZVALUE1")=ZZVALUE1
"RTN","ut",264,0)
 ;                   S NAMEINPT("ZZVALUE2")=ZZVALUE2
"RTN","ut",265,0)
 ;                   D CHKLEAKS^%ut(CODE,NAMELOC,.NAMEINPT)
"RTN","ut",266,0)
 ;
"RTN","ut",267,0)
 ;           If part of a unit test, any leaked variables in ENTRY^ROUTINE which result
"RTN","ut",268,0)
 ;           from running the code with the variables indicated will be shown as FAILUREs.
"RTN","ut",269,0)
 ;
"RTN","ut",270,0)
 ;           If called outside of a unit test, any leaked variables will be printed to the
"RTN","ut",271,0)
 ;           current device.
"RTN","ut",272,0)
 ;
"RTN","ut",273,0)
 N (%utCODE,%utLOC,%utINPT,DUZ,IO,U,%utERRL,%ut,%utGUI,%utERR,%utI,%utJ,%utK,%utLIST,%utROU,%utSTRT,XTGUISEP)
"RTN","ut",274,0)
 ; ZEXCEPT: %ut - part of exclusive NEW TESTS FOR EXISTENCE ONLY
"RTN","ut",275,0)
 ; ZEXCEPT: %utVAR - handled by exclusive NEW
"RTN","ut",276,0)
 ;
"RTN","ut",277,0)
 ; ACTIVATE ANY VARIABLES PASSED AS SUBSCRIPTS TO %utINPT TO THEIR VALUES
"RTN","ut",278,0)
 S %utVAR=" " F  S %utVAR=$O(%utINPT(%utVAR)) Q:%utVAR=""  S (@%utVAR)=%utINPT(%utVAR)
"RTN","ut",279,0)
 X %utCODE
"RTN","ut",280,0)
 N ZZUTVAR S ZZUTVAR="%"
"RTN","ut",281,0)
 I $G(%ut)=1 D
"RTN","ut",282,0)
 . I $D(@ZZUTVAR),'$D(%utINPT(ZZUTVAR)) D FAIL^%ut(%utLOC_" VARIABLE LEAK: "_ZZUTVAR)
"RTN","ut",283,0)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,3)'="%ut",'$D(%utINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,%ut,XTGUISEP,"'[(","_ZZUTVAR_",") D FAIL^%ut(%utLOC_" VARIABLE LEAK: "_ZZUTVAR)
"RTN","ut",284,0)
 . Q
"RTN","ut",285,0)
 I '($G(%ut)=1) D
"RTN","ut",286,0)
 . I $D(@ZZUTVAR),'$D(%utINPT(ZZUTVAR)) W !,%utLOC_" VARIABLE LEAK: "_ZZUTVAR
"RTN","ut",287,0)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,3)'="%ut",'$D(%utINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,%ut,XTGUISEP,"'[(","_ZZUTVAR_",") W !,%utLOC_" VARIABLE LEAK: "_ZZUTVAR
"RTN","ut",288,0)
 . Q
"RTN","ut",289,0)
 Q
"RTN","ut",290,0)
 ;
"RTN","ut",291,0)
NVLDARG ; generate message for invalid arguments to test
"RTN","ut",292,0)
 N XTERMSG
"RTN","ut",293,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",294,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut",295,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",296,0)
 S XTERMSG="NO VALUES INPUT TO CHKEQ^%ut - no evaluation possible"
"RTN","ut",297,0)
 I '$D(%utGUI) D
"RTN","ut",298,0)
 . D SETIO
"RTN","ut",299,0)
 . W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W XTERMSG,! D
"RTN","ut",300,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",301,0)
 . . Q
"RTN","ut",302,0)
 . D RESETIO
"RTN","ut",303,0)
 . Q
"RTN","ut",304,0)
 I $D(%utGUI) S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut",305,0)
 Q
"RTN","ut",306,0)
 ;
"RTN","ut",307,0)
ERROR ; record errors
"RTN","ut",308,0)
 ; ZEXCEPT: %utERRL,%utGUI,%utERR -CREATED IN SETUP, KILLED IN END
"RTN","ut",309,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",310,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",311,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",312,0)
 I '$D(%utGUI) D ERROR1
"RTN","ut",313,0)
 I $D(%utGUI) D
"RTN","ut",314,0)
 . S %ut("CNT")=%ut("CNT")+1
"RTN","ut",315,0)
 . S %utERR=%utERR+1
"RTN","ut",316,0)
 . S @%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"ERROR"_XTGUISEP_$S(+$SY=47:$ZS,1:$ZE)
"RTN","ut",317,0)
 . Q
"RTN","ut",318,0)
 S @($S(+$SY=47:"$ZS",1:"$ZE")_"="_""""""),$EC=""
"RTN","ut",319,0)
 Q
"RTN","ut",320,0)
 ;
"RTN","ut",321,0)
ERROR1 ;
"RTN","ut",322,0)
 I $G(%ut("BREAK")) BREAK  ; if we are asked to break upon error, please do so!
"RTN","ut",323,0)
 ; ZEXCEPT: %utERRL -CREATED IN SETUP, KILLED IN END
"RTN","ut",324,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",325,0)
 D SETIO
"RTN","ut",326,0)
 W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - Error: " W $S(+$SY=47:$ZS,1:$ZE),! D
"RTN","ut",327,0)
 . S %ut("ERRN")=%ut("ERRN")+1,%utERRL(%ut("ERRN"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=$S(+$SY=47:$ZS,1:$ZE),%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",328,0)
 . Q
"RTN","ut",329,0)
 D RESETIO
"RTN","ut",330,0)
 Q
"RTN","ut",331,0)
SETIO ; Set M-Unit Device to write the results to...
"RTN","ut",332,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",333,0)
 I $IO'=%ut("IO") S (IO(0),%ut("DEV","OLD"))=$IO USE %ut("IO") SET IO=$IO
"RTN","ut",334,0)
 QUIT
"RTN","ut",335,0)
 ;
"RTN","ut",336,0)
RESETIO ; Reset $IO back to the original device if we changed it.
"RTN","ut",337,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",338,0)
 I $D(%ut("DEV","OLD")) S IO(0)=%ut("IO") U %ut("DEV","OLD") S IO=$IO K %ut("DEV","OLD")
"RTN","ut",339,0)
 QUIT
"RTN","ut",340,0)
 ;
"RTN","ut",341,0)
ISUTEST() ; .SUPPORTED API TO DETERMINE IF CURRENTLY IN UNIT TEST
"RTN","ut",342,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",343,0)
 Q $G(%ut)=1
"RTN","ut",344,0)
 ;
"RTN","ut",345,0)
PICKSET ; .OPT Interactive selection of MUnit Test Group
"RTN","ut",346,0)
 N DIC,Y,%utROU,%utLIST,DIR
"RTN","ut",347,0)
 S DIC=17.9001,DIC(0)="AEQM" D ^DIC Q:Y'>0  W !
"RTN","ut",348,0)
 D GETSET(+Y,.%utROU,.%utLIST)
"RTN","ut",349,0)
 N DIC,Y,%ut
"RTN","ut",350,0)
 D SETUT
"RTN","ut",351,0)
 D EN1(.%utROU,%utLIST)
"RTN","ut",352,0)
 S DIR(0)="EA",DIR("A")="Enter RETURN to continue:" D ^DIR K DIR
"RTN","ut",353,0)
 Q
"RTN","ut",354,0)
 ;
"RTN","ut",355,0)
RUNSET(SETNAME,VERBOSE) ; .SR Run with Specified Selection of MUnit Test Group
"RTN","ut",356,0)
 N Y,%utROU,%utLIST,%utVERB
"RTN","ut",357,0)
 Q:$G(SETNAME)=""
"RTN","ut",358,0)
 S %utVERB=$G(VERBOSE,0)
"RTN","ut",359,0)
 S Y=+$$FIND1^DIC(17.9001,"","X",SETNAME) Q:Y'>0
"RTN","ut",360,0)
 D GETSET(Y,.%utROU,.%utLIST)
"RTN","ut",361,0)
 N Y,SETNAME,%ut
"RTN","ut",362,0)
 D SETUT
"RTN","ut",363,0)
 D EN1(.%utROU,%utLIST)
"RTN","ut",364,0)
 Q
"RTN","ut",365,0)
 ;
"RTN","ut",366,0)
 ; DOSET CAN BE USED TO RUN A SET OF TESTS BASED ON THE IEN IN THE MUNIT TEST GROUP file (#17.9001)
"RTN","ut",367,0)
DOSET(IEN,%utVERB) ; 140731 JLI added %utVERB as a second argument
"RTN","ut",368,0)
 ; IEN - Internal entry number for selected set of tests in the MUNIT TEST GROUP file (#17.9001)
"RTN","ut",369,0)
 ; %utVERB - optional input that indicates verbose output is permitted
"RTN","ut",370,0)
 ;
"RTN","ut",371,0)
 N %utROU,%utLIST
"RTN","ut",372,0)
 I '$D(%utVERB) S %utVERB=0
"RTN","ut",373,0)
 S %utLIST=0
"RTN","ut",374,0)
 D GETSET($G(IEN),.%utROU,.%utLIST)
"RTN","ut",375,0)
 I %utLIST>0  N IEN,%ut D SETUT,EN1(.%utROU,%utLIST)
"RTN","ut",376,0)
 Q
"RTN","ut",377,0)
 ;
"RTN","ut",378,0)
GETSET(IEN,%utROU,%utLIST) ;  JLI 140731 - called from PICKSET, RUNSET, DOSET, GUISET
"RTN","ut",379,0)
 N IENS,%utROOT
"RTN","ut",380,0)
 S IENS=IEN_"," D GETS^DIQ(17.9001,IENS,"1*","","%utROOT")
"RTN","ut",381,0)
 S %utLIST=0,IENS="" F  S IENS=$O(%utROOT(17.90011,IENS)) Q:IENS=""  S %utLIST=%utLIST+1,%utROU(%utLIST)=%utROOT(17.90011,IENS,.01)
"RTN","ut",382,0)
 Q
"RTN","ut",383,0)
 ;
"RTN","ut",384,0)
GUISET(%utRSLT,XTSET) ; Entry point for GUI start with selected Test Set IEN - called by %ut-TEST GROUP LOAD rpc
"RTN","ut",385,0)
 N %utROU,%utLIST,%ut
"RTN","ut",386,0)
 D SETUT
"RTN","ut",387,0)
 S %ut("RSLT")=$NA(^TMP("MUNIT-%utRSLT",$J)) K @%ut("RSLT")
"RTN","ut",388,0)
 D GETSET(XTSET,.%utROU,.%utLIST)
"RTN","ut",389,0)
 D GETLIST(.%utROU,%utLIST,%ut("RSLT"))
"RTN","ut",390,0)
 S @%ut("RSLT")@(1)=(@%ut("RSLT")@(1))_"^1" ; 110719 mark as new version
"RTN","ut",391,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",392,0)
 Q
"RTN","ut",393,0)
 ;
"RTN","ut",394,0)
GUILOAD(%utRSLT,%utROUN) ; Entry point for GUI start with %utROUN containing primary routine name - called by %ut-TEST LOAD rpc
"RTN","ut",395,0)
 N %utROU,%ut
"RTN","ut",396,0)
 D SETUT
"RTN","ut",397,0)
 S %ut("RSLT")=$NA(^TMP("MUNIT-%utRSLT",$J)) K @%ut("RSLT")
"RTN","ut",398,0)
 S %utROU(1)=%utROUN
"RTN","ut",399,0)
 D GETLIST(.%utROU,1,%ut("RSLT"))
"RTN","ut",400,0)
 S @%ut("RSLT")@(1)=(@%ut("RSLT")@(1))_"^1" ; 110719 mark as new version
"RTN","ut",401,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",402,0)
 Q
"RTN","ut",403,0)
 ;
"RTN","ut",404,0)
GETLIST(%utROU,%utLIST,%utRSLT) ; called from GUISET, GUILOAD
"RTN","ut",405,0)
 N I,%utROUL,%utROUN,%ut,XTCOMNT,XTVALUE,%utCNT
"RTN","ut",406,0)
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J)) K @XTVALUE
"RTN","ut",407,0)
 S %utCNT=0,XTCOMNT=""
"RTN","ut",408,0)
 D GETTREE^%ut1(.%utROU,%utLIST)
"RTN","ut",409,0)
 F I=1:1 Q:'$D(%utROU(I))  S %utROUL(%utROU(I))=""
"RTN","ut",410,0)
 S %utROUN="" F  S %utROUN=$O(%utROUL(%utROUN)) Q:%utROUN=""  D LOAD(%utROUN,.%utCNT,XTVALUE,XTCOMNT,.%utROUL)
"RTN","ut",411,0)
 M @%utRSLT=@XTVALUE
"RTN","ut",412,0)
 K @%utRSLT@("SHUTDOWN")
"RTN","ut",413,0)
 K @%utRSLT@("STARTUP")
"RTN","ut",414,0)
 S @XTVALUE@("LASTROU")="" ; Use this to keep track of place in routines
"RTN","ut",415,0)
 Q
"RTN","ut",416,0)
 ;
"RTN","ut",417,0)
 ; generate list of unit test routines, entry points and comments on test for entry point
"RTN","ut",418,0)
LOAD(%utROUN,%utNCNT,XTVALUE,XTCOMNT,%utROUL) ; called from GETLIST, and recursively from LOAD
"RTN","ut",419,0)
 I $T(@("^"_%utROUN))="" S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_"^^*** ERROR - ROUTINE NAME NOT FOUND" Q
"RTN","ut",420,0)
 S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_U_XTCOMNT
"RTN","ut",421,0)
 ;N %utI,XTX1,XTX2,LINE
"RTN","ut",422,0)
 N %utI,XTX1,XTX2,LINE,LIST,I
"RTN","ut",423,0)
 ; 100622 JLI added code to identify STARTUP and TEARDOWN
"RTN","ut",424,0)
 I $T(@("STARTUP^"_%utROUN))'="",'$D(@XTVALUE@("STARTUP")) S @XTVALUE@("STARTUP")="STARTUP^"_%utROUN
"RTN","ut",425,0)
 I $T(@("SHUTDOWN^"_%utROUN))'="",'$D(@XTVALUE@("SHUTDOWN")) S @XTVALUE@("SHUTDOWN")="SHUTDOWN^"_%utROUN
"RTN","ut",426,0)
 ; JLI 140731 handle @TEST identified test tags
"RTN","ut",427,0)
 D NEWSTYLE^%ut1(.LIST,%utROUN)
"RTN","ut",428,0)
 F I=1:1:LIST S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_LIST(I)
"RTN","ut",429,0)
 ; JLI 140731 end of @TEST addition
"RTN","ut",430,0)
 F %utI=1:1 S LINE=$T(@("XTENT+"_%utI_"^"_%utROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTX2=$P(LINE,";",4),%utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_XTX1_U_XTX2
"RTN","ut",431,0)
 F %utI=1:1 S LINE=$T(@("XTROU+"_%utI_"^"_%utROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTCOMNT=$P(LINE,";",4) I '$D(%utROUL(XTX1)) S %utROUL(XTX1)="" D LOAD(XTX1,.%utNCNT,XTVALUE,XTCOMNT,.%utROUL)
"RTN","ut",432,0)
 Q
"RTN","ut",433,0)
 ;
"RTN","ut",434,0)
GUINEXT(%utRSLT,%utLOC,XTGUISEP) ; Entry point for GUI execute next test - called by %ut-TEST NEXT rpc
"RTN","ut",435,0)
 ; XTGUISEP - added 110719 to provide for changing separator for GUI
"RTN","ut",436,0)
 ;            return from ^ to another value ~~^~~  so that data returned
"RTN","ut",437,0)
 ;            is not affected by ^ values in the data - if not present
"RTN","ut",438,0)
 ;            sets value to default ^
"RTN","ut",439,0)
 N %utETRY,%utROUT,XTOLROU,XTVALUE,%utERR,%utGUI
"RTN","ut",440,0)
 N %ut
"RTN","ut",441,0)
 I $G(XTGUISEP)="" S XTGUISEP="^"
"RTN","ut",442,0)
 D SETUT
"RTN","ut",443,0)
 S %ut("LOC")=%utLOC
"RTN","ut",444,0)
 S %ut("CURR")=0,%ut("ECNT")=0,%ut("FAIL")=0,%ut("CHK")=0,%ut("NENT")=0,%ut("ERRN")=0
"RTN","ut",445,0)
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J))
"RTN","ut",446,0)
 S %ut("RSLT")=$NA(^TMP("GUINEXT",$J)) K @%ut("RSLT")
"RTN","ut",447,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",448,0)
 S %utETRY=$P(%utLOC,U),%utROUT=$P(%utLOC,U,2),XTOLROU=$G(@XTVALUE@("LASTROU"))
"RTN","ut",449,0)
 S %utGUI=1
"RTN","ut",450,0)
 S %ut("CHK")=0,%ut("CNT")=1,%utERR=0
"RTN","ut",451,0)
 ; I %utROUT'=XTOLROU D  I %utROUT="" S @%utRSLT@(1)="" K @XTVALUE Q  ;140731 JLI - commented out
"RTN","ut",452,0)
 ;D  I %utROUT="" S @%utRSLT@(1)="" K @XTVALUE Q  ; 140731 JLI - replaced previous line - moves check for SHUTDOWN at end of processing
"RTN","ut",453,0)
 D  I %utROUT="" S @%utRSLT@(1)="" Q  ; 140829 JLI - Have to leave XTVALUE intact, in case they simply run again for STARTUP, etc.
"RTN","ut",454,0)
 . I XTOLROU="",$D(@XTVALUE@("STARTUP")) D
"RTN","ut",455,0)
 . . S %ut("LOC")=@XTVALUE@("STARTUP")
"RTN","ut",456,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",457,0)
 . . D @(@XTVALUE@("STARTUP"))
"RTN","ut",458,0)
 . . Q
"RTN","ut",459,0)
 . S @XTVALUE@("LASTROU")=%utROUT I %utROUT'="",$T(@("SETUP^"_%utROUT))'="" D
"RTN","ut",460,0)
 . . S %ut("LOC")="SETUP^"_%utROUT
"RTN","ut",461,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",462,0)
 . . D @("SETUP^"_%utROUT)
"RTN","ut",463,0)
 . . Q
"RTN","ut",464,0)
 . I %utROUT="",$D(@XTVALUE@("SHUTDOWN")) D
"RTN","ut",465,0)
 . . S %ut("LOC")=@XTVALUE@("SHUTDOWN")
"RTN","ut",466,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",467,0)
 . . D @(@XTVALUE@("SHUTDOWN"))
"RTN","ut",468,0)
 . . Q
"RTN","ut",469,0)
 . Q
"RTN","ut",470,0)
 S %ut("LOC")=%utLOC
"RTN","ut",471,0)
 S %ut("CHK")=0,%ut("CNT")=1,%utERR=0
"RTN","ut",472,0)
 D  ; to limit range of error trap so we continue through other tests
"RTN","ut",473,0)
 . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",474,0)
 . D @%ut("LOC")
"RTN","ut",475,0)
 . Q
"RTN","ut",476,0)
 I $T(@("TEARDOWN^"_%utROUT))'="" D
"RTN","ut",477,0)
 . S %ut("LOC")="TEARDOWN^"_%utROUT
"RTN","ut",478,0)
 . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",479,0)
 . D @("TEARDOWN^"_%utROUT)
"RTN","ut",480,0)
 . Q
"RTN","ut",481,0)
 S @%ut("RSLT")@(1)=%ut("CHK")_XTGUISEP_(%ut("CNT")-1-%utERR)_XTGUISEP_%utERR
"RTN","ut",482,0)
 Q
"RTN","ut",483,0)
 ;
"RTN","ut",484,0)
TESTCOVR ; entry under coverage analysis
"RTN","ut",485,0)
 D ENTRY^%uttcovr ; does analysis while running various unit tests
"RTN","ut",486,0)
 Q
"RTN","ut",487,0)
 ;
"RTN","ut1")
0^2^B87092328
"RTN","ut1",1,0)
%ut1 ;VEN/SMH/JLI - CONTINUATION OF M-UNIT PROCESSING ;09/10/14  14:27
"RTN","ut1",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","ut1",3,0)
 ;
"RTN","ut1",4,0)
 ;following is original header from XTMUNIT1 in unreleased patch XT*7.3*81 VA code
"RTN","ut1",5,0)
 ;XTMUNIT1    ;JLI/FO-OAK-CONTINUATION OF UNIT TEST ROUTINE ;2014-04-17  5:26 PM
"RTN","ut1",6,0)
 ;;7.3;TOOLKIT;**81**;APR 25 1995;Build 24
"RTN","ut1",7,0)
 ;
"RTN","ut1",8,0)
 ;
"RTN","ut1",9,0)
 ; Original by Dr. Joel Ivey
"RTN","ut1",10,0)
 ; Major contributions by Dr. Sam Habiel
"RTN","ut1",11,0)
 ;
"RTN","ut1",12,0)
 ; Changes:
"RTN","ut1",13,0)
 ; 130726 SMH - Moved test collection logic from %utUNIT to here (multiple places)
"RTN","ut1",14,0)
 ; 131218 SMH - dependence on XLFSTR removed
"RTN","ut1",15,0)
 ; 131218 SMH - CHEKTEST refactored to use $TEXT instead of ^%ZOSF("LOAD")
"RTN","ut1",16,0)
 ; 131218 SMH - CATCHERR now nulls out $ZS if on GT.M
"RTN","ut1",17,0)
 ;
"RTN","ut1",18,0)
 Q
"RTN","ut1",19,0)
 ;
"RTN","ut1",20,0)
CHEKTEST(%utROU,%ut,%utUETRY) ; Collect Test list.
"RTN","ut1",21,0)
 ; %utROU - input - Name of routine to check for tags with @TEST attribute
"RTN","ut1",22,0)
 ; %ut - input/output - passed by reference
"RTN","ut1",23,0)
 ; %utUETRY - input/output - passed by reference
"RTN","ut1",24,0)
 ;
"RTN","ut1",25,0)
 ; Test list collected in two ways:
"RTN","ut1",26,0)
 ; - @TEST on labellines
"RTN","ut1",27,0)
 ; - Offsets of XTENT
"RTN","ut1",28,0)
 ;
"RTN","ut1",29,0)
 S %ut("ENTN")=0 ; Number of test, sub to %utUETRY.
"RTN","ut1",30,0)
 ;
"RTN","ut1",31,0)
 ; This stanza and everything below is for collecting @TEST.
"RTN","ut1",32,0)
 ; VEN/SMH - block refactored to use $TEXT instead of ^%ZOSF("LOAD")
"RTN","ut1",33,0)
 N I,LIST
"RTN","ut1",34,0)
 S I=$L($T(@(U_%utROU))) I I<0 Q "-1^Invalid Routine Name"
"RTN","ut1",35,0)
 ; 140731 JLI - the following SMH code is replaced by the code below
"RTN","ut1",36,0)
 ; Complexity galore: $TEXT loops through routine
"RTN","ut1",37,0)
 ; IF tab or space isn't the first character ($C(9,32)) and line contains @TEST
"RTN","ut1",38,0)
 ; Load that line as a testing entry point
"RTN","ut1",39,0)
 ; F I=1:1 S LINE=$T(@("+"_I_U_%utROU)) Q:LINE=""  I $C(9,32)'[$E(LINE),$$UP(LINE)["@TEST" D
"RTN","ut1",40,0)
 ; . N TAGNAME,CHAR,NPAREN S TAGNAME="",NPAREN=0
"RTN","ut1",41,0)
 ; . F  Q:LINE=""  S CHAR=$E(LINE),LINE=$E(LINE,2,999) Q:CHAR=""  Q:" ("[CHAR  S TAGNAME=TAGNAME_CHAR
"RTN","ut1",42,0)
 ; . ; should be no paren or arguments
"RTN","ut1",43,0)
 ; . I CHAR="(" Q
"RTN","ut1",44,0)
 ; . F  Q:LINE=""  S CHAR=$E(LINE) Q:" ;"'[CHAR  S LINE=$E(LINE,2,999)
"RTN","ut1",45,0)
 ; . I $$UP($E(LINE,1,5))="@TEST" S LINE=$E(LINE,6,999) D
"RTN","ut1",46,0)
 ; . . S %ut("ENTN")=%ut("ENTN")+1,%utUETRY(%ut("ENTN"))=TAGNAME
"RTN","ut1",47,0)
 ; . . F  Q:LINE=""  S CHAR=$E(LINE) Q:CHAR?1AN  S LINE=$E(LINE,2,999)
"RTN","ut1",48,0)
 ; . . S %utUETRY(%ut("ENTN"),"NAME")=LINE
"RTN","ut1",49,0)
 ; JLI 140731 - end of code replaced by following code
"RTN","ut1",50,0)
 ; JLI 140731 - the following code replaces the code above
"RTN","ut1",51,0)
 D NEWSTYLE(.LIST,%utROU)
"RTN","ut1",52,0)
 F I=1:1:LIST S %ut("ENTN")=%ut("ENTN")+1,%utUETRY(%ut("ENTN"))=$P(LIST(I),U),%utUETRY(%ut("ENTN"),"NAME")=$P(LIST(I),U,2,99)
"RTN","ut1",53,0)
 ; JLI 140731 - end of replacement code
"RTN","ut1",54,0)
 ;
"RTN","ut1",55,0)
 ;
"RTN","ut1",56,0)
 ; This Stanza is to collect XTENT offsets
"RTN","ut1",57,0)
 N %utUI F %utUI=1:1 S %ut("ELIN")=$T(@("XTENT+"_%utUI_"^"_%utROU)) Q:$P(%ut("ELIN"),";",3)=""  D
"RTN","ut1",58,0)
 . S %ut("ENTN")=%ut("ENTN")+1,%utUETRY(%ut("ENTN"))=$P(%ut("ELIN"),";",3),%utUETRY(%ut("ENTN"),"NAME")=$P(%ut("ELIN"),";",4)
"RTN","ut1",59,0)
 . Q
"RTN","ut1",60,0)
 ;
"RTN","ut1",61,0)
 QUIT
"RTN","ut1",62,0)
 ;
"RTN","ut1",63,0)
 ; VEN/SMH 26JUL2013 - Moved GETTREE here.
"RTN","ut1",64,0)
GETTREE(%utROU,%utULIST) ;
"RTN","ut1",65,0)
 ; first get any other routines this one references for running subsequently
"RTN","ut1",66,0)
 ; then any that they refer to as well
"RTN","ut1",67,0)
 ; this builds a tree of all routines referred to by any routine including each only once
"RTN","ut1",68,0)
 N %utUK,%utUI,%utUJ,%utURNAM,%utURLIN
"RTN","ut1",69,0)
 F %utUK=1:1 Q:'$D(%utROU(%utUK))  D
"RTN","ut1",70,0)
 . F %utUI=1:1 S %utURLIN=$T(@("XTROU+"_%utUI_"^"_%utROU(%utUK))) S %utURNAM=$P(%utURLIN,";",3) Q:%utURNAM=""  D
"RTN","ut1",71,0)
 . . F %utUJ=1:1:%utULIST I %utROU(%utUJ)=%utURNAM S %utURNAM="" Q
"RTN","ut1",72,0)
 . . I %utURNAM'="",$T(@("+1^"_%utURNAM))="" W:'$D(XWBOS) "Referenced routine ",%utURNAM," not found.",! Q
"RTN","ut1",73,0)
 . . S:%utURNAM'="" %utULIST=%utULIST+1,%utROU(%utULIST)=%utURNAM
"RTN","ut1",74,0)
 QUIT
"RTN","ut1",75,0)
 ;
"RTN","ut1",76,0)
NEWSTYLE(LIST,ROUNAME) ; JLI 140726 identify and return list of newstyle tags or entries for this routine
"RTN","ut1",77,0)
 ; LIST - input, passed by reference - returns containing array with list of tags identified as tests
"RTN","ut1",78,0)
 ;                   LIST indicates number of tags identified, LIST(n)=tag^test_info where tag is entry point for test
"RTN","ut1",79,0)
 ; ROUNAME - input - routine name in which tests should be identified
"RTN","ut1",80,0)
 ;
"RTN","ut1",81,0)
 N I,VALUE,LINE
"RTN","ut1",82,0)
 K LIST S LIST=0
"RTN","ut1",83,0)
 ; search routine by line for a tag and @TEST declaration
"RTN","ut1",84,0)
 F I=1:1 S LINE=$T(@("+"_I_"^"_ROUNAME)) Q:LINE=""  S VALUE=$$CHECKTAG(LINE) I VALUE'="" S LIST=LIST+1,LIST(LIST)=VALUE
"RTN","ut1",85,0)
 Q
"RTN","ut1",86,0)
 ;
"RTN","ut1",87,0)
CHECKTAG(LINE) ; JLI 140726 check line to determine @test TAG
"RTN","ut1",88,0)
 ; LINE - input - Line of code to be checked
"RTN","ut1",89,0)
 ; returns null line if not @TEST line, otherwise TAG^NOTE
"RTN","ut1",90,0)
 N TAG,NOTE,CHAR
"RTN","ut1",91,0)
 I $E(LINE)=" " Q "" ; test entry must have a tag
"RTN","ut1",92,0)
 I $$UP(LINE)'["@TEST" Q "" ; must have @TEST declaration
"RTN","ut1",93,0)
 I $P($$UP(LINE),"@TEST")["(" Q "" ; can't have an argument
"RTN","ut1",94,0)
 S TAG=$P(LINE," "),LINE=$P(LINE," ",2,400),NOTE=$P($$UP(LINE),"@TEST"),LINE=$E(LINE,$L(NOTE)+5+1,$L(LINE))
"RTN","ut1",95,0)
 F  Q:NOTE=""  S CHAR=$E(NOTE),NOTE=$E(NOTE,2,$L(NOTE)) I " ;"'[CHAR Q  ;
"RTN","ut1",96,0)
 I $L(NOTE)'=0 Q "" ; @TEST must be first text on line
"RTN","ut1",97,0)
 F  Q:$E(LINE)'=" "  S LINE=$E(LINE,2,$L(LINE)) ; remove leading spaces from test info
"RTN","ut1",98,0)
 S TAG=TAG_U_LINE
"RTN","ut1",99,0)
 Q TAG
"RTN","ut1",100,0)
 ;
"RTN","ut1",101,0)
 ; VEN/SMH 17DEC2013 - Remove dependence on VISTA - Uppercase here instead of XLFSTR.
"RTN","ut1",102,0)
UP(X) ;
"RTN","ut1",103,0)
 Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
"RTN","ut1",104,0)
 ;
"RTN","ut1",105,0)
COV(NMSP,COVCODE,VERBOSITY) ; VEN/SMH - PUBLIC ENTRY POINT; Coverage calculations
"RTN","ut1",106,0)
 ; NMSP: Namespace of the routines to analyze. End with * to include all routines.
"RTN","ut1",107,0)
 ;       Not using * will only include the routine with NMSP name.
"RTN","ut1",108,0)
 ;       e.g. PSOM* will include all routines starting with PSOM
"RTN","ut1",109,0)
 ;            PSOM will only include PSOM.
"RTN","ut1",110,0)
 ; COVCODE: Mumps code to run over which coverage will be calculated. Typically Unit Tests.
"RTN","ut1",111,0)
 ; VERBOSITY (optional): Scalar from -1 to 3.
"RTN","ut1",112,0)
 ;    - -1 = Global output in ^TMP("%utCOVREPORT",$J)
"RTN","ut1",113,0)
 ;    - 0 = Print only total coverage
"RTN","ut1",114,0)
 ;    - 1 = Break down by routine
"RTN","ut1",115,0)
 ;    - 2 = Break down by routine and tag
"RTN","ut1",116,0)
 ;    - 3 = Break down by routine and tag, and print lines that didn't execute for each tag.
"RTN","ut1",117,0)
 ;
"RTN","ut1",118,0)
 Q:'(+$SY=47)  ; GT.M only!
"RTN","ut1",119,0)
 ;
"RTN","ut1",120,0)
 ; ZEXCEPT: CTRAP - not really a variable
"RTN","ut1",121,0)
 S VERBOSITY=+$G(VERBOSITY) ; Get 0 if not passed.
"RTN","ut1",122,0)
 N %ZR ; GT.M specific
"RTN","ut1",123,0)
 D SILENT^%RSEL(NMSP,"SRC") ; GT.M specific. On Cache use $O(^$R(RTN)).
"RTN","ut1",124,0)
 ;
"RTN","ut1",125,0)
 N RN S RN=""
"RTN","ut1",126,0)
 W "Loading routines to test coverage...",!
"RTN","ut1",127,0)
 F  S RN=$O(%ZR(RN)) Q:RN=""  W RN," " D
"RTN","ut1",128,0)
 . N L2 S L2=$T(+2^@RN)
"RTN","ut1",129,0)
 . S L2=$TR(L2,$C(9,32)) ; Translate spaces and tabs out
"RTN","ut1",130,0)
 . I $E(L2,1,2)'=";;" K %ZR(RN)  ; Not a human produced routine
"RTN","ut1",131,0)
 ;
"RTN","ut1",132,0)
 N RTNS M RTNS=%ZR
"RTN","ut1",133,0)
 K %ZR
"RTN","ut1",134,0)
 ;
"RTN","ut1",135,0)
 N GL
"RTN","ut1",136,0)
 S GL=$NA(^TMP("%utCOVCOHORT",$J))
"RTN","ut1",137,0)
 K @GL
"RTN","ut1",138,0)
 D RTNANAL(.RTNS,GL)
"RTN","ut1",139,0)
 K ^TMP("%utCOVCOHORTSAV",$J)
"RTN","ut1",140,0)
 M ^TMP("%utCOVCOHORTSAV",$J)=^TMP("%utCOVCOHORT",$J)
"RTN","ut1",141,0)
 ;
"RTN","ut1",142,0)
 ;
"RTN","ut1",143,0)
 K ^TMP("%utCOVRESULT",$J)
"RTN","ut1",144,0)
 VIEW "TRACE":1:$NA(^TMP("%utCOVRESULT",$J))  ; GT.M START PROFILING
"RTN","ut1",145,0)
 DO  ; Run the code, but keep our variables to ourselves.
"RTN","ut1",146,0)
 . NEW $ETRAP,$ESTACK
"RTN","ut1",147,0)
 . SET $ETRAP="Q:($ES&$Q) -9 Q:$ES  W ""CTRL-C ENTERED"""
"RTN","ut1",148,0)
 . USE $PRINCIPAL:(CTRAP=$C(3))
"RTN","ut1",149,0)
 . NEW (DUZ,IO,COVCODE,U,DILOCKTM,DISYS,DT,DTIME,IOBS,IOF,IOM,ION,IOS,IOSL,IOST,IOT,IOXY)
"RTN","ut1",150,0)
 . XECUTE COVCODE
"RTN","ut1",151,0)
 VIEW "TRACE":0:$NA(^TMP("%utCOVRESULT",$J))  ; GT.M STOP PROFILING
"RTN","ut1",152,0)
 ;
"RTN","ut1",153,0)
 D COVCOV($NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J))) ; Venn diagram matching between globals
"RTN","ut1",154,0)
 ;
"RTN","ut1",155,0)
 ; Report
"RTN","ut1",156,0)
 I VERBOSITY=-1 D
"RTN","ut1",157,0)
 . K ^TMP("%utCOVREPORT",$J)
"RTN","ut1",158,0)
 . D COVRPTGL($NA(^TMP("%utCOVCOHORTSAV",$J)),$NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J)),$NA(^TMP("%utCOVREPORT",$J)))
"RTN","ut1",159,0)
 E  D COVRPT($NA(^TMP("%utCOVCOHORTSAV",$J)),$NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J)),VERBOSITY)
"RTN","ut1",160,0)
 ;
"RTN","ut1",161,0)
 QUIT
"RTN","ut1",162,0)
 ;
"RTN","ut1",163,0)
RTNANAL(RTNS,GL) ; [Private] - Routine Analysis
"RTN","ut1",164,0)
 ; Create a global similar to the trace global produced by GT.M in GL
"RTN","ut1",165,0)
 ; Only non-comment lines are stored.
"RTN","ut1",166,0)
 ; A tag is always stored. Tag,0 is stored only if there is code on the tag line (format list or actual code).
"RTN","ut1",167,0)
 ; tags by themselves don't count toward the total.
"RTN","ut1",168,0)
 ;
"RTN","ut1",169,0)
 N RTN S RTN=""
"RTN","ut1",170,0)
 F  S RTN=$O(RTNS(RTN)) Q:RTN=""  D                       ; for each routine
"RTN","ut1",171,0)
 . N TAG
"RTN","ut1",172,0)
 . S TAG=RTN                                              ; start the tags at the first
"RTN","ut1",173,0)
 . N I,LN F I=2:1 S LN=$T(@TAG+I^@RTN) Q:LN=""  D         ; for each line, starting with the 3rd line (2 off the first tag)
"RTN","ut1",174,0)
 . . I $E(LN)?1A D  QUIT                                  ; formal line
"RTN","ut1",175,0)
 . . . N T                                                ; Terminator
"RTN","ut1",176,0)
 . . . N J F J=1:1:$L(LN) S T=$E(LN,J) Q:T'?1AN           ; Loop to...
"RTN","ut1",177,0)
 . . . S TAG=$E(LN,1,J-1)                                 ; Get tag
"RTN","ut1",178,0)
 . . . S @GL@(RTN,TAG)=TAG                                ; store line
"RTN","ut1",179,0)
 . . . I T="(" S @GL@(RTN,TAG,0)=LN                       ; formal list
"RTN","ut1",180,0)
 . . . E  D                                               ; No formal list
"RTN","ut1",181,0)
 . . . . N LNTR S LNTR=$P(LN,TAG,2,999),LNTR=$TR(LNTR,$C(9,32)) ; Get rest of line, Remove spaces and tabs
"RTN","ut1",182,0)
 . . . . I $E(LNTR)=";" QUIT                              ; Comment
"RTN","ut1",183,0)
 . . . . S @GL@(RTN,TAG,0)=LN                             ; Otherwise, store for testing
"RTN","ut1",184,0)
 . . . S I=0                                              ; Start offsets from zero (first one at the for will be 1)
"RTN","ut1",185,0)
 . . I $C(32,9)[$E(LN) D  QUIT                            ; Regular line
"RTN","ut1",186,0)
 . . . N LNTR S LNTR=$TR(LN,$C(32,9))                     ; Remove all spaces and tabs
"RTN","ut1",187,0)
 . . . I $E(LNTR)=";" QUIT                                ; Comment line -- don't want.
"RTN","ut1",188,0)
 . . . S @GL@(RTN,TAG,I)=LN                               ; Record line
"RTN","ut1",189,0)
 QUIT
"RTN","ut1",190,0)
 ;
"RTN","ut1",191,0)
ACTLINES(GL) ; [Private] $$ ; Count active lines
"RTN","ut1",192,0)
 ;
"RTN","ut1",193,0)
 N CNT S CNT=0
"RTN","ut1",194,0)
 N REF S REF=GL
"RTN","ut1",195,0)
 N GLQL S GLQL=$QL(GL)
"RTN","ut1",196,0)
 F  S REF=$Q(@REF) Q:REF=""  Q:(GL'=$NA(@REF,GLQL))  D
"RTN","ut1",197,0)
 . N REFQL S REFQL=$QL(REF)
"RTN","ut1",198,0)
 . N LASTSUB S LASTSUB=$QS(REF,REFQL)
"RTN","ut1",199,0)
 . I LASTSUB?1.N S CNT=CNT+1
"RTN","ut1",200,0)
 QUIT CNT
"RTN","ut1",201,0)
 ;
"RTN","ut1",202,0)
COVCOV(C,R) ; [Private] - Analyze coverage Cohort vs Result
"RTN","ut1",203,0)
 N RTN S RTN=""
"RTN","ut1",204,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D  ; For each routine in cohort set
"RTN","ut1",205,0)
 . I '$D(@R@(RTN)) QUIT             ; Not present in result set
"RTN","ut1",206,0)
 . N TAG S TAG=""
"RTN","ut1",207,0)
 . F  S TAG=$O(@R@(RTN,TAG)) Q:TAG=""  D  ; For each tag in the routine in the result set
"RTN","ut1",208,0)
 . . N LN S LN=""
"RTN","ut1",209,0)
 . . F  S LN=$O(@R@(RTN,TAG,LN)) Q:LN=""  D  ; for each line in the tag in the routine in the result set
"RTN","ut1",210,0)
 . . . I $D(@C@(RTN,TAG,LN)) K ^(LN)  ; if present in cohort, kill off
"RTN","ut1",211,0)
 QUIT
"RTN","ut1",212,0)
 ;
"RTN","ut1",213,0)
COVRPT(C,S,R,V) ; [Private] - Coverage Report
"RTN","ut1",214,0)
 ; C = COHORT    - Global name
"RTN","ut1",215,0)
 ; S = SURVIVORS - Global name
"RTN","ut1",216,0)
 ; R = RESULT    - Global name
"RTN","ut1",217,0)
 ; V = Verbosity - Scalar from -1 to 3
"RTN","ut1",218,0)
 N ORIGLINES S ORIGLINES=$$ACTLINES(C)
"RTN","ut1",219,0)
 N LEFTLINES S LEFTLINES=$$ACTLINES(S)
"RTN","ut1",220,0)
 W !!
"RTN","ut1",221,0)
 W "ORIG: "_ORIGLINES,!
"RTN","ut1",222,0)
 W "LEFT: "_LEFTLINES,!
"RTN","ut1",223,0)
 W "COVERAGE PERCENTAGE: "_$S(ORIGLINES:$J(ORIGLINES-LEFTLINES/ORIGLINES*100,"",2),1:100.00),!
"RTN","ut1",224,0)
 W !!
"RTN","ut1",225,0)
 W "BY ROUTINE:",!
"RTN","ut1",226,0)
 I V=0 QUIT  ; No verbosity. Don't print routine detail
"RTN","ut1",227,0)
 N RTN S RTN=""
"RTN","ut1",228,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D
"RTN","ut1",229,0)
 . N O S O=$$ACTLINES($NA(@C@(RTN)))
"RTN","ut1",230,0)
 . N L S L=$$ACTLINES($NA(@S@(RTN)))
"RTN","ut1",231,0)
 . W ?3,RTN,?21,$S(O:$J(O-L/O*100,"",2),1:"100.00"),!
"RTN","ut1",232,0)
 . I V=1 QUIT  ; Just print the routine coverage for V=1
"RTN","ut1",233,0)
 . N TAG S TAG=""
"RTN","ut1",234,0)
 . F  S TAG=$O(@C@(RTN,TAG)) Q:TAG=""  D
"RTN","ut1",235,0)
 . . N O S O=$$ACTLINES($NA(@C@(RTN,TAG)))
"RTN","ut1",236,0)
 . . N L S L=$$ACTLINES($NA(@S@(RTN,TAG)))
"RTN","ut1",237,0)
 . . W ?5,TAG,?21,$S(O:$J(O-L/O*100,"",2),1:"100.00"),!
"RTN","ut1",238,0)
 . . I V=2 QUIT  ; Just print routine/tags coverage for V=2; V=3 print uncovered lines
"RTN","ut1",239,0)
 . . N LN S LN=""
"RTN","ut1",240,0)
 . . F  S LN=$O(@S@(RTN,TAG,LN)) Q:LN=""  W TAG_"+"_LN_": "_^(LN),!
"RTN","ut1",241,0)
 QUIT
"RTN","ut1",242,0)
 ;
"RTN","ut1",243,0)
COVRPTGL(C,S,R,OUT) ; [Private] - Coverage Global for silent invokers
"RTN","ut1",244,0)
 ; C = COHORT    - Global name
"RTN","ut1",245,0)
 ; S = SURVIVORS - Global name
"RTN","ut1",246,0)
 ; R = RESULT    - Global name
"RTN","ut1",247,0)
 ; OUT = OUTPUT  - Global name
"RTN","ut1",248,0)
 ;
"RTN","ut1",249,0)
 N O S O=$$ACTLINES(C)
"RTN","ut1",250,0)
 N L S L=$$ACTLINES(S)
"RTN","ut1",251,0)
 S @OUT=(O-L)_"/"_O
"RTN","ut1",252,0)
 N RTN,TAG,LN S (RTN,TAG,LN)=""
"RTN","ut1",253,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D
"RTN","ut1",254,0)
 . N O S O=$$ACTLINES($NA(@C@(RTN)))
"RTN","ut1",255,0)
 . N L S L=$$ACTLINES($NA(@S@(RTN)))
"RTN","ut1",256,0)
 . S @OUT@(RTN)=(O-L)_"/"_O
"RTN","ut1",257,0)
 . F  S TAG=$O(@C@(RTN,TAG)) Q:TAG=""  D
"RTN","ut1",258,0)
 . . N O S O=$$ACTLINES($NA(@C@(RTN,TAG)))
"RTN","ut1",259,0)
 . . N L S L=$$ACTLINES($NA(@S@(RTN,TAG)))
"RTN","ut1",260,0)
 . . S @OUT@(RTN,TAG)=(O-L)_"/"_O
"RTN","ut1",261,0)
 . . F  S LN=$O(@S@(RTN,TAG,LN)) Q:LN=""  S @OUT@(RTN,TAG,LN)=@S@(RTN,TAG,LN)
"RTN","ut1",262,0)
 QUIT
"RTN","ut1",263,0)
 ;
"RTN","ut1",264,0)
TESTCOVR ; entry under coverage analysis
"RTN","ut1",265,0)
 D ENTRY^%uttcovr ; does analysis while running various unit tests
"RTN","ut1",266,0)
 Q
"RTN","ut1",267,0)
 ;
"RTN","utt1")
0^3^B25860592
"RTN","utt1",1,0)
%utt1 ; VEN/SMH - Testing routines for M-Unit;08/29/14  11:35
"RTN","utt1",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","utt1",3,0)
%utNITT ; VEN/SMH - Testing routines for M-Unit;2014-04-01  2:04 PM
"RTN","utt1",4,0)
 ;
"RTN","utt1",5,0)
 ; THIS ROUTINE IS THE UNIFIED UNIT TESTER FOR ALL OF M-UNIT.
"RTN","utt1",6,0)
 ;
"RTN","utt1",7,0)
 ; Dear Users,
"RTN","utt1",8,0)
 ;
"RTN","utt1",9,0)
 ; I know about about the irony of a test suite for the testing suite,
"RTN","utt1",10,0)
 ; so stop snikering. Aside from that, it's actually going to be hard.
"RTN","utt1",11,0)
 ;
"RTN","utt1",12,0)
 ; Truly yours,
"RTN","utt1",13,0)
 ;
"RTN","utt1",14,0)
 ; Sam H
"RTN","utt1",15,0)
 ;
"RTN","utt1",16,0)
 D EN^%ut($T(+0),1) ; Run tests here, be verbose.
"RTN","utt1",17,0)
 QUIT
"RTN","utt1",18,0)
 ;
"RTN","utt1",19,0)
STARTUP ; M-Unit Start-Up - This runs before anything else.
"RTN","utt1",20,0)
 S ^TMP($J,"%ut","STARTUP")=""
"RTN","utt1",21,0)
 S KBANCOUNT=1
"RTN","utt1",22,0)
 QUIT
"RTN","utt1",23,0)
 ;
"RTN","utt1",24,0)
SHUTDOWN ; M-Unit Shutdown - This runs after everything else is done.
"RTN","utt1",25,0)
 K ^TMP($J,"%ut","STARTUP")
"RTN","utt1",26,0)
 K KBANCOUNT
"RTN","utt1",27,0)
 QUIT
"RTN","utt1",28,0)
 ;
"RTN","utt1",29,0)
 ;
"RTN","utt1",30,0)
 ;
"RTN","utt1",31,0)
SETUP ; This runs before every test.
"RTN","utt1",32,0)
 S KBANCOUNT=KBANCOUNT+1
"RTN","utt1",33,0)
 QUIT
"RTN","utt1",34,0)
 ;
"RTN","utt1",35,0)
TEARDOWN ; This runs after every test
"RTN","utt1",36,0)
 S KBANCOUNT=KBANCOUNT-1
"RTN","utt1",37,0)
 QUIT
"RTN","utt1",38,0)
 ;
"RTN","utt1",39,0)
 ;
"RTN","utt1",40,0)
 ;
"RTN","utt1",41,0)
T1 ; @TEST - Make sure Start-up Ran
"RTN","utt1",42,0)
 D CHKTF($D(^TMP($J,"%ut","STARTUP")),"Start-up node on ^TMP must exist")
"RTN","utt1",43,0)
 QUIT
"RTN","utt1",44,0)
 ;
"RTN","utt1",45,0)
T2 ; @TEST - Make sure Set-up runs
"RTN","utt1",46,0)
 D CHKEQ(KBANCOUNT,2,"KBANCount not incremented properly at SETUP")
"RTN","utt1",47,0)
 QUIT
"RTN","utt1",48,0)
 ;
"RTN","utt1",49,0)
T3 ; @TEST - Make sure Teardown runs
"RTN","utt1",50,0)
 D CHKEQ(KBANCOUNT,2,"KBANCount not decremented properly at TEARDOWN")
"RTN","utt1",51,0)
 QUIT
"RTN","utt1",52,0)
 ;
"RTN","utt1",53,0)
T4 ; Specified in XTMTAG
"RTN","utt1",54,0)
 ; 140731 JLI - note that this will fail when run from the GUI runner, since it calls each tag separately
"RTN","utt1",55,0)
 I $G(%utGUI) D CHKEQ(%utETRY,"T4","T4 should be the value for %utETRY in the GUI Runner")
"RTN","utt1",56,0)
 I '$G(%utGUI) D CHKEQ(%utETRY(4),"T4","T4 should be the collected as the fourth entry in %utETRY")
"RTN","utt1",57,0)
 QUIT
"RTN","utt1",58,0)
 ;
"RTN","utt1",59,0)
T5 ; ditto
"RTN","utt1",60,0)
 D CHKTF(0,"This is an intentional failure.")
"RTN","utt1",61,0)
 D CHKEQ(%ut("FAIL"),1,"By this point, we should have failed one test")
"RTN","utt1",62,0)
 D FAIL^%ut("Intentionally throwing a failure")
"RTN","utt1",63,0)
 D CHKEQ(%ut("FAIL"),2,"By this point, we should have failed two tests")
"RTN","utt1",64,0)
 ; S %ut("FAIL")=0 ; Okay... Boy's and Girls... as the developer I can do that.
"RTN","utt1",65,0)
 QUIT
"RTN","utt1",66,0)
 ;
"RTN","utt1",67,0)
T6 ; ditto
"RTN","utt1",68,0)
 N TESTCOUNT S TESTCOUNT=%ut("CHK")
"RTN","utt1",69,0)
 D SUCCEED^%ut
"RTN","utt1",70,0)
 D SUCCEED^%ut
"RTN","utt1",71,0)
 D CHKEQ(%ut("CHK"),TESTCOUNT+2,"Succeed should increment the number of tests")
"RTN","utt1",72,0)
 QUIT
"RTN","utt1",73,0)
 ;
"RTN","utt1",74,0)
T7 ; Make sure we write to principal even though we are on another device
"RTN","utt1",75,0)
 ; This is a rather difficult test to carry out for GT.M and Cache...
"RTN","utt1",76,0)
 N D
"RTN","utt1",77,0)
 I +$SY=47 S D="/tmp/test.txt" ; All GT.M ; VMS not supported.
"RTN","utt1",78,0)
 I +$SY=0 D  ; All Cache
"RTN","utt1",79,0)
 . I $ZVERSION(1)=2 S D=$SYSTEM.Util.GetEnviron("temp")_"\test.txt" I 1 ; Windows
"RTN","utt1",80,0)
 . E  S D="/tmp/test.txt" ; not windows; VMS not supported.
"RTN","utt1",81,0)
 I +$SY=0 O D:"NWS" ; Cache new file
"RTN","utt1",82,0)
 I +$SY=47 O D:(newversion) ; GT.M new file
"RTN","utt1",83,0)
 U D
"RTN","utt1",84,0)
 WRITE "HELLO",!
"RTN","utt1",85,0)
 WRITE "HELLO",!
"RTN","utt1",86,0)
 C D
"RTN","utt1",87,0)
 ;
"RTN","utt1",88,0)
 ; Now open back the file, and read the hello, but open in read only so
"RTN","utt1",89,0)
 ; M-Unit will error out if it will write something out there.
"RTN","utt1",90,0)
 ;
"RTN","utt1",91,0)
 ; Per VISTA conventions, current IO device should be IO, old is IO(0).
"RTN","utt1",92,0)
 ;
"RTN","utt1",93,0)
 I +$SY=0 O D:"R"
"RTN","utt1",94,0)
 I +$SY=47 O D:(readonly)
"RTN","utt1",95,0)
 U D
"RTN","utt1",96,0)
 N X READ X:1
"RTN","utt1",97,0)
 D CHKTF(X="HELLO")  ; This should write to the screen the dot not to the file.
"RTN","utt1",98,0)
 D CHKTF(($$LO($IO)=$$LO(D)),"IO device didn't get reset back")       ; $$LO is b/c of a bug in Cache/Windows. $IO is not the same cas D.
"RTN","utt1",99,0)
 I +$SY=0 C D:"D"
"RTN","utt1",100,0)
 I +$SY=47 C D:(delete)
"RTN","utt1",101,0)
 U $P
"RTN","utt1",102,0)
 S IO=$IO
"RTN","utt1",103,0)
 QUIT
"RTN","utt1",104,0)
 ;
"RTN","utt1",105,0)
 ; At the moment T8^%utt1 throws a fail, with no message
"RTN","utt1",106,0)
 ; in the GUI runner.  For some reason, both X and Y
"RTN","utt1",107,0)
 ; variables are returned as null strings, while in the
"RTN","utt1",108,0)
 ; command line runner, Y has a value containing the
"RTN","utt1",109,0)
 ; word being sought
"RTN","utt1",110,0)
 ;
"RTN","utt1",111,0)
T8 ; If IO starts with another device, write to that device as if it's the pricipal device
"RTN","utt1",112,0)
 N D
"RTN","utt1",113,0)
 I +$SY=47 S D="/tmp/test.txt" ; All GT.M ; VMS not supported.
"RTN","utt1",114,0)
 I +$SY=0 D  ; All Cache
"RTN","utt1",115,0)
 . I $ZVERSION(1)=2 S D=$SYSTEM.Util.GetEnviron("temp")_"\test.txt" I 1 ; Windows
"RTN","utt1",116,0)
 . E  S D="/tmp/test.txt" ; not windows; VMS not supported.
"RTN","utt1",117,0)
 I +$SY=0 O D:"NWS" ; Cache new file
"RTN","utt1",118,0)
 I +$SY=47 O D:(newversion) ; GT.M new file
"RTN","utt1",119,0)
 S IO=D
"RTN","utt1",120,0)
 U D
"RTN","utt1",121,0)
 D ^%utt4 ; Run some Unit Tests
"RTN","utt1",122,0)
 C D
"RTN","utt1",123,0)
 I +$SY=0 O D:"R" ; Cache read only
"RTN","utt1",124,0)
 I +$SY=47 O D:(readonly) ; GT.M read only
"RTN","utt1",125,0)
 U D
"RTN","utt1",126,0)
 N X,Y,Z R X:1,Y:1,Z:1
"RTN","utt1",127,0)
 I +$SY=0 C D:"D"
"RTN","utt1",128,0)
 I +$SY=47 C D:(delete)
"RTN","utt1",129,0)
 ;D CHKTF(Y["MAIN") ; JLI 140829 commented out, gui doesn't run verbose
"RTN","utt1",130,0)
 D CHKTF((Y["MAIN")!(Z["Ran 1 Routine"),"Write to system during test didn't work")
"RTN","utt1",131,0)
 S IO=$P
"RTN","utt1",132,0)
 QUIT
"RTN","utt1",133,0)
 ;
"RTN","utt1",134,0)
LO(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
"RTN","utt1",135,0)
 ; Shortcut methods for M-Unit
"RTN","utt1",136,0)
CHKTF(X,Y)   D CHKTF^%ut(X,$G(Y))   QUIT
"RTN","utt1",137,0)
CHKEQ(A,B,M) D CHKEQ^%ut(A,B,$G(M)) QUIT
"RTN","utt1",138,0)
 ;
"RTN","utt1",139,0)
XTENT ; Entry points
"RTN","utt1",140,0)
 ;;T4;Entry point using XTMENT
"RTN","utt1",141,0)
 ;;T5;Error count check
"RTN","utt1",142,0)
 ;;T6;Succeed Entry Point
"RTN","utt1",143,0)
 ;;T7;Make sure we write to principal even though we are on another device
"RTN","utt1",144,0)
 ;;T8;If IO starts with another device, write to that device as if it's the pricipal device
"RTN","utt1",145,0)
 ;
"RTN","utt1",146,0)
XTROU ; Routines containing additional tests
"RTN","utt1",147,0)
 ;;%utt2; old %utNITU
"RTN","utt1",148,0)
 ;;%utt4; old %utNITW
"RTN","utt1",149,0)
 ;;%utt5;
"RTN","utt1",150,0)
 ;;%utt6;
"RTN","utt2")
0^4^B473823
"RTN","utt2",1,0)
%utt2 ; VEN/SMH - Bad Ass Continuation of Unit Tests;08/04/14  09:12
"RTN","utt2",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","utt2",3,0)
XTMUNITU ; VEN/SMH - Bad Ass Continuation of Unit Tests;2014-04-01  1:03 PM
"RTN","utt2",4,0)
 ;
"RTN","utt2",5,0)
T11 ; @TEST An @TEST Entry point in Another Routine invoked through XTROU offsets
"RTN","utt2",6,0)
 D CHKTF^%ut(1)
"RTN","utt2",7,0)
 QUIT
"RTN","utt2",8,0)
T12 ;
"RTN","utt2",9,0)
 D CHKTF^%ut(1)
"RTN","utt2",10,0)
 QUIT
"RTN","utt2",11,0)
XTENT ;
"RTN","utt2",12,0)
 ;;T12;An XTENT offset entry point in Another Routine invoked through XTROU offsets
"RTN","utt3")
0^5^B1493136
"RTN","utt3",1,0)
%utt3 ; VEN/SMH - Unit Tests Coverage Tests;08/14/14  14:02
"RTN","utt3",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","utt3",3,0)
XTMUNITV ; VEN/SMH - Unit Tests Coverage Tests;2014-04-16  7:14 PM
"RTN","utt3",4,0)
 ;
"RTN","utt3",5,0)
 ; *** BE VERY CAREFUL IN MODIFIYING THIS ROUTINE ***
"RTN","utt3",6,0)
 ; *** THE UNIT TEST COUNTS ACTIVE AND INACTIVE LINES OF CODE ***
"RTN","utt3",7,0)
 ; *** IF YOU MODIFY THIS, MODIFY XTMUNITW AS WELL ***
"RTN","utt3",8,0)
 ;
"RTN","utt3",9,0)
 ; Coverage tester in %utt4
"RTN","utt3",10,0)
 ; 20 Lines of code
"RTN","utt3",11,0)
 ; 5 do not run as they are dead code
"RTN","utt3",12,0)
 ; Expected Coverage: 15/20 = 75%
"RTN","utt3",13,0)
 ;
"RTN","utt3",14,0)
STARTUP ; Doesn't count
"RTN","utt3",15,0)
 N X    ; Counts
"RTN","utt3",16,0)
 S X=1  ; Counts
"RTN","utt3",17,0)
 QUIT   ; Counts
"RTN","utt3",18,0)
 ;
"RTN","utt3",19,0)
SHUTDOWN K X,Y QUIT     ; Counts; ZEXCEPT: X,Y
"RTN","utt3",20,0)
 ;
"RTN","utt3",21,0)
SETUP S Y=$G(Y)+1 QUIT  ; Counts
"RTN","utt3",22,0)
 ;
"RTN","utt3",23,0)
TEARDOWN ; Doesn't count
"RTN","utt3",24,0)
 S Y=Y-1 ; Counts
"RTN","utt3",25,0)
 QUIT    ; Counts
"RTN","utt3",26,0)
 ;
"RTN","utt3",27,0)
T1 ; @TEST Test 1
"RTN","utt3",28,0)
 D CHKTF^%ut($D(Y)) ; Counts
"RTN","utt3",29,0)
 QUIT                   ; Counts
"RTN","utt3",30,0)
 ;
"RTN","utt3",31,0)
T2 ; @TEST Test 2
"RTN","utt3",32,0)
 D INTERNAL(1)          ; Counts
"RTN","utt3",33,0)
 D CHKTF^%ut(1)     ; Counts
"RTN","utt3",34,0)
 QUIT                   ; Counts
"RTN","utt3",35,0)
 S X=1                  ; Dead code
"RTN","utt3",36,0)
 QUIT                   ; Dead code
"RTN","utt3",37,0)
 ;
"RTN","utt3",38,0)
INTERNAL(A) ; Counts
"RTN","utt3",39,0)
 S A=A+1    ; Counts
"RTN","utt3",40,0)
 QUIT       ; Counts
"RTN","utt3",41,0)
 S A=2      ; Dead code
"RTN","utt3",42,0)
 S Y=2      ; Dead code
"RTN","utt3",43,0)
 QUIT       ; Dead code
"RTN","utt4")
0^6^B1419637
"RTN","utt4",1,0)
%utt4 ; VEN/SMH - Coverage Test Runner;08/23/14  08:33
"RTN","utt4",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","utt4",3,0)
XTMUNITW ; VEN/SMH - Coverage Test Runner;2014-04-17  3:30 PM
"RTN","utt4",4,0)
 ;;7.3;KERNEL TOOLKIT;;
"RTN","utt4",5,0)
 ;
"RTN","utt4",6,0)
 ; This tests code in XTMUNITV for coverage
"RTN","utt4",7,0)
 D EN^%ut($T(+0),1) QUIT
"RTN","utt4",8,0)
 ;
"RTN","utt4",9,0)
MAIN ; @TEST - Test coverage calculations
"RTN","utt4",10,0)
 Q:$D(^TMP("%uttcovr",$J))  ; already running coverage analysis from %uttcovr
"RTN","utt4",11,0)
 Q:'(+$SY=47)  ; GT.M ONLY
"RTN","utt4",12,0)
 ;D COV^%ut1("XTMUNITV","D EN^%ut(""XTMUNITV"",1)",-1)  ; Only produce output global.
"RTN","utt4",13,0)
 D COV^%ut1("%utt3","D EN^%ut(""%utt3"",1)",-1)  ; Only produce output global.
"RTN","utt4",14,0)
 D CHKEQ^%ut(^TMP("%utCOVREPORT",$J),"15/20")
"RTN","utt4",15,0)
 ;D CHKEQ^%ut(^TMP("XTMCOVREPORT",$J,"XTMUNITV","INTERNAL"),"3/6")
"RTN","utt4",16,0)
 D CHKEQ^%ut(^TMP("%utCOVREPORT",$J,"%utt3","INTERNAL"),"3/6")
"RTN","utt4",17,0)
 ;D CHKTF^%ut($D(^TMP("XTMCOVREPORT",$J,"XTMUNITV","T2",4)))
"RTN","utt4",18,0)
 D CHKTF^%ut($D(^TMP("%utCOVREPORT",$J,"%utt3","T2",4)))
"RTN","utt4",19,0)
 ;D CHKEQ^%ut(^TMP("XTMCOVREPORT",$J,"XTMUNITV","SETUP"),"1/1")
"RTN","utt4",20,0)
 D CHKEQ^%ut(^TMP("%utCOVREPORT",$J,"%utt3","SETUP"),"1/1")
"RTN","utt4",21,0)
 QUIT
"RTN","utt5")
0^7^B22421637
"RTN","utt5",1,0)
%utt5 ;JLI - test for aspects of MUnit functionality ;08/29/14  11:23
"RTN","utt5",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","utt5",3,0)
 Q
"RTN","utt5",4,0)
 ;
"RTN","utt5",5,0)
OLDSTYLE ;
"RTN","utt5",6,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",7,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",8,0)
 I $D(%utt6var) S %ut("ENT")="OLDSTYLE",%utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"OLDSTYLE")=""
"RTN","utt5",9,0)
 D CHKEQ^%ut(5,5,"SET EQUAL ON PURPOSE - OLDSTYLE DONE")
"RTN","utt5",10,0)
 D CHKTF^%ut(4=4,"MY EQUAL VALUE")
"RTN","utt5",11,0)
 Q
"RTN","utt5",12,0)
 ;
"RTN","utt5",13,0)
OLDSTYL1 ;
"RTN","utt5",14,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",15,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",16,0)
 I $D(%utt6var) S %ut("ENT")="OLDSTYL1",%utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"OLDSTYL1")=""
"RTN","utt5",17,0)
 D CHKEQ^%ut(4,4,"SET EQUAL ON PURPOSE - OLDSTYL1 DONE")
"RTN","utt5",18,0)
 Q
"RTN","utt5",19,0)
 ;
"RTN","utt5",20,0)
NEWSTYLE ; @TEST identify new style test indicator functionality
"RTN","utt5",21,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",22,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",23,0)
 I $D(%utt6var) S %ut("ENT")="NEWSTYLE" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"NEWSTYLE")=""
"RTN","utt5",24,0)
 D CHKEQ^%ut(4,4,"SET EQUAL ON PURPOSE - NEWSTYLE DONE")
"RTN","utt5",25,0)
 Q
"RTN","utt5",26,0)
 ;
"RTN","utt5",27,0)
BADCHKEQ ;
"RTN","utt5",28,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",29,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",30,0)
 I $D(%utt6var) S %ut("ENT")="BADCHKEQ" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADCHKEQ")=""
"RTN","utt5",31,0)
 D CHKEQ^%ut(4,3,"SET UNEQUAL ON PURPOSE - SHOULD FAIL")
"RTN","utt5",32,0)
 Q
"RTN","utt5",33,0)
 ;
"RTN","utt5",34,0)
BADCHKTF ;
"RTN","utt5",35,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",36,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",37,0)
 I $D(%utt6var) S %ut("ENT")="BADCHKTF" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADCHKTF")=""
"RTN","utt5",38,0)
 D CHKTF^%ut(0,"SET FALSE (0) ON PURPOSE - SHOULD FAIL")
"RTN","utt5",39,0)
 Q
"RTN","utt5",40,0)
 ;
"RTN","utt5",41,0)
BADERROR ;
"RTN","utt5",42,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",43,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",44,0)
 N X
"RTN","utt5",45,0)
 I $D(%utt6var) S %ut("ENT")="BADERROR" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADERROR")=""
"RTN","utt5",46,0)
 ; following syntax error is on purpose to throw an error
"RTN","utt5",47,0)
 S X= ; syntax error on purpose
"RTN","utt5",48,0)
 Q
"RTN","utt5",49,0)
 ;
"RTN","utt5",50,0)
CALLFAIL ;
"RTN","utt5",51,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",52,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",53,0)
 N X
"RTN","utt5",54,0)
 I $D(%utt6var) S %ut("ENT")="CALLFAIL" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"CALLFAIL")=""
"RTN","utt5",55,0)
 D FAIL^%ut("Called FAIL to test it")
"RTN","utt5",56,0)
 Q
"RTN","utt5",57,0)
 ;
"RTN","utt5",58,0)
LEAKSOK ;
"RTN","utt5",59,0)
 N CODE,LOCATN,MYVALS,X
"RTN","utt5",60,0)
 S CODE="S X=$$NOW^XLFDT()",LOCATN="LEAKSOK TEST",MYVALS("X")=""
"RTN","utt5",61,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find no leaks
"RTN","utt5",62,0)
 Q
"RTN","utt5",63,0)
 ;
"RTN","utt5",64,0)
LEAKSBAD ;
"RTN","utt5",65,0)
 N CODE,LOCATN,MYVALS,X
"RTN","utt5",66,0)
 S CODE="S X=$$NOW^XLFDT()",LOCATN="LEAKSBAD TEST - X NOT SPECIFIED"
"RTN","utt5",67,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find X since it isn't indicated
"RTN","utt5",68,0)
 Q
"RTN","utt5",69,0)
 ;
"RTN","utt5",70,0)
NVLDARG1 ;
"RTN","utt5",71,0)
 D CHKEQ^%ut(1)
"RTN","utt5",72,0)
 Q
"RTN","utt5",73,0)
 ;
"RTN","utt5",74,0)
ISUTEST ;
"RTN","utt5",75,0)
 D CHKTF^%ut($$ISUTEST^%ut,"ISUTEST returned FALSE!")
"RTN","utt5",76,0)
 Q
"RTN","utt5",77,0)
 ;
"RTN","utt5",78,0)
BADFORM1(X) ; @TEST should not be selected - arguments
"RTN","utt5",79,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",80,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",81,0)
 I $D(%utt6var) S %ut("ENT")="NEWSTYLE" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADFORM1")=""
"RTN","utt5",82,0)
 D CHKEQ^%ut(4,3,"SHOULD NOT BE SELECTED - ARGUMENTS - BADFORM1")
"RTN","utt5",83,0)
 Q
"RTN","utt5",84,0)
 ;
"RTN","utt5",85,0)
BADFORM2 ; ABC @TEST should not be selected - @TEST NOT FIRST
"RTN","utt5",86,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",87,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",88,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADFORM2")=""
"RTN","utt5",89,0)
 D CHKEQ^%ut(4,3,"SHOULD NOT BE SELECTED - @TEST NOT FIRST - BADFORM2")
"RTN","utt5",90,0)
 Q
"RTN","utt5",91,0)
 ;
"RTN","utt5",92,0)
STARTUP ;
"RTN","utt5",93,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",94,0)
 ; ZEXCEPT: KBANCOUNT created here, killed in SHUTDOWN
"RTN","utt5",95,0)
 I $D(%utt6var),$D(^TMP("%utt5",$J)) K ^TMP("%utt5",$J)
"RTN","utt5",96,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"STARTUP")=""
"RTN","utt5",97,0)
 ; following brought from %utt1, since only one STARTUP can RUN in a set
"RTN","utt5",98,0)
 I '$D(%utt6var) D
"RTN","utt5",99,0)
 . S ^TMP($J,"%ut","STARTUP")=""
"RTN","utt5",100,0)
 . S KBANCOUNT=1
"RTN","utt5",101,0)
 . Q
"RTN","utt5",102,0)
 Q
"RTN","utt5",103,0)
 ;
"RTN","utt5",104,0)
SHUTDOWN ;
"RTN","utt5",105,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",106,0)
 ; ZEXCEPT: KBANCOUNT created in STARTUP, killed here
"RTN","utt5",107,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"SHUTDOWN")=""
"RTN","utt5",108,0)
 ; following brought from %utt1, since only one SHUTDOWN can RUN in a set
"RTN","utt5",109,0)
 I '$D(%utt6var) D
"RTN","utt5",110,0)
 . K ^TMP($J,"%ut","STARTUP")
"RTN","utt5",111,0)
 . K KBANCOUNT
"RTN","utt5",112,0)
 . Q
"RTN","utt5",113,0)
 Q
"RTN","utt5",114,0)
 ;
"RTN","utt5",115,0)
SETUP ;
"RTN","utt5",116,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",117,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"SETUP")=""
"RTN","utt5",118,0)
 Q
"RTN","utt5",119,0)
 ;
"RTN","utt5",120,0)
TEARDOWN ;
"RTN","utt5",121,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",122,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"TEARDOWN")=""
"RTN","utt5",123,0)
 Q
"RTN","utt5",124,0)
 ;
"RTN","utt5",125,0)
XTENT ;
"RTN","utt5",126,0)
 ;;OLDSTYLE; identify old style test indicator functionality
"RTN","utt5",127,0)
 ;;OLDSTYL1; identify old style test indicator 2
"RTN","utt5",128,0)
 ;;BADCHKEQ; CHKEQ should fail on unequal value
"RTN","utt5",129,0)
 ;;BADCHKTF; CHKTF should fail on false value
"RTN","utt5",130,0)
 ;;BADERROR; throws an error on purpose
"RTN","utt5",131,0)
 ;;CALLFAIL; called FAIL to test it
"RTN","utt5",132,0)
 ;;LEAKSOK;check leaks should be ok
"RTN","utt5",133,0)
 ;;LEAKSBAD;check leaks with leak
"RTN","utt5",134,0)
 ;;NVLDARG1;check invalid arg in CHKEQ
"RTN","utt5",135,0)
 ;;ISUTEST;check ISUTEST inside unit test
"RTN","utt6")
0^8^B29243478
"RTN","utt6",1,0)
%utt6 ;JLI - Unit tests for MUnit functionality ;08/29/14  11:43
"RTN","utt6",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","utt6",3,0)
 ;
"RTN","utt6",4,0)
 ; This routine uses ZZUTJLI2 as a test routine, it does not include the routine as an extension,
"RTN","utt6",5,0)
 ; since it uses it for tests.
"RTN","utt6",6,0)
 ;
"RTN","utt6",7,0)
 ; ZZUTJLI2 currently contains 3 tests (2 old style, 1 new style), it also specifies STARTUP and
"RTN","utt6",8,0)
 ; SHUTDOWN (should be 1 each) and SETUP and TEARDOWN (should be 3 each, 1 for each test) enteries, each of these
"RTN","utt6",9,0)
 ; creates an entry under the ^TMP("ZZUTJLI2" global node, indicating function then continues the process.
"RTN","utt6",10,0)
 ; Should be 2+3n entries (1+1 for STARTUP and SHUTDOWN, then 3 for each of the tests (SETUP, test,
"RTN","utt6",11,0)
 ; and TEARDOWN).
"RTN","utt6",12,0)
 ;
"RTN","utt6",13,0)
 ; This first section is more of a functional test, since it checks the full unit test processing from both
"RTN","utt6",14,0)
 ; a command line and a GUI call approach.  Data for analysis is saved under ^TMP("ZZUTJLI2_C", for command
"RTN","utt6",15,0)
 ; line and ^TMP("ZZUTJLI2_G", for gui processing.
"RTN","utt6",16,0)
 ;
"RTN","utt6",17,0)
 ; The counts for the command line processing are based on the number of unit test tags
"RTN","utt6",18,0)
 ; determined for the GUI processing as well.  The numbers are 2 (startup and shutdown)
"RTN","utt6",19,0)
 ;  + 3 x the number of tests present.
"RTN","utt6",20,0)
 ;
"RTN","utt6",21,0)
 ; run unit tests by command line
"RTN","utt6",22,0)
 N VERBOSE
"RTN","utt6",23,0)
 S VERBOSE=0
"RTN","utt6",24,0)
VERBOSE ;
"RTN","utt6",25,0)
 I '$D(VERBOSE) N VERBOSE S VERBOSE=1
"RTN","utt6",26,0)
 N ZZUTCNT,JLICNT,JLIEXPCT,JLII,JLIX,ZZUTRSLT,%utt5,%utt6,%utt6var
"RTN","utt6",27,0)
 W !!,"RUNNING COMMAND LINE TESTS VIA DOSET^%ut",!
"RTN","utt6",28,0)
 D DOSET^%ut(1,VERBOSE) ; run `1 in M-UNIT TEST GROUP file
"RTN","utt6",29,0)
 ;
"RTN","utt6",30,0)
 W !!!,"Running command line tests by RUNSET^%ut",!
"RTN","utt6",31,0)
 D RUNSET^%ut("TESTS FOR UNIT TEST ROUTINES")
"RTN","utt6",32,0)
 ;
"RTN","utt6",33,0)
 ; Call GUISET to obtain list of tags via entry in M-UNIT TEST GROUP file
"RTN","utt6",34,0)
 ; silent to the user
"RTN","utt6",35,0)
 D GUISET^%ut(.%utt6,1)
"RTN","utt6",36,0)
 K ^TMP("%utt6_GUISET",$J) M ^TMP("%utt6_GUISET",$J)=@%utt6
"RTN","utt6",37,0)
 ;
"RTN","utt6",38,0)
 W !!!,"RUNNING COMMAND LINE UNIT TESTS FOR %utt5",!
"RTN","utt6",39,0)
 N ZZUTCNT,JLICNT,JLIEXPCT,JLII,JLIX,ZZUTRSLT
"RTN","utt6",40,0)
 S ZZUTCNT=0
"RTN","utt6",41,0)
 K ^TMP("%utt5",$J) ; kill any contents of data storage
"RTN","utt6",42,0)
 D EN^%ut("%utt5",VERBOSE) ; should do STARTUP(1x), then SETUP, test, TEARDOWN (each together 3x) and SHUTDOWN (1x)
"RTN","utt6",43,0)
 K ^TMP("%utt5_C",$J) M ^TMP("%utt5_C",$J)=^TMP("%utt5",$J)
"RTN","utt6",44,0)
 ;
"RTN","utt6",45,0)
 ; now run unit tests by GUI - first determines unit test tags
"RTN","utt6",46,0)
 W !!!,"RUNNING UNIT TESTS FOR %utt5 VIA GUI CALLS - Silent",!
"RTN","utt6",47,0)
 S ZZUTCNT=0
"RTN","utt6",48,0)
 K ^TMP("%utt5",$J),^TMP("%utt6",$J)
"RTN","utt6",49,0)
 D GUILOAD^%ut(.%utt6,"%utt5")
"RTN","utt6",50,0)
 M ^TMP("%utt6",$J)=@%utt6
"RTN","utt6",51,0)
 S %utt6=$NA(^TMP("%utt6",$J))
"RTN","utt6",52,0)
 ; then run each tag separately
"RTN","utt6",53,0)
 ; JLICNT is count of unit test tags, which can be determined for GUI call for each unit test tag
"RTN","utt6",54,0)
 S JLICNT=0 F JLII=1:1 S JLIX=$G(@%utt6@(JLII)) Q:JLIX=""  I $P(JLIX,U,2)'="" S JLICNT=JLICNT+1 D GUINEXT^%ut(.ZZUTRSLT,$P(JLIX,U,2)_U_$P(JLIX,U))
"RTN","utt6",55,0)
 ; and close it with a null routine name
"RTN","utt6",56,0)
 D GUINEXT^%ut(.ZZUTRSLT,"")
"RTN","utt6",57,0)
 K ^TMP("%utt5_G",$J) M ^TMP("%utt5_G",$J)=^TMP("%utt5",$J)
"RTN","utt6",58,0)
 S JLIEXPCT=2+(3*JLICNT) ; number of lines that should be in the global nodes for command line and GUI
"RTN","utt6",59,0)
 ;
"RTN","utt6",60,0)
 ; now run the unit tests in this routine
"RTN","utt6",61,0)
 W !!,"NOW RUNNING UNIT TESTS FOR %utt6",!!
"RTN","utt6",62,0)
 D EN^%ut("%utt6",VERBOSE)
"RTN","utt6",63,0)
 K ^TMP("%utt5",$J),^TMP("%utt5_C",$J),^TMP("%utt5_G",$J),^TMP("%utt6",$J),^TMP("%utt6_GUISET",$J)
"RTN","utt6",64,0)
 ; clean up after GUI calls as well
"RTN","utt6",65,0)
 K ^TMP("GUI-MUNIT",$J),^TMP("GUINEXT",$J),^TMP("MUNIT-%utRSLT",$J)
"RTN","utt6",66,0)
 Q
"RTN","utt6",67,0)
 ;
"RTN","utt6",68,0)
 ;
"RTN","utt6",69,0)
 ;           WARNING     --      WARNING     --      WARNING
"RTN","utt6",70,0)
 ; If the number of NEW STYLE tests in %utt5 is increased (it is currently 1), then the following
"RTN","utt6",71,0)
 ; test will need to be updated to reflect the change(s)
"RTN","utt6",72,0)
 ;     END OF WARNING  --  END OF WARNING  --  END OF WARNING
"RTN","utt6",73,0)
 ;
"RTN","utt6",74,0)
NEWSTYLE ; tests return of valid new style or @TEST indicators
"RTN","utt6",75,0)
 N LIST
"RTN","utt6",76,0)
 D NEWSTYLE^%ut1(.LIST,"%utt5")
"RTN","utt6",77,0)
 D CHKEQ^%ut(LIST,1,"Returned an incorrect number ("_LIST_") of New Style indicators - should be one")
"RTN","utt6",78,0)
 I LIST>0 D CHKEQ^%ut(LIST(1),"NEWSTYLE^identify new style test indicator functionality","Returned incorrect TAG^reason "_LIST(1))
"RTN","utt6",79,0)
 I LIST>0 D CHKEQ^%ut($G(LIST(2)),"","Returned a value for LIST(2) - should not have any value (i.e., null)")
"RTN","utt6",80,0)
 Q
"RTN","utt6",81,0)
 ;
"RTN","utt6",82,0)
CKGUISET ;
"RTN","utt6",83,0)
 ; ZEXCEPT: %utt6var - if present, is NEWed and created in code following VERBOSE
"RTN","utt6",84,0)
 I '$D(%utt6var) Q
"RTN","utt6",85,0)
 N MAX
"RTN","utt6",86,0)
 S MAX=$O(^TMP("%utt6_GUISET",$J,""),-1)
"RTN","utt6",87,0)
 D CHKTF^%ut(^TMP("%utt6_GUISET",$J,MAX)["%utt6^NEWSTYLE","GUISET returned incorrect list")
"RTN","utt6",88,0)
 Q
"RTN","utt6",89,0)
 ;
"RTN","utt6",90,0)
CHKCMDLN ; check command line processing of %utt5
"RTN","utt6",91,0)
 ; ZEXCEPT: JLIEXPCT,%utt6var - if present NEWed and created in code following VERBOSE tag
"RTN","utt6",92,0)
 I '$D(%utt6var) Q
"RTN","utt6",93,0)
 D CHKTF^%ut($D(^TMP("%utt5_C",$J,JLIEXPCT))=10,"Not enough entries in %utt5 expected "_JLIEXPCT)
"RTN","utt6",94,0)
 D CHKTF^%ut($D(^TMP("%utt5_C",$J,JLIEXPCT+1))=0,"Too many entries in %utt5 expected "_JLIEXPCT)
"RTN","utt6",95,0)
 D CHKTF^%ut($O(^TMP("%utt5_C",$J,1,""))="STARTUP","Incorrect function for entry 1,'"_$O(^TMP("%utt5_C",$J,1,""))_"' should be 'STARTUP'")
"RTN","utt6",96,0)
 D CHKTF^%ut($O(^TMP("%utt5_C",$J,JLIEXPCT,""))="SHUTDOWN","Incorrect function for entry "_JLIEXPCT_", '"_$O(^TMP("%utt5_C",$J,JLIEXPCT,""))_"' should be 'SHUTDOWN'")
"RTN","utt6",97,0)
 Q
"RTN","utt6",98,0)
 ;
"RTN","utt6",99,0)
CHKGUI ; check GUI processing of %utt5
"RTN","utt6",100,0)
 ; ZEXCEPT: JLIEXPCT,%utt6var - if present NEWed and created in code following VERBOSE tag
"RTN","utt6",101,0)
 I '$D(%utt6var) Q
"RTN","utt6",102,0)
 D CHKTF^%ut($D(^TMP("%utt5_G",$J,JLIEXPCT))=10,"Not enough entries in %utt5 expected "_JLIEXPCT)
"RTN","utt6",103,0)
 D CHKTF^%ut($D(^TMP("%utt5_G",$J,JLIEXPCT+1))=0,"Too many entries in %utt5 expected "_JLIEXPCT)
"RTN","utt6",104,0)
 D CHKTF^%ut($O(^TMP("%utt5_G",$J,1,""))="STARTUP","Incorrect function for entry 1,'"_$O(^TMP("%utt5Z_G",1,""))_"' should be 'STARTUP'")
"RTN","utt6",105,0)
 D CHKTF^%ut($O(^TMP("%utt5_G",$J,JLIEXPCT,""))="SHUTDOWN","Incorrect function for entry "_JLIEXPCT_", '"_$O(^TMP("%utt5_G",$J,JLIEXPCT,""))_"' should be 'SHUTDOWN'")
"RTN","utt6",106,0)
 Q
"RTN","utt6",107,0)
 ;
"RTN","utt6",108,0)
XTENT ;
"RTN","utt6",109,0)
 ;;CHKCMDLN;check command line processing of %utt5
"RTN","utt6",110,0)
 ;;CHKGUI;check GUI processing of %utt5
"RTN","utt6",111,0)
 ;;CKGUISET;check list of tests returned by GUISET
"RTN","utt6",112,0)
 ;;NEWSTYLE;test return of valid new style or @TEST indicators
"RTN","uttcovr")
0^9^B2835727
"RTN","uttcovr",1,0)
%uttcovr ;JLI/JIVEYSOFT - runs coverage tests on %ut and %ut1 routines via unit tests ;09/10/14  14:34
"RTN","uttcovr",2,0)
 ;;0.1;MASH UTILITIES;
"RTN","uttcovr",3,0)
 ;
"RTN","uttcovr",4,0)
 I '(+$SY=47) W !,"This coverage analysis is currently only available in GT.M" Q  ; GT.M only!
"RTN","uttcovr",5,0)
 ;
"RTN","uttcovr",6,0)
 ; if SHOWALL is true (1) all coverage globals data are listed
"RTN","uttcovr",7,0)
 ; if SHOWALL is false (0), only the %utCOVREPORT global is listed
"RTN","uttcovr",8,0)
 I '$D(SHOWALL) N SHOWALL S SHOWALL=0
"RTN","uttcovr",9,0)
 ; set global node so %utt4 doesn't run its own analysis
"RTN","uttcovr",10,0)
 S ^TMP("%uttcovr",$J)=1
"RTN","uttcovr",11,0)
 ; start analysis of %ut - it calls entry below
"RTN","uttcovr",12,0)
 D COV^%ut1("%ut","D TESTCOVR^%ut",-1)
"RTN","uttcovr",13,0)
 D LIST("%ut") ; output results of analysis
"RTN","uttcovr",14,0)
 ; start analysis of %ut1
"RTN","uttcovr",15,0)
 D COV^%ut1("%ut1","D TESTCOVR^%ut1",3)
"RTN","uttcovr",16,0)
 D LIST("%ut1")
"RTN","uttcovr",17,0)
 K ^TMP("%uttcovr",$J)
"RTN","uttcovr",18,0)
 Q
"RTN","uttcovr",19,0)
 ;
"RTN","uttcovr",20,0)
SHOWALL ; Entry to get all coverage globals listed
"RTN","uttcovr",21,0)
 N SHOWALL
"RTN","uttcovr",22,0)
 S SHOWALL=1
"RTN","uttcovr",23,0)
 D ^%uttcovr
"RTN","uttcovr",24,0)
 Q
"RTN","uttcovr",25,0)
 ;
"RTN","uttcovr",26,0)
ENTRY ;
"RTN","uttcovr",27,0)
 D ^%utt1 ; verbose
"RTN","uttcovr",28,0)
 D EN^%ut("%utt1") ; non-verbose
"RTN","uttcovr",29,0)
 ; run tests from top of %utt6, runs both command line and gui analyses
"RTN","uttcovr",30,0)
 D ^%utt6 ; non-verbose
"RTN","uttcovr",31,0)
 D VERBOSE^%utt6 ; verbose
"RTN","uttcovr",32,0)
 Q
"RTN","uttcovr",33,0)
 ;
"RTN","uttcovr",34,0)
LIST(ROU) ;
"RTN","uttcovr",35,0)
 ; ZEXCEPT: SHOWALL - NEWed and set in SHOWALL or entering at %uttcovr
"RTN","uttcovr",36,0)
 N JOB,NAME,BASE,GLOB
"RTN","uttcovr",37,0)
 S JOB=$J
"RTN","uttcovr",38,0)
 W !!!,ROU_" COVERAGE ANALYSIS"
"RTN","uttcovr",39,0)
 F NAME="%utCOVREPORT","%utCOVRESULT","%utCOVCOHORT","%utCOVCOHORTSAV" D
"RTN","uttcovr",40,0)
 . I 'SHOWALL,NAME'="%utCOVREPORT" Q
"RTN","uttcovr",41,0)
 . W !!!,NAME," GLOBAL DATA",!
"RTN","uttcovr",42,0)
 . S BASE="^TMP("""_NAME_""","_JOB,GLOB=BASE_")"
"RTN","uttcovr",43,0)
 . I $D(GLOB)#2 W !,GLOB,"=",$G(@GLOB)
"RTN","uttcovr",44,0)
 . F  S GLOB=$Q(@GLOB) Q:GLOB'[BASE  I $D(GLOB)#2 W !,GLOB,"=",@GLOB
"RTN","uttcovr",45,0)
 . Q
"RTN","uttcovr",46,0)
 Q
"SEC","^DIC",17.9001,17.9001,0,"AUDIT")
@
"SEC","^DIC",17.9001,17.9001,0,"DD")
@
"SEC","^DIC",17.9001,17.9001,0,"DEL")
@
"SEC","^DIC",17.9001,17.9001,0,"LAYGO")
@
"SEC","^DIC",17.9001,17.9001,0,"RD")
@
"SEC","^DIC",17.9001,17.9001,0,"WR")
@
"VER")
8.0^22.0
"^DD",17.9001,17.9001,0)
FIELD^^2^3
"^DD",17.9001,17.9001,0,"DT")
3140812
"^DD",17.9001,17.9001,0,"IX","B",17.9001,.01)

"^DD",17.9001,17.9001,0,"NM","MUNIT TEST GROUP")
 
"^DD",17.9001,17.9001,0,"VRPK")
MASH
"^DD",17.9001,17.9001,.01,0)
NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",17.9001,17.9001,.01,1,0)
^.1
"^DD",17.9001,17.9001,.01,1,1,0)
17.9001^B
"^DD",17.9001,17.9001,.01,1,1,1)
S ^%ut(17.9001,"B",$E(X,1,30),DA)=""
"^DD",17.9001,17.9001,.01,1,1,2)
K ^%ut(17.9001,"B",$E(X,1,30),DA)
"^DD",17.9001,17.9001,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",17.9001,17.9001,1,0)
TEST ROUTINE^17.90011^^1;0
"^DD",17.9001,17.9001,2,0)
DESCRIPTION FOR GROUP^17.90012^^2;0
"^DD",17.9001,17.9001,2,21,0)
^^3^3^3140812^
"^DD",17.9001,17.9001,2,21,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.9001,2,21,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.9001,2,21,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.9001,2,23,0)
^^3^3^3140812^
"^DD",17.9001,17.9001,2,23,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.9001,2,23,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.9001,2,23,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.9001,2,"DT")
3140812
"^DD",17.9001,17.90011,0)
TEST ROUTINE SUB-FIELD^^.01^1
"^DD",17.9001,17.90011,0,"DT")
3140731
"^DD",17.9001,17.90011,0,"IX","B",17.90011,.01)

"^DD",17.9001,17.90011,0,"NM","TEST ROUTINE")
 
"^DD",17.9001,17.90011,0,"UP")
17.9001
"^DD",17.9001,17.90011,.01,0)
TEST ROUTINE^MF^^0;1^K:$L(X)>8!($L(X)<3) X
"^DD",17.9001,17.90011,.01,1,0)
^.1
"^DD",17.9001,17.90011,.01,1,1,0)
17.90011^B
"^DD",17.9001,17.90011,.01,1,1,1)
S ^%ut(17.9001,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",17.9001,17.90011,.01,1,1,2)
K ^%ut(17.9001,DA(1),1,"B",$E(X,1,30),DA)
"^DD",17.9001,17.90011,.01,3)
This is a routine to be used for the MUnit Test Group.  Answer must be 3-8 characters in length.
"^DD",17.9001,17.90011,.01,"DT")
3140731
"^DD",17.9001,17.90012,0)
DESCRIPTION FOR GROUP SUB-FIELD^^.01^1
"^DD",17.9001,17.90012,0,"DT")
3140812
"^DD",17.9001,17.90012,0,"NM","DESCRIPTION FOR GROUP")

"^DD",17.9001,17.90012,0,"UP")
17.9001
"^DD",17.9001,17.90012,.01,0)
DESCRIPTION FOR GROUP^W^^0;1^Q
"^DD",17.9001,17.90012,.01,3)
Enter a description for the Unit Test Group
"^DD",17.9001,17.90012,.01,21,0)
^.001^3^3^3140812^^
"^DD",17.9001,17.90012,.01,21,1,0)
This word processing field provides a location for the developer to enter 
"^DD",17.9001,17.90012,.01,21,2,0)
a description of the purpose or function of the M-Unit Test Group, 
"^DD",17.9001,17.90012,.01,21,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.90012,.01,23,0)
^^3^3^3140812^
"^DD",17.9001,17.90012,.01,23,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.90012,.01,23,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.90012,.01,23,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.90012,.01,"DT")
3140812
"^DIC",17.9001,17.9001,0)
M-UNIT TEST GROUP^17.9001
"^DIC",17.9001,17.9001,0,"GL")
^%ut(17.9001,
"^DIC",17.9001,"B","M-UNIT TEST GROUP",17.9001)

**END**
**END**
